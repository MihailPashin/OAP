[содержание](/readme.md)  

# Файлы произвольного доступа. Порядок работы с файлами произвольного доступа. Создание структуры записи. Открытие и закрытие файла произвольного доступа.

## Произвольный доступ

Открывать и закрывать файлы мы уже научились на прошлой лекции. Научились читать построчно и даже весь файл целиком. Но в реальной жизни чаще приходится работать двоичными файлами и их объем может превышать объем ОЗУ, например базы данных. И для таких файлов возникает необходимость постоянно перемещаться из одной части файла в другую (индексы баз данных).

В этом случае нам поможет класс RandomAccessFile и его метод seek.

```
seek(pos: Long)->Unit
```

После вызова этого метода текущая позиция в файле устанавливается в соответствии со значением параметра pos.

В любой момент времени вы можете определить текущую позицию внутри файла, вызвав метод getFilePointer (или геттер *filePointer*):

```kt
    val raf = RandomAccessFile("./double.dat", "r")
    raf.seek(100)
    val curPos = raf.filePointer
    ...
```

## Пример чтения двоичного файла

Попробуем на практике прочитать заголовок файла формата ``*.wav``.

### Теория

Итак, рассмотрим самый обычный WAV файл (Windows PCM). Он представляет собой две, четко делящиеся, области. Одна из них – заголовок файла, другая – область данных. 

В заголовке файла хранится информация о:

* Размере файла.
* Количестве каналов.
* Частоте дискретизации.
* Количестве бит в сэмпле (эту величину еще называют глубиной звучания).

Структура заголовка:

Местоположение   | Поле          | Описание
-----------------|---------------|---------
0..3 (4 байта)   | chunkId       | Содержит символы “RIFF” в ASCII кодировке
4..7 (4 байта)   | chunkSize     | Размер файла -8 (т.е. минус два поля, которые уже считаны)
8..11 (4 байта)  | format        | Содержит символы “WAVE”
12..15 (4 байта) | subchunk1Id   | Содержит символы “fmt “ (0x666d7420 в big-endian представлении)
16..19 (4 байта) | subchunk1Size | 16 для формата PCM. Это оставшийся размер подцепочки, начиная с этой позиции.
20..21 (2 байта) | audioFormat   | Аудио формат, для PCM = 1 (то есть, Линейное квантование). Значения, отличающиеся от 1, обозначают некоторый формат сжатия.
22..23 (2 байта) | numChannels   | Количество каналов. Моно = 1, Стерео = 2 и т.д.
24..27 (4 байта) | sampleRate    | Частота дискретизации. 8000 Гц, 44100 Гц и т.д.
28..31 (4 байта) | byteRate      | Количество байт, передаваемых за секунду воспроизведения.
32..33 (2 байта) | blockAlign    | Количество байт для одного сэмпла, включая все каналы.
34..35 (2 байта) | bitsPerSample | Количество бит в сэмпле. Так называемая “глубина” или точность звучания. 8 бит, 16 бит и т.д.
36..39 (4 байта) | subchunk2Id   | Содержит символы “data” (0x64617461 в big-endian представлении)
40..43 (4 байта) | subchunk2Size | Количество байт в области данных.

Дальше идут собственно данные.

Пример программы чтения заголовка файла WAV.

> В принципе из файла можно читать сразу Byte, Short, Int... Но в Java (Котлине) эти типы хранятся в формате Big-endian, а во многих других языках в формате Little-endian. Поэтому приходится считывать данные в буфер, устанавливать порядок байт для этого буфера и только потом считывать данные

```kt
fun main(args: Array<String>){
    val file = File("./test.wav")
    // у объекта File можно узнать размер и есть ли файл с таким именем на диске
    if(file.exists() && file.length()>43){
        //открываем файл
        val raf = RandomAccessFile("./test.wav", "r")
        try {
            // объявляем буфер
            val header = ByteBuffer.wrap(ByteArray(44)).order(ByteOrder.LITTLE_ENDIAN)
            val ba4 = ByteArray(4)

            // считываем в буфер весь заголовок
            raf.read(header.array())

            // считываем и проверяем заголовок
            header.get(ba4)
            if (String(ba4).compareTo("RIFF") == 0) {
                val chunkSize = header.getInt()
                //read format
                header.get(ba4)
                if (String(ba4).compareTo("WAVE") == 0) {
                    //read subchunk1Id
                    header.get(ba4)
                    if (String(ba4).compareTo("fmt ") == 0) {
                        val subchunk1Size = header.getInt()
                        val audioFormat = header.getShort()
                        var numChannels = header.getShort()
                        val sampleRate = header.getInt()
                        val byteRate = header.getInt()
                        val blockAlign = header.getShort()
                        val bitsPerSample = header.getShort()

                        //read subchunk2Id
                        header.get(ba4)
                        if (String(ba4).compareTo("data") == 0) {
                            val subchunk2Size = header.getInt()

                            println("Размер файла: ${chunkSize + 8}")
                            println("Аудиоформат: ${if (audioFormat.equals(1)) "PCM" else "сжатый"}")
                            println("Количество каналов: $numChannels")
                            println("Частота дискретизации: $sampleRate Гц")
                            println("Битрейт: $byteRate байт/сек")
                            println("Размер блока: $blockAlign байт")
                            println("Глубина звучания (BPS): $bitsPerSample бит")
                            println("Размер блока данных: $subchunk2Size байт")

                        }
                    }
                }
            }
        } finally {
            raf.close()
        }
    }
}
```

Получим примерно такой результат:
```
Размер файла: 6756
Аудиоформат: PCM
Количество каналов: 2
Частота дискретизации: 11025Гц
Битрейт: 22050 байт/сек
Размер блока: 2 байт
Глубина звучания (BPS): 8 бит
```


[содержание](/readme.md)  
