[содержание](/readme.md)  

# Основы языка Kotlin

* [Условные выражения](#Условные-выражения)
* [Условные конструкции](#Условные-конструкции)
* [Циклы](#Циклы)
* [Последовательности](#Последовательности)

## Условные выражения

Условные выражения представляют некоторое условие, которое возвращает значение типа Boolean: либо true (если условие истинно), либо false (если условие ложно).

### Операции отношения
``>`` (больше чем): возвращает true, если первый операнд больше второго. Иначе возвращает false

```kt
val a = 11
val b = 12
val c : Boolean =  a > b
println(c)      // false - a меньше чем b
 
val d = 35 > 12
println(d)      // true - 35 больше чем 12
```

``<`` (меньше чем): возвращает true, если первый операнд меньше второго. Иначе возвращает false

```kt
val a = 11
val b = 12
val c =  a < b   // true
 
val d = 35 < 12  // false
```

``>=`` (больше чем или равно): возвращает true, если первый операнд больше или равен второму

```kt
val a = 11
val b = 12
val c = a >= b      // false
val d = 11 >= a     // true
```

``<=`` (меньше чем или равно): возвращает true, если первый операнд меньше или равен второму.

```kt
val a = 11
val b = 12
val c = a <= b      // true
val d = 11 <= a     // false
```

``==`` (равно): возвращает true, если оба операнда равны. Иначе возвращает false

```kt
val a = 11
val b = 12
val c = a == b      // false
val d = b == 12     // true
```

``!=`` (не равно): возвращает true, если оба операнда НЕ равны

```kt
val a = 11
val b = 12
val c = a != b      // true
val d = b != 12     // false
```

### Логические операции

Операндами в логических операциях являются два значения типа Boolean. Нередко логические операции объединяют несколько операций отношения:

**and**: возвращает true, если оба операнда равны true.

```kt
val a = true
val b = false
val c = a and b                         // false
val d = (11 >= 5) and (9 < 10)     // true
println(c)
println(d)
```

**or**: возвращает true, если хотя бы один из операндов равен true.

```kt
val a = true
val b = false
val c = a or b                          // true
val d = (11 < 5) or (9 > 10)     // false
```

**xor**: возвращает true, если только один из операндов равен true. Если операнды равны возвращается false

```kt
val a = true
val b = false
val c = a xor b                 // true
val d = a xor (90 > 10)      // false
```

**!**: возвращает true, если операнд равен false. И, наоборот, если операнд равен false, возвращает true.

```kt
val a = true
val b = !a  // false
val c = !b  // true
```

В качестве альтернативы оператору ! можно использовать метод not():

```kt
val a = true
val b = a.not()  // false
val c = b.not()  // true
```

**in**: возвращает true, если операнд имеется в некоторой последовательности.

```kt
val a = 5
val b = a in 1..6       // true
```

Выражение 1..6 создает последовательность чисел от 1 до 6. И в данном случае оператор in проверяет, есть ли значение переменной a в этой последовательности. Поскольку значение переменной a имеется в данной последовательности, то возвращается true.

## Условные конструкции

Условные конструкции позволяют направить выполнение программы по одному из путей в зависимости от условия.

### if...else

Конструкция if принимает условие, и если это условие истинно, то выполняется последующий блок инструкций.

```kt
val a = 10
if(a == 10) {
    println("a равно 10")
}
```

В данном случае в конструкции if проверяется истинность выражения a == 10, если оно истинно, то выполняется последующий блок кода в фигурных скобках, и на консоль выводится сообщение "a равно 10". Если же выражение ложно, тогда блок кода не выполняется.

Если необходимо задать альтернативный вариант, то можно добавить блок else:

```kt
val a = 10
if(a == 10) {
    println("a равно 10")
}
else{
    println("a НЕ равно 10")
}
```

Таким образом, если условное выражение после оператора if истинно, то выполняется блок после if, если ложно - выполняется блок после else.

Если блок кода состоит из одного выражения, то в принципе фигурные скобки можно опустить:

```kt
val a = 10
if(a == 10)
    println("a равно 10")
else
    println("a НЕ равно 10")
```

Если необходимо проверить несколько альтернативных вариантов, то можно добавить выражения else if:

```kt
val a = 10
if(a == 10) {
    println("a равно 10")
}
else if(a == 9){
    println("a равно 9")
}
else if(a == 8){
    println("a равно 8")
}
else{
    println("a имеет неопределенное значение")
}
```

Стоит отметить, что конструкция if может возвращать значение. Например, найдем максимальное из двух чисел:

```kt
val a = 10
val b = 20
val c = if (a > b) a else b
 
println(c)  // 20
```

Если при определении возвращаемого значения надо выполнить еще какие-нибудь действия, то можно заключить эти действия в блоки кода:

```kt
val a = 10
val b = 20
val c = if (a > b){
    println("a = $a")
    a
} else {
    println("b = $b")
    b
}
```

В конце каждого блока указывается возвращаемое значение.

### Конструкция when

Конструкция when проверяет значение некоторого объекта и в зависимости от его значения выполняет тот или иной код. Конструкция when аналогична конструкции switch в других языках.

```kt
val a = 10
when(a){
    10 -> println("a = 10")
    20 -> println("a = 20")
    else -> println("неопределенное значение")
}
```

После ключевого слова when в скобках идет выражение. Затем идет блок кода, в котором определяются значения для сравнения. После каждого значения после стрелки -> идет последовательность выполняемых инструкций:

```kt
10 -> println("a = 10")
```

То есть в данном случае если переменная a равна 10, то на консоль будет выводиться сообщение "a = 10".

Если ни одно из значений в блоке when не соответствуют выражению, то выполняются инструкции из выражения else. Выражение else не обязательное, его можно не определять.

Если надо, чтобы при совпадении значений выполнялось несколько инструкций, то для каждого значения можно определить блок кода:

```kt
var a = 10
when(a){
    10 -> {
        println("a = 10")
        a *= 2
    }
    20 -> {
        println("a = 20")
        a *= 5
    }
    else -> { println("неопределенное значение")}
}
println(a)
```

Можно определить одни и те же действия сразу для нескольких значений. В этом случае значения перечисляются через запятую:

```kt
val a = 10
when(a){
    10, 20 -> println("a = 10 или a = 20")
    else -> println("неопределенное значение")
}
```

Также можно сравнивать с целым диапазоном значений с помощью оператора in:

```kt
val a = 10
when(a){
    in 10..19 -> println("a в диапазоне от 10 до 19")
    in 20..29 -> println("a в диапазоне от 20 до 29")
    !in 10..20 -> println("a вне диапазона от 10 до 20")
    else -> println("неопределенное значение")
}
```

Если оператор in позволяет узнать, есть ли значение в определенном диапазоне, то связка операторов !in позволяет проверить отсутствие значения в определенной последовательности.

#### Возвращение значения

Как и if конструкция when может возвращать значение:

```kr
val sum = 1000
 
val rate = when(sum){
    in 100..999 -> 10
    in 1000..9999 -> 15
    else -> 20
}
println(rate)       // 15
```

Таким образом, если значение переменной sum располагается в определенном диапазоне, то возвращается то значение, которое идет после стрелки.

Также вместе с when-выражениями работают умные приведения (is, !is)

```kt
when (x) {
    is Int -> print(x + 1)
    is String -> print(x.length + 1)
    is IntArray -> print(x.sum())
}
```

when удобно использовать вместо цепочки условий вида if-else if. При отстутствии аргумента, условия работают как простые логические выражения, а тело ветки выполняется при его истинности:

```kt
when {
  x.isOdd() -> print("x is odd")
  x.isEven() -> print("x is even")
  else -> print("x is funny")
}
```

## Циклы

Циклы представляют вид управляющих конструкций, которые позволяют в зависимости от определенных условий выполнять некоторое действие множество раз.

### For

Цикл for пробегается по всем элементам коллекции. В этом плане цикл for в Kotlin эквивалентен циклу for-each в ряде других языков программирования. Его формальная форма выглядит следующим образом:

```kt
for(переменная in поледовательность){
    выполняемые инструкции
}
```

Например, выведем все квадраты чисел от 1 до 9, используя цикл for:

```kt
for(n in 1..9){
    print("${n * n} \t")
}
```

В данном случае перебирается последовательность чисел от 1 до 9. При каждом проходе цикла (итерации цикла) из этой последовательности будет извлекаться элемент и помещаться в переменную n. И через переменную n можно манипулировать значением элемента. То есть в данном случае мы получим следующий консольный вывод:

```
1 	4 	9 	16 	25 	36 	49 	64 	81
```

Циклы могут быть вложенными. Например, выведем таблицу умножения:

```kt
for(i in 1..9){
    for(j in 1..9){
        print("${i * j} \t")
    }
    println()
}
```

В итоге на консоль будет выведена следующая таблица умножения:

```
1 	2 	3 	4 	5 	6 	7 	8 	9 	
2 	4 	6 	8 	10 	12 	14 	16 	18 	
3 	6 	9 	12 	15 	18 	21 	24 	27 	
4 	8 	12 	16 	20 	24 	28 	32 	36 	
5 	10 	15 	20 	25 	30 	35 	40 	45 	
6 	12 	18 	24 	30 	36 	42 	48 	54 	
7 	14 	21 	28 	35 	42 	49 	56 	63 	
8 	16 	24 	32 	40 	48 	56 	64 	72 	
9 	18 	27 	36 	45 	54 	63 	72 	81
```

### Цикл while

Цикл while повторяет определенные действия пока истинно некоторое условие:

```kt
var i = 10
while(i > 0){
    println(i*i)
    i--;
}
```

Здесь пока переменная i больше 0, будет выполняться цикл, в котором на консоль будет выводиться квадрат значения i.

В данном случае вначале проверяется условие (i > 0) и если оно истинно (то есть возвращает true), то выполняется цикл. И вполне может быть ситуация, когда к началу выполнения цикла условие не будет выполняться. Например, переменная i изначально меньше 0, тогда цикл вообще не будет выполняться.

Но есть и другая форма цикла while - do..while:

```kt
var i = -1
do{
    println(i*i)
    i--;
}
while(i > 0)
```

В данном случае вначале выполняется блок кода после ключевого слова do, а потом оценивается условие после while. Если условие истинно, то повторяется выполнение блока после do. То есть несмотря на то, что в данном случае переменная i меньше 0 и она не соответствует условию, тем не менее блок do выполнится хотя бы один раз.

### Операторы continue и break

Иногда при использовании цикла возникает необходимость при некоторых условиях не дожидаться выполнения всех инструкций в цикле, перейти к новой итерации. Для этого можно использовать оператор continue:

```kt
for(n in 1..8){
    if(n == 5) continue;
    println(n * n)
}
```

В данном случае когда n будет равно 5, сработает оператор continue. И последующая инструкция, которая выводит на консоль квадрат числа, не будет выполняться. Цикл перейдет к обработке следующего элемента в массиве

Бывает, что при некоторых условиях нам вовсе надо выйти из цикла, прекратить его выполнение. В этом случае применяется оператор break:

```kt
for(n in 1..5){
    if(n == 5) break;
    println(n * n)
}
```

В данном случае когда n окажется равен 5, то с помощью оператора break будет выполнен выход из цикла. Цикл полностью завершится.

## Последовательности

Последовательность представляет набор значений или диапазон. Для создания последовательности применяется оператор ..:

```kt
var range = 1..5    // последовательность [1, 2, 3, 4, 5]
```

Этот оператор принимает два значения - границы последовательности, и все элементы между этими значениями (включая их самих) составляют последовательность.

Последовательность необязательно должна представлять числовые данные. Например, это могут быть строки:

```kt
var range =  "a".."d"
```

Оператор .. позволяет создать последовательность по нарастающей, где каждый следующий элемент будет больше предыдущего. С помощью специальной функции downTo можно построить последовательность в обратном порядке:

```kt
var range1 =  1..5      // 1 2 3 4 5
var range2 =  5 downTo 1    // 5 4 3 2 1
```

Еще одна специальная функция step позволяет задать шаг, на который будут изменяться последующие элементы:

```kt
var range1 = 1..10 step 2           // 1 3 5 7 9
var range2 = 10 downTo 1 step 3     // 10 7 4 1
```

Еще одна функция until позволяет не включать верхнюю границу в саму последовательность:

``` kt
var range1 = 1 until 9          // 1 2 3 4 5 6 7 8
var range2 = 1 until 9 step 2   // 1 3 5 7
```

С помощью специальных операторов можно проверить наличие или отсутствие элементов в последовательности:

in: возвращает true, если объект имеется в последовательности

!in: возвращает true, если объект отсутствует в последовательности

```kt
fun main(args: Array<String>) {
     var range = 1..5
 
    var isInRange = 5 in range
    println(isInRange)      // true
 
    isInRange = 86 in range
    println(isInRange)      // false
 
    var isNotInRange = 6 !in range
    println(isNotInRange)   // true
 
    isNotInRange = 3 !in range
    println(isNotInRange)   // false
}
```

С помощью цикла for можно перебирать последовательность:

```kt
var range1 = 5 downTo 1 
for(c in range1) print(c)   // 54321
println()
for(c in 1..9) print(c)     // 123456789
println()
for(c in 1 until 9) print(c)    // 12345678
println()
for(c in 1..9 step 2) print(c)  // 13579
```

[содержание](/readme.md)  
