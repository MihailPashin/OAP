[содержание](/readme.md)  

# Параметры командной строки.

До этого мы параметры получали в интерактивном режиме командой *input*, но реально этот способ получения параметров используется редко, только в образовательных целях. Чаще всего параметры берутся из файла настроек или из командной строки.

Первый способ подходит если параметры задаются один раз при настройке программы и не изменяются при последующей работе.

Второй способ - передача параметров при вызове программы через командную строку - используется, когда параметры вызова заранее не известны и применяются в скриптах.

Путь для начала у нас есть простейший скрипт на Python. Это будет классический Hello World, над которым мы будем работать в дальнейшем.

```py
if __name__ == "__main__":
    print ("Привет, мир!")
```

Мы завершили эту сложнейшую программу и отдали ее заказчику, он доволен, но просит добавить в нее возможность указывать имя того, кого приветствуем, причем этот параметр может быть не обязательным. Т.е. программа может использоваться двумя путями:

```
python coolprogram.py
```

или

```
python coolprogram.py Вася
```

Первое, что приходит на ум при решении такой задачи, просто воспользоваться переменной *argv* из модуля *sys*. Эта переменная содержит список параметров, переданных программе через командную строку, причем нулевой элемент списка - это имя нашего скрипта. Т.е. если у нас есть следующий скрипт с именем params.py:

```py
import sys

if __name__ == "__main__":
    for param in sys.argv:
        print (param)
```

и мы запускаем его с помощью команды

```
python params.py
```

то в консоль будет выведена единственная строка:

```
params.py
```

Если же мы добавим несколько параметров,

```
python params.py param1 param2 param3
```

то эти параметры мы увидим в списке sys.argv, начиная с первого элемента:

```
params.py
param1
param2
param3
```

>Так как мы пишем и отлаживаем наш код на VSC, то сразу расскажу как добавить параметры командной строки в отладчик:
>1. Перейдите в режим отладки 
>2. Откройте выпадающий список конфигураций отладчика
>3. Выберите пункт "добавить конфигурацию"
>
>![добавление параметров командной строки в отладчик](../img/t7l3p1.png)
>
>а затем, в блок настроек "Python: Current File (Integrated Terminal)" (Текущий файл (интегрированный терминал)), добавьте массив **args**, не забыв поставить перед ним запятую. Обратите внимание: каждый параметр нужно записывать отдельным элементом массива.
>
>![добавление параметров командной строки в отладчик](../img/t7l3p2.png)

Вернемся к нашей задаче. Погрузившись в код на неделю, мы могли бы выдать заказчику следующий скрипт:

```py
import sys

if __name__ == "__main__":
    if len (sys.argv) > 1:
        print ("Привет, {}!".format (sys.argv[1] ) )
    else:
        print ("Привет, мир!")
```
Теперь, если программа вызывается с помощью команды

``python coolprogram.py``

то результат будет прежний

``Привет, мир!``

а если мы добавим параметр:

``python coolprogram.py Вася``

то программа поприветствует некоего Васю:

``Привет, Вася!``

Пока все легко и никаких проблем не возникает. Теперь предположим, что требования заказчика вновь изменились, и на этот раз он хочет, чтобы имя приветствуемого человека передавалось после именованного параметра --name или -n, причем нужно следить, что в командной строке передано только одно имя. С этого момента у нас начнется вермишель из конструкций if.

```py
import sys

if __name__ == "__main__":
    if len (sys.argv) == 1:
        print ("Привет, мир!")
    else:
        if len (sys.argv) < 3:
            print ("Ошибка. Слишком мало параметров.")
            sys.exit (1)

        if len (sys.argv) > 3:
            print ("Ошибка. Слишком много параметров.")
            sys.exit (1)

        param_name = sys.argv[1]
        param_value = sys.argv[2]

        if (param_name == "--name" or
                param_name == "-n"):
            print ("Привет, {}!".format (param_value) )
        else:
            print ("Ошибка. Неизвестный параметр '{}'".format (param_name) )
            sys.exit (1)
```

Здесь мы проверяем ситуацию, что мы вообще не передали ни одного параметра, потом проверяем, что дополнительных параметров у нас ровно два, что они называются именно --name или -n, и, если нас все устраивает, выводим приветствие.

Как видите, код превратился в тихий ужас. Изменить логику работы в нем в дальнейшем будет очень сложно, а при увеличении количества параметров нужно будет срочно применять объектно-ориентированные меры по отделению логики работы программы от разбора командной строки. Разбор командной строки мы могли бы выделить в отдельный класс (или классы), но мы этого здесь делать не будем, поскольку все уже сделано в стандартной библиотеке Python, которая называется **argparse**.

## Использование библиотеки **argparse**

Как как было сказано выше, стандартная библиотека **argparse** предназначена для облегчения разбора командной строки. На нее можно возложить проверку переданных параметров: их количество и обозначения, а уже после того, как эта проверка будет выполнена автоматически, использовать полученные параметры в логике своей программы.

Основа работы с командной строкой в библиотеке **argparse** является класс **ArgumentParser**. У его конструктора и методов довольно много параметров, все их рассматривать не будем, поэтому в дальнейшем рассмотрим работу этого класса на примерах, попутно обсуждая различные параметры.

Простейший принцип работы с **argparse** следующий:

* Создаем экземпляр класса ArgumentParser.
* Добавляем в него информацию об ожидаемых параметрах с помощью метода add_argument (по одному вызову на каждый параметр).
* Разбираем командную строку помощью метода parse_args, передавая ему полученные параметры командной строки (кроме нулевого элемента списка sys.argv).
* Начинаем использовать полученные параметры.

Для начала перепишем программу coolprogram.py с единственным параметром так, чтобы она использовала библиотеку argparse. Напомню, что данном случае мы ожидаем следующий синтаксис параметров:

``python coolprogram.py [Имя]``

Здесь [Имя] является необязательным параметром.

Наша программа с использованием **argparse** может выглядеть следующим образом:

```py
import sys
import argparse
 
def createParser ():
    parser = argparse.ArgumentParser()
    parser.add_argument ('name', nargs='?')
    return parser
 
if __name__ == '__main__':
    parser = createParser()
    namespace = parser.parse_args()

    # print (namespace)
       
    if namespace.name:
        print ("Привет, {}!".format (namespace.name) )
    else:
        print ("Привет, мир!")
```

На первый взгляд эта программа работает точно так же, как и раньше, хотя есть отличия, но мы их рассмотрим чуть позже. Пока разберемся с тем, что мы понаписали в программе.

Создание парсера вынесено в отдельную функцию, поскольку эта часть программы в будущем будет сильно изменяться и разрастаться. Сначала мы создали экземпляр класса ArgumentParser с параметрами по умолчанию. Что это за параметры, опять же, поговорим чуть позже.

Далее мы добавили ожидаемый параметр в командной строке с помощью метода add_argument. При этом такой параметр будет считаться позиционным, т.е. он должен стоять именно на этом месте и у него не будет никаких предварительных обозначений (мы их добавим позже в виде '-n' или '--name'). Если бы мы не добавили именованный параметр nargs='?', то этот параметр был бы обязательным. nargs может принимать различные значения. Если бы мы ему присвоили целочисленное значение больше 0, то это бы означало, что мы ожидаем ровно такое же количество передаваемых параметров (точнее, считалось бы, что первый параметр ожидал бы список из N элементов, разделенных пробелами, этот случай мы рассмотрим позже). Также этот параметр может принимать значение '?', '+', '*' и argparse.REMAINDER. 

Итак, мы создали парсер, после чего можно вызвать его метод parse_args для разбора командной строки. Если мы не укажем никакого параметра, это будет означать равносильно тому, что мы передадим в него все параметры из sys.argv кроме нулевого, который содержит имя нашей программы. т.е.

```py
parser.parse_args (sys.argv[1:])
```

В качестве результата мы получим экземпляр класса Namespace, который будет содержать в качестве члена имя нашего параметра. Теперь можно раскомментировать строку 

```
# print (namespace)
```

в приведенном выше примере, чтобы посмотреть, чему же равны наши параметры.

Если мы это сделаем и запустим программу с переданным параметром

```
python coolprogram.py Вася
```

, то увидим его в пространстве имен.

```
Namespace(name='Вася')
```

Если же теперь мы запустим программу без дополнительных параметров, то это значение будет равно None:

```
Namespace(name=None)
```

Мы можем изменить значение по умолчанию, что позволит нам несколько сократить программу. Пусть по умолчанию используется слово 'мир', ведь мы его приветствуем, если параметры не переданы. Для этого воспользуемся дополнительным именованным параметром default в методе add_argument.

```py
import sys
import argparse
  
def createParser ():
    parser = argparse.ArgumentParser()
    parser.add_argument ('name', nargs='?', default='мир')
    return parser
 
if __name__ == '__main__':
    parser = createParser()
    namespace = parser.parse_args (sys.argv[1:])
    print ("Привет, {}!".format (namespace.name) )
```

Программа продолжает работать точно также, как и раньше. Вы, наверное, заметили, что в предыдущем примере в метод parse_args передаются параметры командной строки из sys.argv. Это сделано для того, чтобы показать, что список параметров мы можем передавать явно, при необходимости мы его можем предварительно обработать, хотя это вряд ли понадобится, ведь почти всю обработку можно возложить на плечи библиотеки **argparse**.

## Добавляем именованные параметры

Теперь снова переделаем нашу программу таким образом, чтобы использовать именованные параметры. Напомню, что согласно последнему желанию заказчика имя приветствуемого человека должно передаваться после параметра --name или -n. С помощью argparse сделать это проще простого - достаточно в качестве первых двух параметров метода add_argument передать эти имена параметров.

```py
import sys
import argparse
 
def createParser ():
    parser = argparse.ArgumentParser()
    parser.add_argument ('-n', '--name', default='мир')
    return parser
 
if __name__ == '__main__':
    parser = createParser()
    namespace = parser.parse_args()
    print ("Привет, {}!".format (namespace.name) )
```

Теперь, если мы запустим программу без параметров, то увидим знакомое "Привет, мир!", а если мы запустим программу с помощью команды

```
python coolprogram.py -n Вася
```

или

```
python coolprogram.py --name Вася
```

То приветствовать программа будет Васю. Обратите внимание, что теперь в методе add_argument мы убрали параметр nargs='?' , поскольку все именованные параметры считаются необязательными. А если они не обязательные, то возникает вопрос, как поведет себя argparse, если этот параметр не передан? Для этого уберем параметр default в add_argument.

```py
import sys
import argparse
 
def createParser ():
    parser = argparse.ArgumentParser()
    parser.add_argument ('-n', '--name')
    return parser
 
if __name__ == '__main__':
    parser = createParser()
    namespace = parser.parse_args()
    print ("Привет, {}!".format (namespace.name) )
```    

Если теперь запустить программу без параметров, то увидим приветствие великого None:

```
Привет, None!
```

Таким образом, если значение по умолчанию не указано, то оно считается равным None.

>Раньше мы на это не обращали внимание, но нужно все-таки сказать, что argparse по умолчанию заточен для создания интерфейса командной строки именно в стиле UNIX, где именованные параметры начинаются с символов "-" или "--". Если такой параметр попытаться называть в стиле Windows (например, "/name"), то будет брошено исключение:
>
>```
>ValueError: invalid option string '/name': must start with a character '-'
>```
>
>На самом деле буквально с помощью одного параметра мы можем заставить работать argparse в стиле Windows, достаточно в параметры конструктора добавить **prefix_chars**: 
>
>```py
>parser = argparse.ArgumentParser(prefix_chars='/')
>```


До этого мы задавали два имени для одного и того же параметра: длинное имя, начинающееся с "--" (--name) и короткое сокращение, начинающееся с "-" (-n). При этом получение значение параметра из пространства имен осуществляется по длинному имени:

```
print ("Привет, {}!".format (namespace.name) )
```

Если мы не зададим длинное имя, то придется обращаться к параметру через его короткое имя (n):

```py
import sys
import argparse
 
def createParser ():
    parser = argparse.ArgumentParser()
    parser.add_argument ('-n')
    return parser
 
if __name__ == '__main__':
    parser = createParser()
    namespace = parser.parse_args()
    print (namespace)
    print ("Привет, {}!".format (namespace.n) )
```

При этом пространство имен будет выглядеть как:

```
Namespace(n='Вася')
```

Хорошо, с уменьшением количества имен параметров разобрались, но мы можем еще и увеличить количество имен, например, мы можем добавить для того же параметра еще новое имя --username, для этого достаточно его добавить следующим параметром метода add_argument:

```py
import sys
import argparse
 
def createParser ():
    parser = argparse.ArgumentParser()
    parser.add_argument ('-n', '--name', '--username')
    return parser
 
if __name__ == '__main__':
    parser = createParser()
    namespace = parser.parse_args()
    print (namespace)
    print ("Привет, {}!".format (namespace.name) )
```

Теперь мы можем использовать три варианта передачи параметров:

```
python coolprogram.py -n Вася
python coolprogram.py --name Вася
python coolprogram.py --username Вася
```

Все три варианта равнозначны, при этом надо обратить внимание, что при получении значения этого параметра используется первое длинное имя, т.е. name. Пространство имен при использовании всех трех вариантов вызова программы будет выглядеть одинаково:

```
Namespace(name='Вася')
```

## Параметры как списки

До сих пор мы ожидали, что в качестве значения параметра выступает строка, но бывают ситуации, когда необходимо, чтобы в качестве значения параметра принимался список строк. Например, пусть нам теперь нужно изменить программу так, чтобы мы могли приветствовать нескольких человек. Первое, что приходит на ум - это вручную разобрать строку после имени параметра, т.е.

```py
import sys
import argparse
 
def createParser ():
    parser = argparse.ArgumentParser()
    parser.add_argument ('-n', '--name', default='мир')
    return parser
 
if __name__ == '__main__':
    parser = createParser()
    namespace = parser.parse_args()
 
    print (namespace)
 
    for name in namespace.name.split():
        print ("Привет, {}!".format (name) )
```

Но это не самое лучшее решение, поскольку если пользователь захочет передать несколько параметров после --name, то ему придется оборачивать список имен в кавычки:

```
python coolprogram.py --name "Вася Оля Петя"
```

Поскольку, если написать просто

```
python coolprogram.py --name Вася Оля Петя
```

, то argparse решит, что "Оля Петя" - это отдельные параметры, имя для которых не задано, и напишет ошибку:

```
error: unrecognized arguments: Оля Петя
```

Чтобы указать библиотеке argparse, что значений параметров у нас может быть несколько, вспомним уже используемый нами параметр nargs. Но если в прошлый раз в качестве его значения мы использовали значение "?", обозначающее, что у нас может быть 0 или 1 значение, то теперь мы будем использовать значение nargs='+', обозначающее, что мы ожидаем одно или более значение (по аналогии с регулярными выражениями).

```py
import sys
import argparse
 
def createParser ():
    parser = argparse.ArgumentParser()
    parser.add_argument ('-n', '--name', nargs='+', default=['мир'])
    return parser
 
 
if __name__ == '__main__':
    parser = createParser()
    namespace = parser.parse_args()
    print (namespace)
    for name in namespace.name:
        print ("Привет, {}!".format (name) )
```

Обратите внимание, что здесь в качестве значения по умолчанию используется список из одного слова.

Теперь, если мы выполним эту программу с помощью команды

```
python coolprogram.py --name Вася Оля Петя
```

То программа нам выведет:

```
Namespace(name=['Вася', 'Оля', 'Петя'])
Привет, Вася!
Привет, Оля!
Привет, Петя!
```

Таким образом, мы возложили задачу разделения параметров на плечи argparse. Напомню, что nargs может принимать и другие значения, в том числе целое число N, обозначающее, что мы ожидаем ровно N значений.

## Указание типов параметров

До сих пор мы в качестве входных параметров использовали строки, что логично, поскольку на самом нижнем уровне все входные параметры считаются строками. Однако часто на практике в качестве параметров хотелось бы использовать другие типы: целые числа или числа с плавающей точкой. Конечно, не проблема вручную преобразовать строку в нужный тип или написать ошибку в случае, если этого сделать невозможно. Однако, даже такую мелочь можно переложить на argparse. Для этого достаточно добавить еще один именованный параметр в метод add_argument, а именно параметр type, который будет указывать ожидаемый тип значения параметра. Изменим пример таким образом, чтобы в качестве входного параметра с именем -c или --count принималось целое число, которое обозначает, сколько раз нужно вывести строку "Привет, мир!" (временно забудем про параметры -n и --name).

```py
import sys
import argparse
 
def createParser ():
    parser = argparse.ArgumentParser()
    parser.add_argument ('-c', '--count', default=1, type=int)
    return parser
 
if __name__ == '__main__':
    parser = createParser()
    namespace = parser.parse_args()
    print (namespace)
    for _ in range (namespace.count):
        print ("Привет, мир!")
```

Нас здесь больше всего интересует строка, где мы указали ожидаемый тип параметра. Обратите внимание, что в качестве значения параметра type мы передали не строку, а тип ожидаемых данных. В остальном там нет никаких особенностей.

В следующем блоке показан пример работы этой программы:

```
python coolprogram.py --count 5

Namespace(count=5)
Привет, мир!
Привет, мир!
Привет, мир!
Привет, мир!
Привет, мир!
```

Здесь мы видим, что в пространстве имен параметр count сразу записан как целое число (без кавычек). Если же мы попытаемся передать в качестве параметра какую-то строку, которую преобразовать в целое число невозможно, то мы получим ошибку:

```
python coolprogram.py --count Абырвалг

usage: coolprogram.py [-h] [-c COUNT]
coolprogram.py: error: argument -c/--count: invalid int value: 'Абырвалг'
```

## Имена файлов как параметры

Но это не все возможности параметра type. Во многих программах в качестве входных параметров используются имена файлов, которые нужно прочитать. При этом имена файлов передают обычно не просто так, эти файлы или читают, или в них что-то пишут, а, как известно, открытие файла - это лотерея, может быть он откроется, а может и нет, здесь всегда надо ловить исключения. А раз это такая частая операция, то argparse позволяет и это автоматизировать.

Для примера напишем программу, которая просто выводит содержимое текстового файла, имя которого задается после именованного параметра -n или --name Для работы программы понадобится дополнительный файл "text.txt" для простоты в кодировке UTF-8.

Для того, чтобы указать argparse, что в качестве входного параметра мы ожидаем файл, который должен быть открыт для чтения, в метод add_argument нужно передать параметр type, равный open (опять же, это стандартная функция для открытия файла, а не строка). Использование этого параметра показано ниже:

```py
import sys
import argparse
 
def createParser ():
    parser = argparse.ArgumentParser()
    parser.add_argument ('-n', '--name', type=open)
    return parser
 
if __name__ == '__main__':
    parser = createParser()
    namespace = parser.parse_args()
    print (namespace)
    text = namespace.name.read()
    print (text)
```

Если вы запустите этот пример, то кроме содержимого файла, переданного в качестве параметра --name, увидите, что пространство имен namespace будет содержать уже открытый файл:

```
python coolprogram.py --name text.txt

Namespace(name=<_io.TextIOWrapper name='text.txt' mode='r' encoding='UTF-8'>)
Содержимое текстового файла
```

Если же мы укажем имя несуществующего файла, то получим исключение:

```
python coolprogram.py --name invalid.txt
 
Traceback (most recent call last):
  File "coolprogram.py", line 16, in <module>
    namespace = parser.parse_args(sys.argv[1:])
  File "/usr/lib/python3.3/argparse.py", line 1714, in parse_args
    args, argv = self.parse_known_args(args, namespace)
  File "/usr/lib/python3.3/argparse.py", line 1746, in parse_known_args
    namespace, args = self._parse_known_args(args, namespace)
  File "/usr/lib/python3.3/argparse.py", line 1952, in _parse_known_args
    start_index = consume_optional(start_index)
  File "/usr/lib/python3.3/argparse.py", line 1892, in consume_optional
    take_action(action, args, option_string)
  File "/usr/lib/python3.3/argparse.py", line 1804, in take_action
    argument_values = self._get_values(action, argument_strings)
  File "/usr/lib/python3.3/argparse.py", line 2247, in _get_values
    value = self._get_value(action, arg_string)
  File "/usr/lib/python3.3/argparse.py", line 2276, in _get_value
    result = type_func(arg_string)
FileNotFoundError: [Errno 2] No such file or directory: 'invalid.txt'
```

Как видно из строк 4-5, исключение будет брошено при попытке разобрать параметры с помощью метода parse_args. Сначала кажется странным, что argparse не обрабатывает такую простую ситуацию, бросая такое некрасивое исключение. Казалось бы, почему бы библиотеке самой его не обработать и не вывести ошибку, как это было сделано при использовании параметра type=int?

Несмотря на то, что использование параметра type=open описано в документации, на мой взгляд его лучше не использовать в таком виде, поскольку argparse предлагает более красивое решение этой проблемы. Достаточно в качестве параметра type передать не функцию open, а экземпляр класса, полученного с помощью функции argparse.FileType, предназначенной для безопасной попытки открытия файла.

Функция argparse.FileType выглядит следующим образом и напоминает упрощенную версию функции open:

```
argparse.FileType(mode='r', bufsize=-1, encoding=None, errors=None)
```

Здесь первый параметр задает режим открытия файла ('r' - чтение, 'w' - запись и т.д. по аналогии с функцией open), второй задает размер буфера, если нужно использовать буферизированое чтение, третий параметр задает кодировку открываемого файла, а последний - действие в случае ошибки декодирования файла. Эта функция создает экземпляр класса, предназначенного для работы с файлами.

Таким образом, мы можем исправить предыдущий пример:

```py
import sys
import argparse
 
def createParser ():
    parser = argparse.ArgumentParser()
    parser.add_argument ('-n', '--name', type=argparse.FileType())
    return parser
 
if __name__ == '__main__':
    parser = createParser()
    namespace = parser.parse_args()
    print (namespace)
    text = namespace.name.read()
    print (text)
```

Теперь, если пользователь попытается передать имя несуществующего файла, то он увидит не большой страшный листинг исключения, а внятную ошибку:

```
python coolprogram.py --name invalid.txt

usage: coolprogram.py [-h] [-n NAME]
coolprogram.py: error: argument -n/--name: can't open 'invalid.txt': [Errno 2] No such file or directory: 'invalid.txt'
```

Аналогично мы можем принимать имя файла для записи, при этом только надо не забыть передать в фукнцию argparse.FileType в качестве первого параметра строку 'w'.

## Обязательные именованные параметры

До сих пор мы говорили, что позиционные параметры у нас обязательные. Напомню, что позиционными считаются те параметры, имена которых не начинаются с символов "-" или "--". Почему они называются позиционными, поговорим чуть позже, когда перейдем к разделу про разбор нескольких параметров.

Т.е. следующая программа у нас должна обязательно получить один параметр:

```py
import sys
import argparse
 
def createParser ():
    parser = argparse.ArgumentParser()
    parser.add_argument ('name')
    return parser
 
if __name__ == '__main__':
    parser = createParser()
    namespace = parser.parse_args()
    print (namespace)
    print ("Привет, {}!".format (namespace.name) )
```

А поскольку параметр у нас не именованный (не начинается с символов "-" или "--"), то мы не должны в командной строке указывать имя параметра. Если же мы не укажем обязательный позиционный параметр, то argparse нам выведет понятную ошибку, а не будет бросать исключения. В следующем блоке показаны два случая использования этого скрипта: с переданным параметром и без него.

```
python coolprogram.py Вася

Namespace(name='Вася')
Привет, Вася!
```

```
python coolprogram.py

usage: coolprogram.py [-h] name
coolprogram.py: error: the following arguments are required: name
```

Теперь вернемся к примеру, где мы этот параметр сделали именованным:

```py
import sys
import argparse
 
def createParser ():
    parser = argparse.ArgumentParser()
    parser.add_argument ('-n', '--name')
    return parser
 
if __name__ == '__main__':
    parser = createParser()
    namespace = parser.parse_args()
    print (namespace)
    print ("Привет, {}!".format (namespace.name) )
```

Именованные параметры по умолчанию считаются необязательными, если мы его не укажем, то получим в качестве результата работы:

```
Namespace(name=None)
Привет, None!
```

Если же нас такое поведение не устраивает, мы можем указать, что этот параметр является обязательным, для этого достаточно в метод add_argument добавить параметр required=True

```py
import sys
import argparse
 
def createParser ():
    parser = argparse.ArgumentParser()
    parser.add_argument ('-n', '--name', required=True)
    return parser
 
if __name__ == '__main__':
    parser = createParser()
    namespace = parser.parse_args()
    print (namespace)
    print ("Привет, {}!".format (namespace.name) )
```

Теперь при попытке запустить программу без параметров пользователь увидит ошибку:

```
python coolprogram.py

usage: coolprogram.py [-h] -n NAME
coolprogram.py: error: the following arguments are required: -n/--name
```

## Параметры как флаги

Иногда может возникнуть желание добавить параметры, которые должны работать как флаги, т.е. они или были указаны, или нет. Например, пусть у нас есть простейшая программа "Hello World", но если мы ей укажем параметр "--goodbye" или "-g", то программа не только поздоровается, но и попрощается с миром. :)

```
python coolprogram.py

Привет, мир!
```

```
python coolprogram.py --goodbye

Привет, мир!
Прощай, мир!
```

Для того, чтобы смоделировать такое поведение нам понадобится еще один параметр метода add_argument, который мы до этого не использовали. Этот аргумент называется action, который предназначен для выполнения некоторых действий над значениями переданного параметра. Мы не будем подробно рассматривать все возможные действия, поскольку многие из них довольно специфические и требуют подробного рассмотрения, и в двух словах их не объяснишь, поэтому рассмотрим только один из вариантов использования этого параметра.

С формальной точки зрения, если мы явно не указываем значения параметра action, то он равен строке "store", это означает, что парсер должен просто хранить полученные значения переменных, это происходило во всех приведенных выше примерах.

Для начала мы воспользуемся другим значением параметра action, а именно строкой "store_const", которая обозначает, что если данный параметр указан, то он всегда будет принимать значение, указанное в другом параметре метода add_argument - const. Если этот параметр указан не будет, то его значение будет равно None.

Напишем наш новый Hello/goodbye World:

```py
import sys
import argparse
 
def createParser ():
    parser = argparse.ArgumentParser()
    parser.add_argument ('-g', '--goodbye', action='store_const', const=True)
    return parser
 
if __name__ == '__main__':
    parser = createParser()
    namespace = parser.parse_args()
    print (namespace)
    print ("Привет, мир!")
    if namespace.goodbye:
        print ("Прощай, мир!")
```

Теперь посмотрим, как он работает, и проследим за значением параметра goodbye:

```
python coolprogram.py

Namespace(goodbye=None)
Привет, мир!
```

```
python coolprogram.py --goodbye

Namespace(goodbye=True)
Привет, мир!
Прощай, мир!
```

Если нас смущает, что без указания параметра --goodbye его значение равно None, а не False, то мы можем воспользоваться уже знакомым нам параметром default:

```py
import sys
import argparse
 
def createParser ():
    parser = argparse.ArgumentParser()
    parser.add_argument ('-g', '--goodbye', action='store_const', const=True, default=False)
    return parser
 
if __name__ == '__main__':
    parser = createParser()
    namespace = parser.parse_args()
    print (namespace)
    print ("Привет, мир!")
    if namespace.goodbye:
        print ("Прощай, мир!")
```

Теперь, если этот параметр не указан, то он будет равен False, в остальном поведение не изменилось:

```
python coolprogram.py

Namespace(goodbye=False)
Привет, мир!
```

```
python coolprogram.py --goodbye

Namespace(goodbye=True)
Привет, мир!
Прощай, мир!
```

Может возникнуть вопрос, почему бы просто не использовать параметр default, зачем нужен еще action? Но одним default мы не обойдемся, поскольку action со значением store (значение по умолчанию для него) подразумевает, что если параметр (в данном случае --goodbye) указан, то после него должно идти какое-то значение, а параметр default позволит указать значение этого параметра только при отсутствии --goodbye.

Поскольку используемый выше прием для создания флагов довольно часто используется, предусмотрено значение параметра action, позволяющее не указывать значение const для булевых значений: store_true и store_false. При использовании этих значений указанный параметр командной строки будет принимать соответственно True или False, если он указан. В данном случае мы можем воспользоваться значением action="store_true":

```py
import sys
import argparse
 
def createParser ():
    parser = argparse.ArgumentParser()
    parser.add_argument ('-g', '--goodbye', action='store_true', default=False)
    return parser
 
if __name__ == '__main__':
    parser = createParser()
    namespace = parser.parse_args()
    print (namespace)
    print ("Привет, мир!")
    if namespace.goodbye:
        print ("Прощай, мир!")
```

Результат работы скрипта не изменится.

## Использование нескольких параметров

До сих пор во всех примерах мы задавали лишь один параметр, обязательный или необязательный, поскольку нас интересовало в первую очередь то, какие свойства могут быть у параметров. В этом разделе мы рассмотрим случаи, когда программа ожидает несколько параметров, что чаще всего и бывает.

Для добавления второго, третьего и т.д. параметра необходимо повторно вызвать метод add_argument класса ArgumentParser, описав с помощью переданных значений свойства ожидаемого параметра.

Например, следующий скрипт ожидает два позиционных параметра - имя приветствуемого человека и число, обозначающее, сколько раз его нужно поприветствовать. В данном случае оба позиционных параметра будут являться обязательными. Причем, первый параметр всегда задает имя, а второй - количество, в данном примере поменять местами мы их не можем, отсюда и название таких параметров - "позиционные".

```py
import sys
import argparse
 
def createParser ():
    parser = argparse.ArgumentParser()
    parser.add_argument ('name')
    parser.add_argument ('count', type=int)
    return parser
 
if __name__ == '__main__':
    parser = createParser()
    namespace = parser.parse_args()
    print (namespace)
    for _ in range (namespace.count):
        print ("Привет, {}!".format (namespace.name) )
```

Различные способы запуска такой программы показано ниже. В пером случае все задано корректно, а в остальных случаях есть ошибки: сначала аргументы перепутаны местами, вследствие чего второй параметр не удалось преобразовать в целое число, затем забыли передать один из параметров:

```
python coolprogram.py Петя 3

Namespace(count=3, name='Петя')
Привет, Петя!
Привет, Петя!
Привет, Петя!
```

```
python coolprogram.py 3 Петя

usage: coolprogram.py [-h] name count
coolprogram.py: error: argument count: invalid int value: 'Петя'
```

```
python coolprogram.py Петя

usage: coolprogram.py [-h] name count
coolprogram.py: error: the following arguments are required: count
```

Лично я недолюбливаю позиционные параметры как раз из-за того, что надо запоминать, в каком порядке они идут. Давайте сделаем их оба именованными, в этом случае порядок их передачи будет не важен, правда, при этом придется больше вводить символов, поскольку нужно будет вводить имена параметров.

```py
import sys
import argparse
 
def createParser ():
    parser = argparse.ArgumentParser()
    parser.add_argument ('-n', '--name')
    parser.add_argument ('-c', '--count', type=int, default=1)
    return parser
 
if __name__ == '__main__':
    parser = createParser()
    namespace = parser.parse_args()
    print (namespace)
    for _ in range (namespace.count):
        print ("Привет, {}!".format (namespace.name) )
```

Теперь параметры можно менять местами, ведь имена параметров все-равно заданы.

```
python coolprogram.py --name Петя --count 3

Namespace(count=3, name='Петя')
Привет, Петя!
Привет, Петя!
Привет, Петя!
```

```
python coolprogram.py --count 3 --name Петя

Namespace(count=3, name='Петя')
Привет, Петя!
Привет, Петя!
Привет, Петя!
```

А как быть, если у нас имеются и позиционные, и необязательные именованные параметры?

```py
import sys
import argparse
 
def createParser ():
    parser = argparse.ArgumentParser()
    parser.add_argument ('name')
    parser.add_argument ('-c', '--count', type=int, default=1)
    return parser
 
if __name__ == '__main__':
    parser = createParser()
    namespace = parser.parse_args()
    print (namespace)
    for _ in range (namespace.count):
        print ("Привет, {}!".format (namespace.name) )
```

В каком порядке мы должны передавать параметры? Сначала позиционные параметры, а потом именованные или наоборот? На самом деле это не важно, оба варианта будут работать:

```
python coolprogram.py Петя --count 3

Namespace(count=3, name='Петя')
Привет, Петя!
Привет, Петя!
Привет, Петя!
```

```
python coolprogram.py --count 3 Петя

Namespace(count=3, name='Петя')
Привет, Петя!
Привет, Петя!
Привет, Петя!
```

[содержание](/readme.md)  
