[содержание](/readme.md)  

# Структурные шаблоны

**Простыми словами**: Структурные шаблоны в основном связаны с композицией объектов, другими словами, с тем, как сущности могут использовать друг друга. Ещё одним объяснением было бы то, что они помогают ответить на вопрос «Как создать программный компонент?».

Список структурных шаблонов проектирования:

* адаптер (Adapter);
* мост (Bridge);
* компоновщик (Composite);
* декоратор (Decorator);
* фасад (Facade);
* приспособленец (Flyweight);
* заместитель (Proxy).

## Адаптер (Adapter)

**Адаптер** — структурный шаблон проектирования, предназначенный для организации использования функций объекта, недоступного для модификации, через специально созданный интерфейс.

**Пример из жизни**: Представим, что у вас на карте памяти есть какие-то изображения и вам надо перенести их на ваш компьютер. Чтобы это сделать, вам нужен какой-то адаптер, который совместим с портами вашего компьютера. В этом случае карт-ридер — это адаптер. Другим примером будет блок питания. Вилку с тремя ножками нельзя вставить в розетку с двумя отверстиями. Для того, чтобы она подошла, надо использовать адаптер. Ещё одним примером будет переводчик, переводящий слова одного человека для другого.

**Простыми словами**: Шаблон позволяет обернуть несовместимые объекты в адаптер, чтобы сделать их совместимыми с другим классом.

Обратимся к коду. Представим игру, в которой охотник охотится на львов.

Изначально у нас есть интерфейс Lion, который реализует всех львов:

```kt
interface Lion {
    fun roar()
}

class AfricanLion : Lion {
    override fun roar(){}
}

class AsianLion : Lion {
    override fun roar(){}
}
```

И Hunter охотится на любую реализацию интерфейса Lion:

```kt
class Hunter {
    fun hunt(lion: Lion){}
}
```

Теперь представим, что нам надо добавить WildDog в нашу игру, на которую наш Hunter также мог бы охотиться. Но мы не можем сделать это напрямую, потому что у WildDog другой интерфейс. Чтобы сделать её совместимой с нашим Hunter, нам надо создать адаптер:

```kt
// Это надо добавить в игру
class WildDog {
    fun bark(){}
}

// Адаптер, чтобы сделать WildDog совместимой с нашей игрой 
class WildDogAdapter(var dog: WildDog) : Lion { 
    override fun roar() { 
        dog.bark() 
    } 
}

fun main() {
    var wildDogAdapter = WildDogAdapter(WildDog())

    var hunter = Hunter()
    hunter.hunt(wildDogAdapter)
}
```

### Мост (Bridge)

**Мост** — структурный шаблон проектирования, используемый в проектировании программного обеспечения чтобы разделять абстракцию и реализацию так, чтобы они могли изменяться независимо. Шаблон мост использует инкапсуляцию, агрегирование и может использовать наследование для того, чтобы разделить ответственность между классами.

**Пример из жизни**: Представим, что у вас есть сайт с разными страницами, и вам надо разрешить пользователям менять их тему. Что вы будете делать? Создавать множественные копии каждой страницы для каждой темы или просто отдельную тему, которую пользователь сможет выбрать сам? Шаблон мост позволяет вам сделать второе.

**Простыми словами**: Шаблон мост — это предпочтение композиции над наследованием. Детали реализации передаются из одной иерархии в другой объект с отдельной иерархией.

Обратимся к примеру в коде. Возьмем пример с нашими страницами. У нас есть иерархия WebPage:

```kt
abstract class WebPage(open var theme: Theme){
    abstract fun getContent(): String
}

class About(override var theme: Theme) : WebPage(theme) {
    override fun getContent(): String = "Страница с информацией в ${theme.getColor()}"
}

class Careers(override var theme: Theme) : WebPage(theme) {
    override fun getContent(): String = "Страница карьеры в ${theme.getColor()}"
}
```

И отдельная иерархия Theme:

```kt
interface Theme {
    fun getColor(): String
}

class DarkTheme : Theme {
    override fun getColor() = "темной теме"
}
class LightTheme : Theme {
    override fun getColor() = "светлой теме"
}

class AquaTheme : Theme {
    override fun getColor() = "голубой теме"
}
```

Применение в коде:

```kt
var darkTheme = DarkTheme()

var about = About(darkTheme)
var careers = Careers(darkTheme)

println(about.getContent()) // "Страница информации в темной теме";
println(careers.getContent()) // "Страница карьеры в темной теме";
```

### Компоновщик (Composite)

**Компоновщик** — структурный шаблон проектирования, объединяющий объекты в древовидную структуру для представления иерархии от частного к целому. Компоновщик позволяет клиентам обращаться к отдельным объектам и к группам объектов одинаково. Паттерн определяет иерархию классов, которые одновременно могут состоять из примитивных и сложных объектов, упрощает архитектуру клиента, делает процесс добавления новых видов объекта более простым.

**Пример из жизни**: Каждая организация скомпонована из сотрудников. У каждого сотрудника есть одинаковые свойства, такие как зарплата, обязанности, отчётность и т.д.

**Простыми словами**: Шаблон компоновщик позволяет клиентам работать с индивидуальными объектами в едином стиле.

Обратимся к коду. Возьмем наш пример с рабочими. У нас есть Employee (работники) разных типов:

```kt
interface Assignee {
    fun canHandleTask(task: String): Boolean
    fun takeTask(task: String)
}

class Employee(val name: String) : Assignee {
    private var hasTask = false
    override fun canHandleTask(task: String) = !hasTask

    override fun takeTask(task: String) {
        println("$name получил задачу: $task")
        hasTask = true
    }
}

class Team(val assignees: ArrayList<Assignee>) : Assignee {

    // вспомогательные методы для управления композитом:
    fun add(assignee: Assignee){
        assignees.add(assignee)
    }
    fun remove(assignee: Assignee){}

    override fun canHandleTask(task: String): Boolean {
        for(assignee in assignees)
            if (assignee.canHandleTask(task)) return true
        return false
    }

    override fun takeTask(task: String) {
        /* может быть разная имплементация - допустим, некоторые задания требуют
        нескольких человек из команды одновременно
        в простейшем случае берем первого незанятого работника среди assignees*/
        var assignee = assignees.removeAt(0)
        assignee.takeTask(task)
    }
}
```

Еще у нас есть Начальник:

```kt
class TaskManager(private val assignees: ArrayList<Assignee>) {
    fun performTask(task: String) {
        for(assignee in assignees)
            if (assignee.canHandleTask(task)) {
                assignee.takeTask(task)
                return
            }

        throw Exception("Cannot handle the task - please hire more people")
    }
}
```

Способ применения (в моей реализации работники "однозадачные"):

```kt
fun main() {
    var employee1 = Employee("трус")
    var employee2 = Employee("балбес")
    var employee3 = Employee("бывалый")
    var employee4 = Employee("шурик")
    var team1 = Team( arrayListOf<Assignee>(employee3, employee4) )

    // ВНИМАНИЕ: передаем команду в taskManager как единый композит.
    // Сам taskManager не знает, что это команда и работает с ней без модификации своей логики.
    var taskManager = TaskManager( arrayListOf<Assignee>(employee1, employee2, team1) )

    for(task in listOf("посадить дерево","построить дом","вырастить сына","украсть невесту","снять фильм"))
        try {
            taskManager.performTask( task )
        } catch (e: Exception){
            println("работники закончились")
            break
        }
}
```

На выходе получим что-то подобное:

```
трус получил задачу: посадить дерево
балбес получил задачу: построить дом
бывалый получил задачу: вырастить сына
шурик получил задачу: украсть невесту
работники закончились
```

### Декоратор (Decorator)

**Декоратор** — структурный шаблон проектирования, предназначенный для динамического подключения дополнительного поведения к объекту. Шаблон декоратор предоставляет гибкую альтернативу практике создания подклассов с целью расширения функциональности.

Декораторы мы уже достаточно подробно [рассмотрели](/articles/t7l4.md#декораторы) в теме про исключения, вспомним на еще одном примере:

**Пример из жизни** - в современном программировании принято возникающие ошибки выбрасывать исключениями. Но для функций, загружаемых из DLL, действует другое соглашение: функция НЕ должна вызывать исключений, она должна вернуть HRESULT - целое число, если 0, значит функция выполнена успешно, если больше, то результат обозначает код возникшей ошибки. Напишем декоратор для таких функций:


```py
def ошибки_в_исключения(оригинал):
    """
    Функция декоратор, анализирует результат, возвращаемый оригиналом и 
    в случае ошибки выбрасывает исключение с ТЕКСТОМ ошибки
    """
    #словарь документированных ошибок
    словарь_ошибок = {1:'ошибка 1', 2: 'ошибка 2'} 
    def обертка(*args, **kwargs):
        результат = оригинал(*args, **kwargs)
        if результат==0:
            return 0
        elif результат in словарь_ошибок:
            raise Exception(словарь_ошибок[результат])
        else:
            raise Exception('не документированная ошибка, код: {}'.format(результат))

    return обертка

# для декорирования функции достаточно нашу функцию с плюшкой добавить перед описанием декорируемой функции
@ошибки_в_исключения    
def вызов_функции_из_виндовой_библиотеки():
    #тут логика по получению адреса функции, заданию формата параметров и т.п.
    return dll_fun()

#а тут реальный вызов функции и он будет завернут в "обертку"
вызов_функции_из_виндовой_библиотеки()    
```

### Фасад (Facade)
**Фасад** — структурный шаблон проектирования, позволяющий скрыть сложность системы путём сведения всех возможных внешних вызовов к одному объекту, делегирующему их соответствующим объектам системы.

**Пример из жизни**: Как вы включаете компьютер? Нажимаю на кнопку включения, скажете вы. Это то, во что вы верите, потому что вы используете простой интерфейс, который компьютер предоставляет для доступа снаружи. Внутри же должно произойти гораздо больше вещей. Этот простой интерфейс для сложной подсистемы называется фасадом.

**Простыми словами**: Шаблон фасад предоставляет упрощенный интерфейс для сложной системы.

Перейдем к примерам в коде. Возьмем пример с компьютером. Изначально у нас есть класс Компьютер:

```py
class Компьютер():
    def включить220(self):
        print('Ай!')

    def озвучитьРезультатПроверкиPOST(self):
        print('Бип!')

    def показатьЭкранЗагрузки(self):
        print('Загрузка...')

    def готовРаботать(self):
        print('Готов к использованию!')

    def закрытьВсеПрограммы(self):
        print('Кто не спрятался, я не виноват...')

    def завершитьРаботуОперационнойСистемы(self):
        print('Подождите, операционная система выключается...')

    def записатьОзуНаДиск(self):
        print('Усиленно шуршим')

    def спать(self):
        print('Хррр...')
```

Теперь нарисуем к нему кнопки включения и выключения (фасад)

```py
class КнопкаНаМорде():
    def __init__(компьютер)
        self._компьютер = компьютер

    def включить():
        self._компьютер.включить220()
        self._компьютер.озвучитьРезультатПроверкиPOST()
        self._компьютер.показатьЭкранЗагрузки()
        self._компьютер.готовРаботать()

    def гибернация():
        self._компьютер.записатьОзуНаДиск()
        self._компьютер.спать()

    def выключить():
        self._компьютер.закрытьВсеПрограммы()
        self._компьютер.завершитьРаботуОперационнойСистемы(self):
```

Пример использования:

```py
кнопка = КнопкаНаМорде(Компьютер())
кнопка.включить()
#Ай!
#Бип!
#Загрузка...
#Готов к использованию!

кнопка.выключить()
#Кто не спрятался, я не виноват...
#Подождите, операционная система выключается...
```

У системы, кстати, может быть несколько вариантов включения/выключения (простое, сон, гибернация), вариант выключения можно передать параметром в метод кнопка.выключить и в режиме гибернации, например, вызывать другие методы (в классе Компьютер они реализованы).

### Приспособленец (Flyweight)

**Приспособленец** — структурный шаблон проектирования, при котором объект, представляющий себя как уникальный экземпляр в разных местах программы, по факту не является таковым.

**Приспособленец** используется для уменьшения затрат при работе с большим количеством мелких объектов. При проектировании приспособленца необходимо разделить его свойства на внешние и внутренние. Внутренние свойства всегда неизменны, тогда как внешние могут отличаться в зависимости от места и контекста применения и должны быть вынесены за пределы приспособленца.

**Приспособленец** дополняет шаблон Factory Method таким образом, что при обращении клиента к Factory Method для создания нового объекта ищет уже созданный объект с такими же параметрами, что и у требуемого, и возвращает его клиенту. Если такого объекта нет, то фабрика создаст новый.

**Пример из Википедии**: наряжаем ёлку разноцветными лампочками

```py
class Лампочка:
    def __init__(self, цвет):
        self.цвет = цвет

#setdefault - Возвращает значение по ключу, инициализируя элемент словаря, если необходимо, указанным значением.

class ФабрикаЛампочек:
    лампочки = {}
    @classmethod
    def взять_лампочку(cls, цвет):
        return ФабрикаЛампочек.лампочки.setdefault(цвет, Лампочка(цвет))


class Ветка:
    def __init__(self, номер_ветки):
        self.номер_ветки = номер_ветки

    def повесить(self, лампочка):
        print("Повесили {} [{}] лампочку на ветку {} [{}]".format(лампочка.цвет, id(лампочка), self.номер_ветки, id(self)))


class Ёлка(object):
    def __init__(self):
        self.лампочек_повешено = 0
        self.ветки = {}

    def взять_ветку(self, номер):
        return self.ветки.setdefault(номер, Ветка(номер))

    def повесить_лампочку(self, цвет, номер_ветки):
        self.взять_ветку(номер_ветки).повесить(ФабрикаЛампочек.взять_лампочку(цвет))
        self.лампочек_повешено += 1

    def нарядить_ёлку(self):
        self.повесить_лампочку('red', 1)
        self.повесить_лампочку('blue', 1)
        self.повесить_лампочку('yellow', 1)
        self.повесить_лампочку('red', 2)
        self.повесить_лампочку('blue', 2)
        self.повесить_лампочку('yellow', 2)
        self.повесить_лампочку('red', 3)
        self.повесить_лампочку('blue', 3)
        self.повесить_лампочку('yellow', 3)
        self.повесить_лампочку('red', 4)
        self.повесить_лампочку('blue', 4)
        self.повесить_лампочку('yellow', 4)
        self.повесить_лампочку('red', 5)
        self.повесить_лампочку('blue', 5)
        self.повесить_лампочку('yellow', 5)
        self.повесить_лампочку('red', 6)
        self.повесить_лампочку('blue', 6)
        self.повесить_лампочку('yellow', 6)
        self.повесить_лампочку('red', 7)
        self.повесить_лампочку('blue', 7)
        self.повесить_лампочку('yellow', 7)

if __name__ == '__main__':
    Ёлка().нарядить_ёлку()
```

В консоли получим примерно такое:

```
Повесили red [78852560] лампочку на ветку 1 [78852624]
Повесили blue [78852944] лампочку на ветку 1 [78852624]
Повесили yellow [78855760] лампочку на ветку 1 [78852624]
Повесили red [78852560] лампочку на ветку 2 [78853584]
Повесили blue [78852944] лампочку на ветку 2 [78853584]
Повесили yellow [78855760] лампочку на ветку 2 [78853584]
Повесили red [78852560] лампочку на ветку 3 [78855984]
Повесили blue [78852944] лампочку на ветку 3 [78855984]
Повесили yellow [78855760] лампочку на ветку 3 [78855984]
Повесили red [78852560] лампочку на ветку 4 [78855792]
Повесили blue [78852944] лампочку на ветку 4 [78855792]
Повесили yellow [78855760] лампочку на ветку 4 [78855792]
Повесили red [78852560] лампочку на ветку 5 [78853648]
Повесили blue [78852944] лампочку на ветку 5 [78853648]
Повесили yellow [78855760] лампочку на ветку 5 [78853648]
Повесили red [78852560] лампочку на ветку 6 [78856016]
Повесили blue [78852944] лампочку на ветку 6 [78856016]
Повесили yellow [78855760] лампочку на ветку 6 [78856016]
Повесили red [78852560] лампочку на ветку 7 [78856144]
Повесили blue [78852944] лампочку на ветку 7 [78856144]
Повесили yellow [78855760] лампочку на ветку 7 [78856144]
```

Лампочка каждого цвета всего в одном экземпляре и одновременно висит на всех ветках.

### Заместитель (Proxy)

**Заместитель** — структурный шаблон проектирования, который предоставляет объект, который контролирует доступ к другому объекту, перехватывая все вызовы (выполняет функцию контейнера).

**Пример из жизни**: Вы когда-нибудь использовали карту доступа, чтобы пройти через дверь? Есть несколько способов открыть дверь: например, она может быть открыта при помощи карты доступа или нажатия кнопки, которая обходит защиту. Основная функциональность двери — это открытие, но заместитель, добавленный поверх этого, добавляет функциональность. Но лучше я объясню это на примере кода чуть ниже.

**Простыми словами**: Используя шаблон заместитель, класс отображает функциональность другого класса.

Перейдем к коду. Возьмем наш пример с безопасностью. Сначала у нас есть интерфейс Дверь и его реализация:

```py
from abc import ABC, abstractmethod

class Дверь(ABC):
    @abstractmethod
    def открыть(self): pass
    @abstractmethod
    def закрыть(self): pass

class ДверьЛаборатории(Дверь):
    def открыть(self):
        print("Открытие двери лаборатории")

    def закрыть(self):
        print("Закрытие двери лаборатории")

# Затем у нас есть заместитель Безопасность для защиты любых наших дверей:

class Безопасность:
    def __init__(self, дверь: Дверь):
        self._дверь = дверь

    def открыть(self, пароль):
        if self.проверить(пароль):
            self._дверь.открыть()
        else:
            print("Нет! Это невозможно.")

    def проверить(self, пароль: str):
        return пароль == '$ecr@t'

    def закрыть(self):
        self._дверь.закрыть()

# Пример использования:

дверь = Безопасность(ДверьЛаборатории())
дверь.открыть('invalid') # Нет! Это невозможно.

дверь.открыть('$ecr@t') # Открытие двери лаборатории
дверь.закрыть() # Закрытие двери лаборатории
```
