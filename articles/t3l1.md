[содержание](/readme.md)  

# Основы языка Kotlin

https://metanit.com/kotlin/tutorial/2.1.php

* [Машинное представление чисел](#Машинное-представление-чисел)
* [Переменные](#Переменные)
* [Типы данных](#Типы-данных)
* [Null безопасность](#Null-безопасность)
* [Операции с числами](#Операции-с-числами)
* [Условные выражения](#Условные-выражения)
* [Условные конструкции](#Условные-конструкции)
* [Циклы](#Циклы)
* [Последовательности](#Последовательности)
* [Массивы](#Массивы)

## Машинное представление чисел
Компьютер хранит и обрабатывает все данные в двоичном виде. Рассмотрим как хранятся числа.

### Целое беззнаковое
Для беззнакового представления все разряды ячейки отводятся под представление самого числа. Например, в байте (8 бит) можно представить беззнаковые числа от 0 до 255. Поэтому, если известно, что числовая величина является неотрицательной, то выгоднее рассматривать её как беззнаковую.

### Целое со знаком
Для представления числа со знаком самый старший (левый) бит отводится под знак числа, остальные разряды - под само число. Если число положительное, то в знаковый разряд помещается 0, если отрицательное - 1. Например, в байте можно представить знаковые числа от -128 до 127.

### Прямой код числа
Представление числа в привычной форме "знак"-"величина", при которой старший разряд ячейки отводится под знак, а остальные - под запись числа в двоичной системе, называется прямым кодом двоичного числа. Например, прямой код двоичных чисел 1001 и -1001 для 8-разрядной ячейки равен 00001001 и 10001001 соответственно.

Положительные числа всегда представляются с помощью прямого кода. Прямой код числа полностью совпадает с записью самого числа в ячейке машины. Прямой код отрицательного числа отличается от прямого кода соответствующего положительного числа лишь содержимым знакового разряда. 

Но отрицательные целые числа не представляются в ЭВМ с помощью прямого кода, для их представления используется так называемый дополнительный код.

### Дополнительный код числа.

>Дополнительный код положительного числа равен прямому коду этого числа.</br></br>
>Дополнительный код отрицательного числа m равен 2k-|m|, где k - количество разрядов в ячейке.</br></br>
>Как уже было сказано, при представлении неотрицательных чисел в беззнаковом формате все разряды ячейки отводятся под само число. Например, запись числа 243=11110011 в одном байте при беззнаковом представлении будет выглядеть следующим образом:</br>
1	1	1	1	0	0	1	1</br></br>
>При представлении целых чисел со знаком старший (левый) разряд отводится под знак числа, и под собственно число остаётся на один разряд меньше. Поэтому, если приведённое выше состояние ячейки рассматривать как запись целого числа со знаком, то для компьютера в этой ячейке записано число -13 (243+13=256=28).
Но если это же отрицательное число записать в ячейку из 16-ти разрядов, то содержимое ячейки будет следующим:</br>
>1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1

### Знаковый разряд

Возникает вопрос: с какой целью отрицательные числа записываются в виде дополнительного кода и как получить дополнительный код отрицательного числа?

Дополнительный код используется для упрощения выполнения арифметических операций. Если бы вычислительная машина работала с прямыми кодами положительных и отрицательных чисел, то при выполнении арифметических операций следовало бы выполнять ряд дополнительных действий. Например, при сложении нужно было бы проверять знаки обоих операндов и определять знак результата. Если знаки одинаковые, то вычисляется сумма операндов и ей присваивается тот же знак. Если знаки разные, то из большего по абсолютной величине числа вычитается меньшее и результату присваивается знак большего числа. То есть при таком представлении чисел (в виде только прямого кода) операция сложения реализуется через достаточно сложный алгоритм. Если же отрицательные числа представлять в виде дополнительного кода, то операция сложения, в том числе и разного знака, сводится к из поразрядному сложению.

Для компьютерного представления целых чисел обычно используется один, два, четыре или восемь байт, то есть ячейка памяти будет состоять из восьми, шестнадцати, тридцати двух или шестидесяти четырех разрядов соответственно.

### Алгоритм получения дополнительного кода отрицательного числа.

>Для получения дополнительного k-разрядного кода отрицательного числа необходимо
модуль отрицательного числа представить прямым кодом в k двоичных разрядах;
значение всех бит инвертировать: все нули заменить на единицы, а единицы на нули(таким образом, получается k-разрядный обратный код исходного числа);
к полученному обратному коду прибавить единицу.</br></br>
>Пример:  
Получим 8-разрядный дополнительный код числа -52:</br>
00110100 - число |-52|=52 в прямом коде</br>
11001011 - число  -52  в обратном коде</br>
11001100 - число  -52  в дополнительном коде

### Представление вещественных чисел в компьютере.

Для представления вещественных чисел в современных компьютерах принят способ представления с плавающей запятой. Этот способ представления опирается на нормализованную (экспоненциальную) запись действительных чисел.
Как и для целых чисел, при представлении действительных чисел в компьютере  используется двоичная система, следовательно, предварительно десятичное число должно быть переведено двоичную систему.

>### Нормализованная запись числа.
>
>**Нормализованная запись** отличного от нуля действительного числа - это запись вида a = +- m*P<sup>q</sup>, где q - целое число (положительное, отрицательное или ноль), а m - правильная P-ичная дробь, у которой первая цифра после запятой не равна нулю, то есть ``1/P <= m < 1``. При этом m называется **мантиссой** числа, q - **порядком** числа.
>
>Примеры:</br>
3,1415926 = 0, 31415926 * 101;</br>
1000=0,1 * 104;</br>
0,123456789 = 0,123456789 * 100;</br>
0,00001078 = 0,1078 * 10<sup>-4</sup>;</br>
1000,00012 = 0,100000012 * 10<sup>4</sup>.
>
>Так как число ноль не может быть записано в нормализованной форме в том виде, в каком она была определена, то считаем, что нормализованная запись нуля в 10-й системе будет такой:
0 = 0,0 * 10<sup>0</sup>.
>
>**Нормализованная экспоненциальная запись** числа - это запись вида a = +- m*P<sup>q</sup>, где q - целое число (положительное, отрицательное или ноль), а m - P-ичная дробь, у которой целая часть состоит из одной цифры. При этом (m-целая часть) называется **мантиссой** числа, q - **порядком** числа.
>
>### Представление чисел с плавающей запятой.
>При представлении чисел с плавающей запятой часть разрядов ячейки отводится для записи порядка числа, остальные разряды - для записи мантиссы. По одному разряду в каждой группе отводится для изображения знака порядка и знака мантиссы. Для того, чтобы не хранить знак порядка, был придуман так называемый смещённый порядок, который рассчитывается по формуле 2<sup>a-1</sup>+ИП, где a - количество разрядов, отводимых под порядок.
>
>Пример:</br>
Если истинный порядок равен -5, тогда смещённый порядок для 4-байтового числа будет равен 127-5=122.
>
>### Алгоритм представления числа с плавающей запятой.
>- Перевести число из p-ичной системы счисления в двоичную;
>- представить двоичное число в нормализованной экспоненциальной форме;
>- рассчитать смещённый порядок числа;
>- разместить знак, порядок и мантиссу в соответствующие разряды сетки.
>
>Пример:</br>
Представить число -25,625 в машинном виде с использованием 4 байтового представления (где 1 бит отводится под знак числа, 8 бит - под смещённый порядок, остальные биты - под мантиссу).</br></br>
>25<sub>10</sub> = 100011<sub>2</sub></br>
0,625<sub>10</sub> = 0,101<sub>2</sub></br>
-25,625<sub>10</sub> = -100011,101<sub>2</sub></br>
-100011,101<sub>2</sub> = -1,00011101<sub>2</sub> * 2<sup>4</sup></br>
СП = 127+4 = 131
>
> знак | смещенный порядок | мантисса
> -----|-------------------|----------
> 1 | 1 0 0 0 0 0 1 1 | 1 0 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
>
>Можно заметить, что представление действительного числа не очень удобно изображать в двоичной системе, поэтому часто используют шестнадцатеричное представление:</br></br>
>Окончательный ответ: C1CD0000.

## Переменные

Для хранения данных в программе в Kotlin, как и в других языках программирования, применяются переменные. Переменная представляет именованный участок памяти, который хранит некоторое значение.

Каждая переменная характеризуется определенным именем, типом данных и значением. Имя переменной представляет поизвольный идентификатор, который может содержать алфавитно-цифровые символы или символ подчеркивания и должен начинаться либо с алфавитного символа, либо со знака подчеркивания. Для определения переменной можно использовать либо ключевое слово val, либо ключевое слово var.

Например, определим переменную age:

```kt
val age: Int
```

Вначале идет слово val или var, затем имя переменной и через двоеточие тип переменной. То есть в данном случае объявлена переменная age, которая имеет тип Int. Тип Int говорит о том, что переменная будет содержать целочисленные значения.

После определения переменной ей можно присвоить значение:
```kt
fun main(args: Array<String>) {
    val age: Int
    age = 23
    println(age)
}
```

Для присвоения значения переменной используется знак равно. Затем мы можем производить с переменной различные операции. Например, в данном случае с помощью функции println значение переменной выводится на консоль. И при запуске этой программы на консоль будет выведено число 23.

Присвоение значения переменной должно производиться только после ее объявления. И также мы можем сразу присвоить переменной начальное значение при ее объявлении. Такой прием называется инициализацией. При инициализации можно опустить указание типа, тип переменной будет задан по типу присваимого значения:

```kt
fun main(args: Array<String>) {
    val age: Int = 23 
    println(age)
}
```

### Изменяемые и неизменяемые переменные

Выше было сказано, что переменные могут объявляться как с помощью слова val, так и с помощью слова var. В чем же разница между двумя этими способами?

С помощью ключевого слова val определяется неизменяемая переменная (immutable variable). То есть мы можем присвоить значение такой переменной только один раз, но изменить его после первого присвоения мы уже не сможем. Например, в следующем случае мы получим ошибку:

```kt
fun main(args: Array<String>) {
    val age: Int
    age = 23        // здесь норм - первое присвоение
    age = 56        // здесь ошибка - переопределить значение переменной нельзя
    println(age)
}
```

В этом плане подобные переменные похожи на константы в других языках программирования.

А у переменной, которая определена с помощью ключевого слова var мы можем многократно менять значения (mutable variable):

```kt
fun main(args: Array<String>) {
    var age: Int
    age = 23
    println(age)
    age = 56
    println(age)
}
```

Поэтому если не планируется изменять значение переменной в программе, то лучше определять ее с ключевым словом val.

## Типы данных

В Kotlin каждая переменная имеет определенный тип. Тип данных определяет, какие операции можно производить с данными этого типа.

В отличие от языка Java и ряда других языков Kotlin не имеет встроенных примитивных типов. Все типы представляют определенные классы.

### Числовые типы

* Byte: хранит целое число от -128 до 127 и занимает 1 байт
* Short: хранит целое число от -32768 до 32767 и занимает 2 байта
* Int: хранит целое число от -2147483648 до 2147483647 и занимает 4 байта
* Long: хранит целое число от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 и занимает 8 байт
* Float: хранит число с плавающей точкой от -3.4*1038 до 3.4*1038 и занимает 4 байта
* Double: хранит число с плавающей точкой от ±5.0*10-324 до ±1.7*10308 и занимает 8 байта.

### Литералы

Литералы представляют неизменяемые значения (иногда их еще называют константами). Литералы можно передавать переменным в качестве значения. Литералы бывают логическими, целочисленными, вещественными, символьными и строчными.

Любые литералы, которые представляют целые числа, воспринимаются как данные типа Int.

```kt
val age: Int = 45
// переменная age будет иметь тип Int
```

Литерал "45" представляет целое число и является значением типа Int. Если же мы хотим явно указать, что число представляет значение типа Long, то следует использовать суффикс L:

```kt
val age: Long = 45  // тут Котлин автоматически приведет к объявленному типу
или 
val age = 45L       // а вот тут мы используем суффикс, чтобы явно указать тип
```

Аналогично все числа с плавающей точкой (которые содержат точку в качестве разделителя целой и дробной части) рассматриваются как числа типа Double:

```kt
val weight: Double = 68.71
```

Если мы хотим указать, что данные будут представлять тип Float, то необходимо использовать суффикс F:

```kt
val weight = 68.71F
```

Кроме чисел в десятичной системе мы можем определять числа в двоичной и шестнадцатеричной системах.

Шестнадцатеричная запись числа начинается с 0x, затем идет набор символов от 0 до F, которые представляют число:

```kt
val age: Int = 0x0A1    // 161
```

Двоичная запись числа предваряется символами 0b, после которых идет последовательность из нулей и единиц:

```kt
val a = 0b0101    // 5
val b = 0b1011     // 11
```

### Нижние подчеркивания в числовых литералах (начиная с версии 1.1)

Вы можете использовать нижние подчеркивания, чтобы сделать числовые константы более читаемыми:

```kt
val oneMillion = 1_000_000
val creditCardNumber = 1234_5678_9012_3456L
val socialSecurityNumber = 999_99_9999L
val hexBytes = 0xFF_EC_DE_5E
val bytes = 0b11010010_01101001_10010100_10010010
```

### Выведение типа

Kotlin позволяет выводить тип переменной на основании данных, которыми переменная инициализируется. Поэтому при инициализации переменной тип можно опустить:

```kt
val age = 5
```

В данном случае компилятор увидит, что переменной присваивается значение типа Int, поэтому переменная age будет представлять тип Int.

Соответственно если мы присваиваем переменной строку, то такая переменная будет иметь тип String.

```kt
val name = "Tom"
```

Однако при этом нам обязательно надо инициализировать переменную некоторым значением. То есть нельзя сначала объявить переменную, а потом где-то в программе присвоить ей какое-то значение:

```kt
val age     // Ошибка, переменная не инициализирована
age = 5 
```

### Логический тип Boolean

Тип Boolean может хранить одно из двух значений: true (истина) или false (ложь).

```kt
val a = true
val b = false
```

### Символы

Символьные данные представлены типом Char. Он представляет отдельный символ, который заключается в одинарные кавычки.

```kt
val a = 'A'
val b = 'B'
val c = 'T'
```

Также тип Char может представлять специальные последовательности, которые интерпретируются особым образом:

* \t: табуляция
* \n: перевод строки
* \r: возврат каретки
* \': одинарная кавычка
* \": двойная кавычка
* ``\\``: обратный слеш

### Строки

Строки представлены типом String. Строка представляет последовательность символов, заключенную в двойные кавычки, либо в тройные двойные кавычки.

```kt
fun main(args: Array<String>) {
    val name = "Eugene"
    println(name)
}
```

Строка может содержать специальные символы или эскейп-последовательности. Например, если необходимо вставить в текст перевод на другую строку, можно использовать эскейп-последовательность \n:

```kt
val text: String = "SALT II was a series of talks between United States \n and Soviet negotiators from 1972 to 1979"
```

Для большего удобства при создании многострочного текста можно использовать тройные двойные кавычки:

```kt
fun main(args: Array<String>) {
    val text: String = """SALT II was a series of talks between United States
and Soviet negotiators from 1972 to 1979.
It was a continuation of the SALT I talks."""
    println(text)
}
```

Строки состоят из символов, которые могут быть получены по порядковому номеру: s[i]. Проход по строке можно выполнить циклом for:

```kt
for (c in str) {
    println(c)
}
```

### Строковые шаблоны

Строки могут содержать шаблонные выражения, т.е. участки кода, которые выполняются, а полученный результат встраивается в строку. Шаблон начинается со знака доллара ($) и состоит либо из простого имени (например, переменной):

```kt
val i = 10
val s = "i = $i" // evaluates to "i = 10"
```

либо из произвольного выражения в фигурных скобках:

```kt
val s = "abc"
val str = "$s.length is ${s.length}" // evaluates to "abc.length is 3"
```

Шаблоны поддерживаются как в обычных, так и в экранированных строках. При необходимости символ $ может быть представлен с помощью следующего синтаксиса:

```kt
val price = "${'$'}9.99"
```

### Тип Any

Тип Any является базовым для всех остальных типов. Остальные базовые типы, такие как Int или Double, являются производными от Any. Соответственно мы можем присвоить переменной данного типа любое значение:

```kt
var name: Any = "Tom Smith"
name = 6758
```

### Операторы is и !is

Мы можем проверить принадлежит ли объект к какому-либо типу во время исполнения с помощью оператора **is** или его отрицания **!is**:

```kt
if (obj is String) {
    print(obj.length)
}

if (obj !is String) { // то же самое, что и !(obj is String)
    print("Not a String")
}
else {
    print(obj.length)
}
```

**Умные приведения**

Во многих случаях в Kotlin вам не нужно использовать явные приведения, потому что компилятор следит за is-проверками для неизменяемых значений и вставляет приведения автоматически, там, где они нужны:

```kt
fun demo(x: Any) {
    if (x is String) {
        print(x.length) // x автоматически преобразовывается в String
    }
}
```

Компилятор достаточно умён для того, чтобы делать автоматические приведения в случаях, когда проверка на несоответствие типу (!is) приводит к выходу из функции:

```kt
if (x !is String) return

// x автоматически преобразовывается в String
print(x.length) 
```

или в случаях, когда приводимая переменная находится справа от оператора && или ||:

```kt
// x автоматически преобразовывается в String справа от `||`
if (x !is String || x.length == 0) return

// x автоматически преобразовывается в String справа от `&&`
if (x is String && x.length > 0) {
    print(x.length) // x автоматически преобразовывается в String
}
```

Заметьте, что умные приведения не работают, когда компилятор не может гарантировать, что переменная не изменится между проверкой и использованием. Более конкретно, умные приведения будут работать:

* с локальными val переменными - всегда;
* с val свойствами - если поле имеет модификатор доступа private или internal, или проверка происходит в том же модуле, в котором объявлено это свойство. Умные приведения неприменимы к публичным свойствам или свойствам, которые имеют переопределённые getter'ы;
* с локальными var переменными - если переменная не изменяется между проверкой и использованием и не захватывается лямбдой, которая её модифицирует;
* с var свойствами - никогда (потому что переменная может быть изменена в любое время другим кодом).

**Оператор "небезопасного" приведения**

Этот оператор приведения выбрасывает исключение, если приведение невозможно, поэтому мы называем его небезопасным. Небезопасное приведение в Kotlin выполняется с помощью инфиксного оператора **as**:

```kt
val x: String = y as String
```

Заметьте, что null не может быть приведен к String, так как String не является nullable, т.е. если y - null, код выше выбросит исключение. Чтобы соответствовать семантике приведений в Java, нам нужно указать nullable тип в правой части приведения:

```kt
val x: String? = y as String?
```

## Null безопасность

### Nullable типы и Non-Null типы

Система типов в языке Kotlin нацелена на то, чтобы искоренить опасность обращения к null значениям, более известную как "Ошибка на миллион".

Самым распространённым подводным камнем многих языков программирования, в том числе Java, является попытка произвести доступ к null значению. Это приводит к ошибке. В Java такая ошибка называется NullPointerException (сокр. "NPE").

Kotlin призван исключить ошибки подобного рода из нашего кода. NPE могу возникать только в случае:

* Явного указания throw NullPointerException()
* Использования оператора !! (описано ниже)
* Эту ошибку вызвал внешний Java-код
* Есть какое-то несоответствие при инициализации данных (в конструкторе использована ссылка this на данные, которые не были ещё проинициализированы)

Система типов Kotlin различает ссылки на те, которые могут иметь значение null (nullable ссылки) и те, которые таковыми быть не могут (non-null ссылки). К примеру, переменная часто используемого типа String не может быть null:

```kt
var a: String = "abc"
a = null // ошибка компиляции
```

Для того, чтобы разрешить null значение, мы можем объявить эту строковую переменную как String?:

```kt
var b: String? = "abc"
b = null // ok
```

Теперь, при вызове метода с использованием переменной a, исключены какие-либо NPE. Вы спокойно можете писать:

```kt
val l = a.length
```

Но в случае, если вы захотите получить доступ к значению b, это будет небезопасно. Компилятор предупредит об ошибке:

```kt
val l = b.length // ошибка: переменная `b` может быть null
```

Но нам по-прежнему надо получить доступ к этому свойству/значению, так? Есть несколько способов этого достичь.

### Проверка на null

Первый способ. Вы можете явно проверить b на null значение и обработать два варианта по отдельности:

```kt
val l = if (b != null) b.length else -1
```

Компилятор отслеживает информацию о проведённой вами проверке и позволяет вызывать length внутри блока if. Также поддерживаются более сложные конструкции:

```kt
if (b != null && b.length > 0) {
    print("String of length ${b.length}")
} else {
    print("Empty string")
}
```

Обратите внимание: это работает только в том случае, если b является неизменной переменной (ориг.: immutable). Например, если это локальная переменная, значение которой не изменяется в период между его проверкой и использованием. Также такой переменной может служить val. В противном случае может так оказаться, что переменная b изменила своё значение на null после проверки.

### Безопасные вызовы

Вторым способом является оператор безопасного вызова ?.:

```kt
x = b?.length
```

Этот код возвращает b.length в том, случае, если b не имеет значение null. Иначе он возвращает null. Типом этого выражения будет Int?.

Такие безопасные вызовы полезны в цепочках. К примеру, если Bob, Employee (работник), может быть прикреплён (или нет) к отделу Department, и у отдела может быть управляющий, другой Employee. Для того, чтобы обратиться к имени этого управляющего (если такой есть), напишем:

```kt
bob?.department?.head?.name
```

Такая цепочка вернёт null в случае, если одно из свойств имеет значение null.

Для проведения каких-либо операций исключительно над non-null значениями вы можете использовать let оператор вместе с оператором безопасного вызова:

```kt
val listWithNulls: List<String?> = listOf("A", null)
for (item in listWithNulls) {
    item?.let { println(it) } // выводит A и игнорирует null
}
```

### Элвис-оператор

Если у нас есть nullable ссылка r, мы можем либо провести проверку этой ссылки и использовать её, либо использовать non-null значение x:

```kt
val l: Int = if (b != null) b.length else -1
```

Аналогом такому if-выражению является элвис-оператор **?:**:

```kt
val l = b?.length ?: -1
```

Если выражение, стоящее слева от Элвис-оператора, не является null, то элвис-оператор его вернёт. В противном случае, в качестве возвращаемого значения послужит то, что стоит справа. Обращаем ваше внимание на то, что часть кода, расположенная справа, выполняется ТОЛЬКО в случае, если слева получается null.

Так как throw и return тоже являются выражениями в Kotlin, их также можно использовать справа от Элвис-оператора. Это может быть крайне полезным для проверки аргументов функции:

```kt
fun foo(node: Node): String? {
    val parent = node.getParent() ?: return null
    val name = node.getName() ?: throw IllegalArgumentException("name expected")
    // ...
}
```

### Оператор !!

Для любителей NPE существует ещё один способ. Мы можем написать b!! и это вернёт нам либо non-null значение b (в нашем примере вернётся String), либо выкинет NPE:

```kt
val l = b!!.length
```

В случае, если вам нужен NPE, вы можете заполучить её только путём явного указания.

### Безопасные приведения типов

Обычное приведение типа может вызвать ClassCastException в случае, если объект имеет другой тип. Можно использовать безопасное приведение, которое вернёт null, если попытка не удалась:

```kt
val aInt: Int? = a as? Int
```

### Коллекции nullable типов

Если у вас есть коллекция nullable элементов и вы хотите отфильтровать все non-null элементы, используйте функцию filterNotNull.

```kt
val nullableList: List<Int?> = listOf(1, 2, null, 4)
val intList: List<Int> = nullableList.filterNotNull()
```

## Операции с числами

### Арифметические операции

Kotlin поддерживает базовые арифметические операции:

``+`` (сложение): возвращает сумму двух чисел.

```kt
val x = 5
val y = 6
val z = x + y
println(z)      // z = 11
```

``-`` (вычитание): возвращает разность двух чисел.

```kt
val x = 5
val y = 6
val z = x - y  // z = -1
```

``*`` (умножение): возвращает произведение двух чисел.

```kt
val x = 5
val y = 6
val z = x * y  // z = 30
```

``/`` (деление): возвращает частное двух чисел.

```kt
val x = 60
val y = 10
val z = x / y  // z = 6
```

``%``: возвращает остаток от целочисленного деления двух чисел.

```kt
val x = 65
val y = 10
val z = x % y  // z = 5
```

``++`` (инкремент): увеличивает значение на единицу.

Префиксный инкремент возвращает увеличенное значение:

```
var x = 5
val y = ++x
println(x)      // x = 6
println(y)      // y = 6
```

Постфиксный инкремент возвращает значение до увеличения на единицу:

```kt
var x = 5
val y = x++
println(x)      // x = 6
println(y)      // y = 5
```

``--`` (декремент): уменьшает значение на единицу.

Префиксный декремент возвращает уменьшенное значение:

```kt
var x = 5
val y = --x
println(x)      // x = 4
println(y)      // y = 4
```

Постфиксный декремент возвращает значение до уменьшения на единицу:

```kt
var x = 5
val y = x--
println(x)      // x = 4
println(y)      // y = 5
```

Также есть ряд операций присвоения, которые сочетают арифметические операции и присвоение:

``+=``: присваивание после сложения. Присваивает левому операнду сумму левого и правого операндов: A += B эквивалентно A = A + B

``-=``: присваивание после вычитания. Присваивает левому операнду разность левого и правого операндов: A -= B эквивалентно A = A - B

``*=``: присваивание после умножения. Присваивает левому операнду произведение левого и правого операндов: A *= B эквивалентно A = A * B

``/=``: присваивание после деления. Присваивает левому операнду частное левого и правого операндов: A /= B эквивалентно A = A / B

``%=``: присваивание после деления по модулю. Присваивает левому операнду остаток от целочисленного деления левого операнда на правый: A %= B эквивалентно A = A % B

### Побитовые операторы

Ряд операций выполняется над двоичными разрядми числа. Здесь важно понимать, как выглядит двоичное представление тех или иных чисел. В частности, число 4 в двоичном виде - 100, а число 15 - 1111.

Есть следующие побитовые операторы (они применяются только к данным типов Int и Long):

**shl**: сдвиг битов числа со знаком влево

```kt
val z = 3 shl 2     // z = 11 << 2 = 1100 
println(z)          // z = 12
val d = 0b11 shl 2
println(d)          // d = 12
```

В данном случае число сдвигается на два разряда влево, поэтому справа число в двоичном виде дополняется двумя нулями. То есть в двоичном виде 3 представляет 11. Сдвигаем на два разряда влево (дополняем справа двумя нулями) и получаем 1100, то есть в десятичной системе число 12.

**shr**: сдвиг битов числа со знаком вправо

```kt
val z = 12 shr 2     // z = 1100 >> 2 = 11
println(z)          // z = 3
val d = 0b1100 shr 2
println(d)          // d = 3
```

Число 12 сдвигается на два разряда вправо, то есть два числа справа факически отбрасываем и получаем число 11, то есть 3 в десятичой системе.

**ushr**: сдвиг битов беззнакового числа вправо

```kt
val z = 12 ushr 2     // z = 1100 >> 2 = 11
println(z)          // z = 3
```

**and**: побитовая операция AND (логическое умножение или конъюнкция). Эта операция сравнивает соответствующие разряды двух чисел и возвращает единицу, если эти разряды обоих чисел равны 1. Иначе возвращает 0.

```kt
val x = 5   // 101
val y = 6   // 110
val z = x and y     // z = 101 & 110 = 100
println(z)          // z = 4
 
val d = 0b101 and 0b110
println(d)          // d = 4
```

**or**: побитовая операция OR (логическое сложение или дизъюнкция). Эта операция сравнивают два соответствуюших разряда обоих чисел и возвращает 1, если хотя бы один разряд равен 1. Если оба разряда равны 0, то возвращается 0.

```kt
val x = 5   // 101
val y = 6   // 110
val z = x or y     // z = 101 | 110 = 111
println(z)         // z = 7
 
val d = 0b101 or 0b110
println(d)          // d = 7
```

**xor**: побитовая операция XOR. Сравнивает два разряда и возвращает 1, если один из разрядов равен 1, а другой равен 0. Если оба разряда равны, то возвращается 0.

```kt
val x = 5   // 101
val y = 6   // 110
val z = x xor y     // z = 101 ^ 110 = 011
println(z)         // z = 3
 
val d = 0b101 xor 0b110
println(d)          // d = 3
```

**inv**: логическое отрицание или инверсия - инвертирует биты числа

```kt
val b = 11  // 1011
val c = b.inv()
println(c)      // -12
```

## Условные выражения

Условные выражения представляют некоторое условие, которое возвращает значение типа Boolean: либо true (если условие истинно), либо false (если условие ложно).

### Операции отношения
``>`` (больше чем): возвращает true, если первый операнд больше второго. Иначе возвращает false

```kt
val a = 11
val b = 12
val c : Boolean =  a > b
println(c)      // false - a меньше чем b
 
val d = 35 > 12
println(d)      // true - 35 больше чем 12
```

``<`` (меньше чем): возвращает true, если первый операнд меньше второго. Иначе возвращает false

```kt
val a = 11
val b = 12
val c =  a < b   // true
 
val d = 35 < 12  // false
```

``>=`` (больше чем или равно): возвращает true, если первый операнд больше или равен второму

```kt
val a = 11
val b = 12
val c = a >= b      // false
val d = 11 >= a     // true
```

``<=`` (меньше чем или равно): возвращает true, если первый операнд меньше или равен второму.

```kt
val a = 11
val b = 12
val c = a <= b      // true
val d = 11 <= a     // false
```

``==`` (равно): возвращает true, если оба операнда равны. Иначе возвращает false

```kt
val a = 11
val b = 12
val c = a == b      // false
val d = b == 12     // true
```

``!=`` (не равно): возвращает true, если оба операнда НЕ равны

```kt
val a = 11
val b = 12
val c = a != b      // true
val d = b != 12     // false
```

### Логические операции

Операндами в логических операциях являются два значения типа Boolean. Нередко логические операции объединяют несколько операций отношения:

**and**: возвращает true, если оба операнда равны true.

```kt
val a = true
val b = false
val c = a and b                         // false
val d = (11 >= 5) and (9 < 10)     // true
println(c)
println(d)
```

**or**: возвращает true, если хотя бы один из операндов равен true.

```kt
val a = true
val b = false
val c = a or b                          // true
val d = (11 < 5) or (9 > 10)     // false
```

**xor**: возвращает true, если только один из операндов равен true. Если операнды равны возвращается false

```kt
val a = true
val b = false
val c = a xor b                 // true
val d = a xor (90 > 10)      // false
```

**!**: возвращает true, если операнд равен false. И, наоборот, если операнд равен false, возвращает true.

```kt
val a = true
val b = !a  // false
val c = !b  // true
```

В качестве альтернативы оператору ! можно использовать метод not():

```kt
val a = true
val b = a.not()  // false
val c = b.not()  // true
```

**in**: возвращает true, если операнд имеется в некоторой последовательности.

```kt
val a = 5
val b = a in 1..6       // true
```

Выражение 1..6 создает последовательность чисел от 1 до 6. И в данном случае оператор in проверяет, есть ли значение переменной a в этой последовательности. Поскольку значение переменной a имеется в данной последовательности, то возвращается true.

## Условные конструкции

Условные конструкции позволяют направить выполнение программы по одному из путей в зависимости от условия.

### if...else

Конструкция if принимает условие, и если это условие истинно, то выполняется последующий блок инструкций.

```kt
val a = 10
if(a == 10) {
    println("a равно 10")
}
```

В данном случае в конструкции if проверяется истинность выражения a == 10, если оно истинно, то выполняется последующий блок кода в фигурных скобках, и на консоль выводится сообщение "a равно 10". Если же выражение ложно, тогда блок кода не выполняется.

Если необходимо задать альтернативный вариант, то можно добавить блок else:

```kt
val a = 10
if(a == 10) {
    println("a равно 10")
}
else{
    println("a НЕ равно 10")
}
```

Таким образом, если условное выражение после оператора if истинно, то выполняется блок после if, если ложно - выполняется блок после else.

Если блок кода состоит из одного выражения, то в принципе фигурные скобки можно опустить:

```kt
val a = 10
if(a == 10)
    println("a равно 10")
else
    println("a НЕ равно 10")
```

Если необходимо проверить несколько альтернативных вариантов, то можно добавить выражения else if:

```kt
val a = 10
if(a == 10) {
    println("a равно 10")
}
else if(a == 9){
    println("a равно 9")
}
else if(a == 8){
    println("a равно 8")
}
else{
    println("a имеет неопределенное значение")
}
```

Стоит отметить, что конструкция if может возвращать значение. Например, найдем максимальное из двух чисел:

```kt
val a = 10
val b = 20
val c = if (a > b) a else b
 
println(c)  // 20
```

Если при определении возвращаемого значения надо выполнить еще какие-нибудь действия, то можно заключить эти действия в блоки кода:

```kt
val a = 10
val b = 20
val c = if (a > b){
    println("a = $a")
    a
} else {
    println("b = $b")
    b
}
```

В конце каждого блока указывается возвращаемое значение.

### Конструкция when

Конструкция when проверяет значение некоторого объекта и в зависимости от его значения выполняет тот или иной код. Конструкция when аналогична конструкции switch в других языках.

```kt
val a = 10
when(a){
    10 -> println("a = 10")
    20 -> println("a = 20")
    else -> println("неопределенное значение")
}
```

После ключевого слова when в скобках идет выражение. Затем идет блок кода, в котором определяются значения для сравнения. После каждого значения после стрелки -> идет последовательность выполняемых инструкций:

```kt
10 -> println("a = 10")
```

То есть в данном случае если переменная a равна 10, то на консоль будет выводиться сообщение "a = 10".

Если ни одно из значений в блоке when не соответствуют выражению, то выполняются инструкции из выражения else. Выражение else не обязательное, его можно не определять.

Если надо, чтобы при совпадении значений выполнялось несколько инструкций, то для каждого значения можно определить блок кода:

```kt
var a = 10
when(a){
    10 -> {
        println("a = 10")
        a *= 2
    }
    20 -> {
        println("a = 20")
        a *= 5
    }
    else -> { println("неопределенное значение")}
}
println(a)
```

Можно определить одни и те же действия сразу для нескольких значений. В этом случае значения перечисляются через запятую:

```kt
val a = 10
when(a){
    10, 20 -> println("a = 10 или a = 20")
    else -> println("неопределенное значение")
}
```

Также можно сравнивать с целым диапазоном значений с помощью оператора in:

```kt
val a = 10
when(a){
    in 10..19 -> println("a в диапазоне от 10 до 19")
    in 20..29 -> println("a в диапазоне от 20 до 29")
    !in 10..20 -> println("a вне диапазона от 10 до 20")
    else -> println("неопределенное значение")
}
```

Если оператор in позволяет узнать, есть ли значение в определенном диапазоне, то связка операторов !in позволяет проверить отсутствие значения в определенной последовательности.

#### Возвращение значения

Как и if конструкция when может возвращать значение:

```kr
val sum = 1000
 
val rate = when(sum){
    in 100..999 -> 10
    in 1000..9999 -> 15
    else -> 20
}
println(rate)       // 15
```

Таким образом, если значение переменной sum располагается в определенном диапазоне, то возвращается то значение, которое идет после стрелки.

Также вместе с when-выражениями работают умные приведения (is, !is)

```kt
when (x) {
    is Int -> print(x + 1)
    is String -> print(x.length + 1)
    is IntArray -> print(x.sum())
}
```

## Циклы

Циклы представляют вид управляющих конструкций, которые позволяют в зависимости от определенных условий выполнять некоторое действие множество раз.

### For

Цикл for пробегается по всем элементам коллекции. В этом плане цикл for в Kotlin эквивалентен циклу for-each в ряде других языков программирования. Его формальная форма выглядит следующим образом:

```kt
for(переменная in поледовательность){
    выполняемые инструкции
}
```

Например, выведем все квадраты чисел от 1 до 9, используя цикл for:

```kt
for(n in 1..9){
    print("${n * n} \t")
}
```

В данном случае перебирается последовательность чисел от 1 до 9. При каждом проходе цикла (итерации цикла) из этой последовательности будет извлекаться элемент и помещаться в переменную n. И через переменную n можно манипулировать значением элемента. То есть в данном случае мы получим следующий консольный вывод:

```
1 	4 	9 	16 	25 	36 	49 	64 	81
```

Циклы могут быть вложенными. Например, выведем таблицу умножения:

```kt
for(i in 1..9){
    for(j in 1..9){
        print("${i * j} \t")
    }
    println()
}
```

В итоге на консоль будет выведена следующая таблица умножения:

```
1 	2 	3 	4 	5 	6 	7 	8 	9 	
2 	4 	6 	8 	10 	12 	14 	16 	18 	
3 	6 	9 	12 	15 	18 	21 	24 	27 	
4 	8 	12 	16 	20 	24 	28 	32 	36 	
5 	10 	15 	20 	25 	30 	35 	40 	45 	
6 	12 	18 	24 	30 	36 	42 	48 	54 	
7 	14 	21 	28 	35 	42 	49 	56 	63 	
8 	16 	24 	32 	40 	48 	56 	64 	72 	
9 	18 	27 	36 	45 	54 	63 	72 	81
```

### Цикл while

Цикл while повторяет определенные действия пока истинно некоторое условие:

```kt
var i = 10
while(i > 0){
    println(i*i)
    i--;
}
```

Здесь пока переменная i больше 0, будет выполняться цикл, в котором на консоль будет выводиться квадрат значения i.

В данном случае вначале проверяется условие (i > 0) и если оно истинно (то есть возвращает true), то выполняется цикл. И вполне может быть ситуация, когда к началу выполнения цикла условие не будет выполняться. Например, переменная i изначально меньше 0, тогда цикл вообще не будет выполняться.

Но есть и другая форма цикла while - do..while:

```kt
var i = -1
do{
    println(i*i)
    i--;
}
while(i > 0)
```

В данном случае вначале выполняется блок кода после ключевого слова do, а потом оценивается условие после while. Если условие истинно, то повторяется выполнение блока после do. То есть несмотря на то, что в данном случае переменная i меньше 0 и она не соответствует условию, тем не менее блок do выполнится хотя бы один раз.

### Операторы continue и break

Иногда при использовании цикла возникает необходимость при некоторых условиях не дожидаться выполнения всех инструкций в цикле, перейти к новой итерации. Для этого можно использовать оператор continue:

```kt
for(n in 1..8){
    if(n == 5) continue;
    println(n * n)
}
```

В данном случае когда n будет равно 5, сработает оператор continue. И последующая инструкция, которая выводит на консоль квадрат числа, не будет выполняться. Цикл перейдет к обработке следующего элемента в массиве

Бывает, что при некоторых условиях нам вовсе надо выйти из цикла, прекратить его выполнение. В этом случае применяется оператор break:

```kt
for(n in 1..5){
    if(n == 5) break;
    println(n * n)
}
```

В данном случае когда n окажется равен 5, то с помощью оператора break будет выполнен выход из цикла. Цикл полностью завершится.

## Последовательности

Последовательность представляет набор значений или диапазон. Для создания последовательности применяется оператор ..:

```kt
var range = 1..5    // последовательность [1, 2, 3, 4, 5]
```

Этот оператор принимает два значения - границы последовательности, и все элементы между этими значениями (включая их самих) составляют последовательность.

Последовательность необязательно должна представлять числовые данные. Например, это могут быть строки:

```kt
var range =  "a".."d"
```

Оператор .. позволяет создать последовательность по нарастающей, где каждый следующий элемент будет больше предыдущего. С помощью специальной функции downTo можно построить последовательность в обратном порядке:

```kt
var range1 =  1..5      // 1 2 3 4 5
var range2 =  5 downTo 1    // 5 4 3 2 1
```

Еще одна специальная функция step позволяет задать шаг, на который будут изменяться последующие элементы:

```kt
var range1 = 1..10 step 2           // 1 3 5 7 9
var range2 = 10 downTo 1 step 3     // 10 7 4 1
```

Еще одна функция until позволяет не включать верхнюю границу в саму последовательность:

``` kt
var range1 = 1 until 9          // 1 2 3 4 5 6 7 8
var range2 = 1 until 9 step 2   // 1 3 5 7
```

С помощью специальных операторов можно проверить наличие или отсутствие элементов в последовательности:

in: возвращает true, если объект имеется в последовательности

!in: возвращает true, если объект отсутствует в последовательности

```kt
fun main(args: Array<String>) {
     var range = 1..5
 
    var isInRange = 5 in range
    println(isInRange)      // true
 
    isInRange = 86 in range
    println(isInRange)      // false
 
    var isNotInRange = 6 !in range
    println(isNotInRange)   // true
 
    isNotInRange = 3 !in range
    println(isNotInRange)   // false
}
```

С помощью цикла for можно перебирать последовательность:

```kt
var range1 = 5 downTo 1 
for(c in range1) print(c)   // 54321
println()
for(c in 1..9) print(c)     // 123456789
println()
for(c in 1 until 9) print(c)    // 12345678
println()
for(c in 1..9 step 2) print(c)  // 13579
```

## Массивы

Массив представляет набор данных одного типа. В языке Kotlin массивы представлены типом Array.

При определении массива после типа Array в угловых скобках необходимо указать, объекты какого типа могут храниться в массиве. Например, определим массив целых чисел:

```kt
val numbers: Array<Int>
```

С помощью встроенной функции arrayOf() можно передать набор значений, которые будут составлять массив:

```kt
val numbers: Array<Int> = arrayOf(1, 2, 3, 4, 5)
```

То есть в данном случае в массиве 5 чисел от 1 до 5.

С помощью индексов мы можем обратиться к определенному элементу в массиве. Индексация начинается с нуля, то есть первый элемент буде иметь индекс 0. Индекс указывается в квадратных скобках:

```kt
val numbers: Array<Int> = arrayOf(1, 2, 3, 4, 5)
val n = numbers[1]  // получаем второй элемент  n=2
numbers[2] = 7      // переустанавливаем третий элемент
```

Также инициализировать массив значениями можно следующим способом:

```kt
val numbers = Array(3, {5}) // [5, 5, 5]
```

Здесь применяется конструктор класса Array. В этот конструктор передаются два параметра. Первый параметр указывает, сколько элементов будет в массиве. В данном случае 3 элемента. Второй параметр представляет выражение, которое генерирует элементы массива. Оно заключается в фигурные скобки. В данном случае в фигурных скобках стоит число 5, то есть все элементы массива будут представлять число 5. Таким образом, массив будет состоять из трех пятерок.

Для упрощения создания массива в Kotlin определены дополнительные типы BooleanArray, ByteArray, ShortArray, IntArray, LongArray, CharArray, FloatArray и DoubleArray, которые позволяют создавать массивы для определенных типов. Например, тип IntArray позволяет определить массив объектов Int, а DoubleArray - массив объектов Double:

```kt
val numbers: IntArray = intArrayOf(1, 2, 3, 4, 5)
val doubles: DoubleArray = doubleArrayOf(2.4, 4.5, 1.2)
```

Для определения данных для этих массивов можно применять функции, которые начинаются на название типа в нижнем регистре, например, int, и затем идет ArrayOf.

Аналогично для инициализации подобных массивов также можно применять конструктор соответствуюшего класса:

```kt
val numbers = IntArray(3, {5})
val doubles = DoubleArray(3, {1.5})
```

Как и в случае с последовательностью мы можем проверить наличие или отсутствие элементов в массиве с помощью операторов in и !in:

```kt
val numbers: Array<Int> = arrayOf(1, 2, 3, 4, 5)
 
println(4 in numbers)       // true
println(2 !in numbers)      // false
```

### Двухмерные массивы

Выше рассматривались одномерные массивы, которые можно представить в виде ряда или строки значений. Но кроме того, мы можем использовать многомерные массивы. К примеру, возьмем двухмерный массив - то есть такой массив, каждый элемент которого в свою очередь сам является массивом. Двухмерный массив еще можно представить в виде таблицы, где каждая строка - это отдельный массив, а ячейки строки - это элементы вложенного массива.

Определение двухмерных массивов менее интуитивно понятно и может вызывать сложности. Например, двухмерный массив чисел:

```kt
val table: Array<Array<Int>> = Array(3, { Array(5, {0}) })
```

В данном случае двухмерный массив будет иметь три элемента - три строки. Каждая строка будет иметь по пять элементов, каждый из которых равен 0.

Используя индексы, можно обращаться к подмассивам в подобном массиве, в том числе переустанавливать их значения:

```kt
val table = Array(3, { Array(3, {0}) })
table[0] = arrayOf(1, 2, 3)
table[1] = arrayOf(4, 5, 6)
table[2] = arrayOf(7, 8, 9)
```

Для обращения к элементам подмассивов двухмерного массива необходимы два индекса. По первому индексу идет получение строки, а по второму индексу - столбца в рамках этой строки:

```kt
val table = Array(3, { Array(3, {0}) })
table[0][1] = 6  // второй элемент первой строки
val n = table[0][1]     // n = 6
```

Перебор массивов
Для перебора массивов применяется цикл for:

```kt
val phones: Array<String> = arrayOf("Galaxy S8", "iPhone X", "Motorola C350")
for(phone in phones){
    println(phone)
}
```

В данном случае переменная phones представляет массив строк. При переборе этого массива в цикле каждый его элемент оказывается в переменной phone. Консольный вывод программы:

```
Galaxy S8
iPhone X
Motorola C350
```

Используя два цикла, можно перебирать двухмерные массивы:

```kt
fun main(args: Array<String>) {
    val table: Array<Array<Int>> = Array(3, { Array(3, {0}) })
    table[0] = arrayOf(1, 2, 3)
    table[1] = arrayOf(4, 5, 6)
    table[2] = arrayOf(7, 8, 9)
    for(row in table){
        for(cell in row){
            print("$cell \t")
        }
        println()
    }
}
```

С помощью внешнего цикла for(row in table) пробегаемся по всем элементам двухмерного массива, то есть по строкам таблицы. Каждый из элементов двухмерного массива сам представляет массив, поэтому мы можем пробежаться по этому массиву и получить из него непосредственно те значения, которые в нем хранятся. В итоге на консоль будет выведено следующее:

```
1 	2 	3 	
4 	5 	6 	
7 	8 	9
```

***

КОНТРОЛЬНЫЕ ВОПРОСЫ:

1. Типы переменных


[содержание](/readme.md)  
