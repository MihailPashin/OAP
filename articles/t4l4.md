[содержание](/readme.md)

# Потоки и асинхронные вычисления. Корутины.

С появлением многоядерных процессоров стала общеупотребительной практика распространять нагрузку на все доступные ядра. Существует несколько основных подходов в распределении нагрузки: использование процессов, потоков и асинхронное выполнение.

Использование нескольких процессов фактически означает использование нескольких программ, которые выполняются независимо друг от друга. Такой подход создает большие неудобства в управлении обмена данными между этими программами.

В качестве альтернативы существует другой подход – создание многопоточных программ. Обмен данными между потоками существенно упрощается. Но управление такими программами усложняется, и вся ответственность ложится на программиста.

Процессы мы в рамках этого курса рассматривать не будем. Остановимся на потоках и асинхронной работе.

## Как работают потоки

Когда запускается любое приложение, то начинает выполняться поток, называемый главным потоком (main). От него, при необходимости, порождаются дочерние потоки. Главный поток, как правило, является последним потоком, завершающим выполнение программы.

Потоки позволяют выполнять несколько задач одновременно, не мешая друг другу, что даёт возможность эффективно использовать системные ресурсы. Потоки используются в тех случаях, когда одно долгоиграющее действие не должно мешать другим действиям. Например, у нас есть музыкальный проигрыватель с кнопками воспроизведения и паузы. Если вы нажимаете кнопку воспроизведения и у вас запускается музыкальный файл в отдельном потоке, то вы не можете нажать на кнопку паузы, пока файл не воспроизведётся полностью. С помощью потоков вы можете обойти данное ограничение.

Когда в одной программе работают несколько потоков, возникает проблема разграничения доступа потоков к общим данным. Предположим, что есть два потока, имеющих доступ к общему списку. Первый поток может делать итерацию по этому списку:

```kt
for(x in L) ...
```

а второй в этот момент начнет удалять значения из этого списка. Тут может произойти все что угодно: программа может упасть, или мы просто получим неверные данные.

Решением в этом случае является применение блокировки. При этом доступ к заблокированному списку будет иметь только один поток, второй будет ждать, пока блокировка не будет снята.

Применение блокировки порождает другую проблему – дедлок (deadlock) – мертвая блокировка. Пример дедлока: имеется два потока и два списка. Первый поток блокирует первый список, второй поток блокирует второй список. Первый поток изнутри первой блокировки пытается получить доступ к уже заблокированному второму списку, второй поток пытается проделать то же самое с первым списком. Получается неопределенная ситуация с бесконечным ожиданием. Эту ситуации легко описать, на практике все гораздо сложнее.

Вариантом решения проблемы дедлоков является политика определения очередности блокировок. Например, в предыдущем примере мы должны определить, что блокировка первого списка идет всегда первой, а уже потом идет блокировка второго списка.

Другая проблема с блокировками – в том, что несколько потоков могут одновременно ждать доступа к уже заблокированному ресурсу и при этом ничего не делать.

### Создание потоков

Для создания потока в Kotlin есть функция **thread**. 

```
fun thread(
    start: Boolean = true,
    isDaemon: Boolean = false,
    contextClassLoader: ClassLoader? = null,
    name: String? = null,
    priority: Int = -1,
    block: () -> Unit
): Thread
```

В параметрах необходимо передать функцию (параметр block), которая будет выполнятся в созданном потоке.

Параметры функции:

* **start: Boolean = true** - запустить блок сразу после создания потока. Значение по-умолчанию *true*, значит параметр можно не указывать, а *false* использовать, если нужно создать поток, но не запускать его сразу.

* **isDaemon: Boolean = false** - если поток создан в режиме демона, то он не препятствует закрытию приложения. Примером демона может служить поток таймера, посылающий регулярные "тики" другим потокам. Обычно приложение продолжает работать, пока работает хотя бы один поток. 

* **contextClassLoader: ClassLoader? = null** - Загрузчик классов для использования для загрузки классов и ресурсов

* **name: String? = null** - название потока (может пригодиться в логах)

* **priority: Int = -1** - приоритет потока, чем больше, тем выше. В Java объявлены три константы:
```java
public static final int MIN_PRIORITY = 1;
public static final int NORM_PRIORITY = 5;
public static final int MAX_PRIORITY = 10;
```

* **block: () -> Unit** - собственно блок кода, который будет выполнятся в потоке.

```kt
fun main(args: Array<String>){
    //можно создать поток и запустить его отдельной командой 
    //val t=thread(start=false, block = { backgroundThreadProcessing() } )
    //t.start()

    //а можно сразу запустить поток
    thread( block = { backgroundThreadProcessing() } )

    //или даже так
    //thread{ backgroundThreadProcessing() }

    for (i in 0..10){
        sleep(100)
        println(i)
    }
}

fun backgroundThreadProcessing(){
    for (i in 0..10){
        sleep(200)
        println(i)
    }
}
```

Функцкия **sleep(delay: Long)** останавливает текущий поток на *delay* миллисекунд (крайне не рекомендуется это делать в основном потоке).

**.isAlive** - узнать состояние потока. true, если поток выполняется.

**.join(delay: Long = 0)** - ожидает завершения потока в течении *delay* миллисекунд. *Delay* = 0 означает, что ожидание бесконечное.

**.interrupt()** - метод завершения или прерывания потока. Вызов этого метода устанавливает у потока статус, что он прерван. Сам метод возвращает true, если поток может быть прерван, в ином случае возвращается false.

При этом сам вызов этого метода НЕ завершает поток, он только устанавливает статус: в частности, метод isInterrupted() класса Thread будет возвращать значение true. Мы можем проверить значение возвращаемое данным методом и прозвести некоторые действия. 

В блоке кода при установленном статусе прерывания возникнет исключение. Необходимо его перехватить и завершить работу:

```kt
fun main(args: Array<String>){
    var t = thread{ backgroundThreadProcessing() }
    for (i in 0..10) {
        sleep(100)
        println(i)
    }
    t.interrupt()
}

fun backgroundThreadProcessing(){
    try {
        for (i in 0..10) {
            sleep(200)
            println(i)
        }
    }catch (e: InterruptedException){}
}
```

### [Синхронизация потоков](https://proglib.io/p/kotlin-java-tips/)

**Анотация @Volatile** - применяется к переменным и гарантирует, что считываемое значение поступает из основной памяти, а не из кэша процессора, поэтому все участники процесса будут ожидать окончания параллельной записи, прежде чем считать значение.

```kt
@Volatile var someVar: Int = 0
```

**Анотация @Syncronized** - применяется к функциям или блокам кода. Аналогично аннотоции Volatile гарантирует, что функция/блок монопольно используются одним потоком.

```kt
@Synchronized fun someFun(){
  //
}
```

**Lock** - выполняет примерно те же функции, что и synchronized, только более гибко. synchronized даёт возможность синхронизировать блоки кода, тогда как с Lock можно реализовывать более сложную логику. После метода Lock нужно обязательно использовать конструкцию *try .. finally*, чтобы гарантировано разблокировать доступ.

```kt
val lock = ReentrantLock()

...

lock.lock()
try {
    //
} finally {
    lock.unlock()
}
```

## Асинхронное выполнение кода (Корутины)

* https://www.codeflow.site/ru/article/kotlin-threads-coroutines
* https://kotlinlang.ru/docs/reference/coroutines.html

Соблазнительно думать, что порождение большего количества потоков может помочь нам выполнять больше задач одновременно. К сожалению, это не всегда так.

Создание слишком большого количества потоков может на самом деле сделать приложение неэффективным в некоторых ситуациях; потоки - это объекты, которые накладывают накладные расходы во время размещения объектов и сборки мусора.

Чтобы преодолеть эти проблемы, Kotlin представил новый способ написания асинхронного неблокирующего кода: Coroutine.

Подобно потокам, сопрограммы могут работать одновременно, ожидать и общаться друг с другом, с той разницей, что их создание намного дешевле, чем потоков.

Сопрограммы обеспечивают возможность избежать блокировки исполняющегося потока путём использования более дешёвой и управляемой операции: приостановки (suspend) сопрограммы.

Сопрограммы упрощают асинхронное программирование, оставив все осложнения внутри библиотек. Логика программы может быть выражена последовательно в сопрограммах, а базовая библиотека будет её реализовывать асинхронно. Библиотека может обернуть соответствующие части кода пользователя в обратные вызовы (callbacks), подписывающиеся на соответствующие события, и диспетчировать исполнение на различные потоки (или даже на разные машины!). Код при этом останется столь же простой, как если бы исполнялся строго последовательно.

### Блокирование против приостановки

Главным отличительным признаком сопрограмм является то, что они являются вычислениями, которые могут быть приостановлены без блокирования потока (вытеснения средствами операционной системы). Блокирование потоков часто является весьма дорогостоящим, особенно при интенсивных нагрузках: только относительно небольшое число потоков из общего числа является активно выполняющимися, поэтому блокировка одного из них ведет к затягиванию какой-нибудь важной части итоговой работы.

С другой стороны, приостановка сопрограммы обходится практически бесплатно. Не требуется переключения контекста (потоков) или иного вовлечения механизмов операционной системы. И сверх этого, приостановка может гибко контролироваться пользовательской библиотекой во многих аспектах: в качестве авторов библиотеки мы можем решать, что происходит при приостановке, и оптимизировать, журналировать или перехватывать в соответствии со своими потребностями.

Еще одно отличие заключается в том, что сопрограммы не могут быть приостановлены на произвольной инструкции, а только в так называемых точках остановки (приостановки), которые вызываются в специально маркируемых функциях.

### Останавливаемые функции

Приостановка происходит в случае вызова функции, обозначенной специальным модификатором suspend:

```kt
suspend fun doSomething(foo: Foo): Bar {
    ...
}
```

Такие функции называются функциями остановки (приостановки), поскольку их вызовы могут приостановить выполнение сопрограммы (библиотека может принять решение продолжать работу без приостановки, если результат вызова уже доступен). Функции остановки могут иметь параметры и возвращать значения точно так же, как и все обычные функции, но они могут быть вызваны только из сопрограмм или других функций остановки. В конечном итоге, при старте сопрограммы она должна содержать как минимум одну функцию остановки, и функция эта обычно анонимная (лямбда-функция остановки). Давайте взглянем, для примера, на упрощённую функцию async() (из библиотеки kotlinx.coroutines):

```kt
fun <T> async(block: suspend () -> T)
```

Здесь async() является обычной функцией (не функцией остановки), но параметр block имеет функциональный тип с модификатором suspend: *suspend () -> T*. Таким образом, когда мы передаём лямбда-функцию в async(), она является анонимной функцией остановки, и мы можем вызывать функцию остановки изнутри её:

```kt
async {
    doSomething(foo)
    ...
}
```

Продолжая аналогию, await() может быть функцией остановки (также может вызываться из блока async {}), которая приостанавливает сопрограмму до тех пор, пока некоторые вычисления не будут выполнены, и затем возвращает их результат:

```kt
async {
    ...
    val result = computation.await()
    ...
}
```

Отметим, что функции приостановки await() и doSomething() не могут быть вызваны из обыкновенных функций, подобных main():

```kt
fun main(args: Array<String>) {
    doSomething() // ERROR: Suspending function called from a non-coroutine context 
}
```

Заметим, что функции остановки могут быть виртуальными, и при их переопределении модификатор suspend также должен быть указан:

```kt
interface Base {
    suspend fun foo()
}

class Derived: Base {
    override suspend fun foo() { ... }
}
```


[содержание](/readme.md)
