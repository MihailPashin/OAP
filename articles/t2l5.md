&nbsp; | &nbsp; | &nbsp; 
:-:|:-:|:-:
[Управляющие операторы языка](../articles/t2l4.md) | [На главную](../readme.md) | [Структуры данных. Массивы.](../articles/t2l6.md)

# Операторы организации циклической обработки. Циклы.

Циклы являются такой же важной частью структурного программирования, как условные операторы. С помощью циклов можно организовать повторение выполнения участков кода. 

## Цикл while

"While" переводится с английского как "пока", в смысле "пока имеем это, делаем то".

Можно сказать, while является универсальным циклом. Он присутствует во всех языках, поддерживающих структурное программирование, в том числе в Python. Его синтаксис выглядит так:

```py
while логическое_выражение:
     блок_кода
```

Он похож на условный оператор if. Однако в случае циклических операторов их тела могут выполняться не один раз. В случае if, если логическое выражение в заголовке возвращает истину, то тело выполняется единожды. После этого поток выполнения программы возвращается в основную ветку и выполняет следующие выражения, расположенные ниже всей конструкции условного оператора.

В случае while, после того как его тело выполнено, поток возвращается к заголовку цикла и снова проверяет условие. Если логическое выражение возвращает истину, то тело снова выполняется. Потом снова возвращаемся к заголовку и так далее.

Цикл завершает свою работу тогда, когда логическое выражение в заголовке возвращает ложь, то есть условие выполнения цикла больше не соблюдается. После этого поток выполнения перемещается к выражениям, расположенным ниже всего цикла. Говорят, "происходит выход из цикла".

С циклом while возможны две исключительные ситуации:

* Если при первом заходе в цикл логическое выражение возвращает False, то тело цикла не выполняется ни разу. Эту ситуацию можно считать нормальной, так как при определенных условиях логика программы может предполагать отсутствие необходимости в выполнении выражений тела цикла.

* Если логическое выражение в заголовке while никогда не возвращает False, а всегда остается равным True, то цикл никогда не завершится, если только в его теле нет оператора принудительного выхода из цикла (break) или вызовов функций выхода из программы – quit(), exit() в случае Python. Если цикл повторяется и повторяется бесконечное количество раз, то в программе происходит **зацикливание**. В это время она зависает и самостоятельно завершиться не может.

Рассмотрим следующий пример:

```py
total = 100
 
i = 0
while i < 5:
    n = int(input())
    total = total - n
    i = i + 1
 
print("Осталось", total)
```

Сколько раз "прокрутится" цикл в этой программе, т. е. сколько итераций он сделает? Ответ: 5.

* Сначала переменная i равна 0. В заголовке цикла проверяется условие i < 5, и оно истинно. Тело цикла выполняется. В нем меняется значение i, путем добавления к нему единицы.

* Теперь переменная i равна 1. Это меньше пяти, и тело цикла выполняется второй раз. В нем i меняется, ее новое значение 2.

* Два меньше пяти. Тело цикла выполняется третий раз. Значение i становится равным трем.

* Три меньше пяти. На этой итерации i присваивается 4.

* Четыре по прежнему меньше пяти. К i добавляется единица, и теперь ее значение равно пяти.

Далее начинается шестая итерация цикла. Происходит проверка условия i < 5. Но поскольку теперь оно возвращает ложь, то выполнение цикла прерывается, и его тело не выполняется.

"Смысловая нагрузка" данного цикла – это последовательное вычитание из переменной total вводимых чисел. Переменная i в данном случае играет только роль счетчика итераций цикла. В других языках программирования для таких случаев предусмотрен цикл for, который так и называется: "цикл со счетчиком". Его преимущество заключается в том, что в теле цикла не надо изменять переменную-счетчик, ее значение меняется автоматически в заголовке for.

В языке Python тоже есть цикл for. Но это не цикл со счетчиком. В Питоне он предназначен для перебора элементов последовательностей и других сложных объектов. 

Для while наличие счетчика не обязательно. Представим, что надо вводить числа, пока переменная total больше нуля. Тогда код будет выглядеть так:

```py
total = 100
 
while total > 0:
    n = int(input())
    total = total - n
 
print("Ресурс исчерпан")
```

Сколько раз здесь выполнится цикл? Неизвестно, все зависит от вводимых значений. Поэтому у цикла со счетчиком известно количество итераций, а у цикла без счетчика – нет.

Самое главное для цикла while – чтобы в его теле происходили изменения значений переменных, которые проверяются в его заголовке, и чтобы хоть когда-нибудь наступил случай, когда логическое выражение в заголовке возвращает False. Иначе произойдет зацикливание.

## Цикл for

Цикл for в языке программирования Python предназначен для перебора элементов структур данных и некоторых других объектов. Это не цикл со счетчиком, каковым является for во многих других языках.

Что значит перебор элементов? Например, у нас есть список, состоящий из ряда элементов. Сначала берем из него первый элемент, затем второй, потом третий и так далее. С каждым элементом мы выполняем одни и те же действия в теле for. Нам не надо извлекать элементы по их индексам и заботится, на каком из них список заканчивается, и следующая итерация бессмысленна. Цикл for сам переберет и определит конец.

```py
spisok = [10, 40, 20, 30]
for element in spisok:
     print(element + 2)
```

После ключевого слова for используется переменная под именем element. Имя здесь может быть любым. Нередко используют i. На каждой итерации цикла for ей будет присвоен очередной элемент из списка spisok. Так при первой прокрутке цикла идентификатор element связан с числом 10, на второй – с числом 40, и так далее. Когда элементы в spisok заканчиваются, цикл for завершает свою работу.

В примере выше не шла речь о перезаписи его элементов, они просто извлекались и использовались. Однако бывает необходимо изменить сам список, например, изменить значение каждого элемента в нем или только определенных, удовлетворяющих определенному условию. И тут без переменной, обозначающей индекс элемента, в большинстве случаев не обойтись:

```py
i = 0
for element in spisok:
     spisok[i] = element + 2
     i += 1
```

Но если мы вынуждены использовать счетчик, то выгода от использования цикла for не очевидна. Если знать длину списка, то почему бы не воспользоваться while. Длину можно измерить с помощью встроенной в Python функции len().

```py
i = 0
while i < len(spisok):
     spisok[i] = spisok[i] + 2
     i = i + 1
```

Кроме того, с циклом while мы избавились от переменной element.

## Функция range()

Теперь пришло время познакомиться со встроенной в Python функцией range(). "Range" переводится как "диапазон". Она может принимать один, два или три аргумента. Если задан только один, то генерируются числа от 0 до указанного числа, не включая его. Если заданы два, то числа генерируются от первого до второго, не включая его. Если заданы три, то третье число – это шаг.

Функция генерирует последовательность чисел в указанном диапазоне. Так, range(5, 11) сгенерирует последовательность 5, 6, 7, 8, 9, 10. Однако это будет не структура данных типа "список". Функция range() производит объекты своего класса – диапазоны.

## Цикл for и range()

Итак, зачем нам понадобилась функций range() в теме про цикл for? Дело в том, что вместе они образуют неплохой тандем. For как цикл перебора элементов, в отличие от while, позволяет не следить за тем, достигнут ли конец структуры. Не надо вводить счетчик для этого, изменять его и проверять условие в заголовке. С другой стороны, range() дает последовательность целых чисел, которые можно использовать как индексы для элементов того же списка.


```py
range(len(spisok))
```

Здесь с помощью функции len() измеряется длина списка. В данном случае она равна четырем. После этого число 4 передается в функцию range(), и она генерирует последовательность чисел от 0 до 3 включительно. Это как раз индексы элементов нашего списка.

Теперь "соединим" for и range():

```py
for i in range(len(spisok)):
     spisok[i] += 2
```

В заголовке цикла for берутся элементы вовсе не списка, а объекта range. Список, элементы которого планируется перезаписывать, тут по-сути не фигурирует. Если заранее знать длину списка, то заголовок может выглядеть так: *for i in range(4)*. То, как используется i в теле цикла, вопрос второй. 

>Примечание. Вместо идентификатора i может быть любой другой.

## Функция enumerate()

В Python есть еще одна встроенная функция, которая часто используется в заголовке for. Это функция enumerate(). Если range() позволяет получить только индексы элементов списка, то enumerate() генерирует пары кортежей, состоящих из индекса элемента и значения элемента.

```py
spisok = [16, 46, 26, 36]
for i in enumerate(spisok):
     print(i)
```

выведет:

```
(0, 16)
(1, 46)
(2, 26)
(3, 36)
```

Эти кортежи можно распаковывать, то есть извлекать индекс и значение, в теле цикла:

```py
for item in enumerate(spisok):
     print(item[0], item[1])
```

Однако чаще это делают еще в заголовке for, используя две переменные перед in:

```py
for id, val in enumerate(spisok):
     print(id, val)
```

&nbsp; | &nbsp; | &nbsp; 
:-:|:-:|:-:
[Управляющие операторы языка](../articles/t2l4.md) | [На главную](../readme.md) | [Структуры данных. Массивы.](../articles/t2l6.md)
