# Ввод и вывод данных. Функции и их параметры. 

## Вывод на экран. Функция println и строковые шаблоны

Здесь мы подходим к такой важной части программирования, как взаимодействие с пользователем и вообще с внешним для программы миром. Обратите внимание — в этот момент используемые нами функции начинают отличаться от чисто математических, так как у них появляются побочные эффекты (side effects). Функция в программировании в общем случае не сводится только к зависимости между параметрами и результатом.

Функция println(p) определена в стандартной библиотеке языка Котлин и не требует подключения каких-либо пакетов. Её параметр p может иметь любой тип — так, вызов println(x1) выведет на отдельную строку консоли значение переменной x1. Чаще всего, однако, p является строкой, например, "x1 = $x1 x2 = $x2". В данной строке присутствуют строковые шаблоны $x1 и $x2, состоящие из символа $ и имени переменной (параметра). Вместо них программа автоматически подставит значение соответствующих переменных. Строковый шаблон позволяет также подставить значение сложного выражения, как, например, здесь: "x1 * x2 = ${x1 * x2}". В этом случае выражение записывается в фигурных скобках, чтобы программа имела возможность отследить его начало и конец.

Осталось определить — что же такое консоль? В привычной нам операционной системе Windows консоль — это окно или же его часть, которую программа использует для вывода текстовой информации. В Intellij IDEA данное окно можно открыть последовательностью команд View → Tool windows → Run. При запуске программы из операционной системы она сама откроет так называемое «окно терминала», которое будет использоваться программой для вывода текстовой информации.

## Ввод с клавиатуры

Для ввода информации с консоли в Котлине применяется функция readLine(), считывающая одну строку с консоли. Строка заканчивается, когда пользователь нажимает клавишу Enter. Функция не имеет параметров, а результат её имеет тип String?. Знак вопроса после названия типа означает, что, помимо строки, результатом функции может быть также специальная константа null. Смысл этой константы в большинстве случаев — "некорректный результат", фактически это ещё один (в дополнении к исключениям) способ поведения в ошибочных ситуациях. Более точный смысл null — некорректная ссылка, не ссылающаяся никуда.

readLine() использует результат null, когда ввод строки по какой-либо причине завершился неудачно. Это может произойти при достижении особого символа "конец файла", который в нормальной ситуации не встречается при вводе в консоли. Операционная система, однако, имеет возможность перенаправления консольного входа программы таким образом, чтобы вместо ввода информации пользователем с клавиатуры программа читала информацию из файла. В случае использования такого перенаправления действительно возможно достижение конца файла.

Пример использования readLine():

```kt
fun main(args: Array<String>) {
    println("Введите время в формате ЧЧ:ММ:СС")
    val line = readLine()
    if (line != null) {
        //что-то делаем
    }
    else {
        println("Достигнут <конец файла> в процессе чтения строки. Программа прервана")
    }
```

## Функции и их параметры

Одним из строительных блоков программы являются функции. Функция определяет некоторое действие. В Kotlin функция объявляется с помощью ключевого слова fun, после которого идет название функции. Затем после названия в скобках указывается список параметров. Если функция возвращает какое-либо значение, то после списка параметров через запятую можно указать тип возвращаемого значения. И далее в фигурных скобках идет тело функции.

```
fun имя_функции (параметры) : возвращаемый_тип{
    выполняемые инструкции
}
```

Параметры необязательны.

Например, определим и вызовем функцию, которая просто выводит некоторую строку на консоль:

```kt
fun main(args: Array<String>) {
    hello() // вызов функции hello
    hello() // вызов функции hello
    hello() // вызов функции hello
}

// определение функции hello
fun hello(){
    println("Hello")
}
```

Функции можно определять в файле вне других функций или классов, сами по себе, как например, определяется функция main. Такие функции еще называют функциями верхнего уровня (top-level functions).

Здесь кроме главной функции main также определена функция hello, которая не принимает никаких параметров и ничего не возвращает. Она просто выводит строку на консоль.

Функция hello (и любая другая определенная функция, кроме main) сама по себе не выполняется. Чтобы ее выполнить, ее надо вызвать. Для вызова функции указывается ее имя (в данном случае "hello"), после которого идут пустые скобки.

Таким образом, если необходимо в разных частях программы выполнить одни и те же действия, то можно эти действия вынести в функцию, и затем вызывать эту функцию.

### Предача параметров

Через параметры функция может получать некоторые значения извне. Параметры указываются после имени функции в скобках через запятую в формате имя_параметра : тип_параметра. Например, определим функцию, которая вычисляет факториал числа:

```kt
fun main(args: Array<String>) {
    factorial(4)
    factorial(5)
    factorial(6)
}
 
fun factorial(n: Int){
 
    var result = 1;
    for(d in 1..n){
        result *= d
    }
    println("Factorial of $n is equal to $result")
}
```

Функция factorial принимает один параметр типа Int. Поэтому при вызове функции в скобках необходимо передать значение для этого параметра: factorial(4). Причем это значение должно представлять тип Int. Значения, которые передаются параметрам функции, еще назвают аргументами.

Консольный вывод программы:

```
Factorial of 4 is equal to 24
Factorial of 5 is equal to 120
Factorial of 6 is equal to 720
```

Другой пример - функция, которая выводит данные о пользователе на консоль:

```kt
fun main(args: Array<String>) {
    displayUser("Tom", 23)
    displayUser("Alice", 19)
    displayUser("Kate", 25)
}

fun displayUser(name: String, age: Int){
    println("Name: $name   Age: $age")
}
```

Функция displayUser() принимает два параметра - name и age. При вызове функции в скобках ей передаются значения для этих параметров. При этом значения передаются параметрам по позиции и должны соответствовать параметрам по типу. Так как вначале идет параметр типа String, а потом параметр типа Int, то при вызове функции в скобках вначале передается строка, а потом число.

### Аргументы по умолчанию

В примере выше при вызове функций factorial и displayUser мы обязательно должны предоставить для каждого их параметра какое-то определенное значение, которое соответствует типу параметра. Мы не можем, к примеру, вызвать функцию displayUser, не передав ей аргументы для параметров, это будет ошибка.

Однако мы можем определить какие-то параметры функции как необязательные и установить для них значения по умолчанию:

```kt
fun displayUser(name: String, age: Int = 18, position: String="unemployed"){
    println("Name: $name   Age: $age  Position: $position")
}
 
fun main(args: Array<String>) {
    displayUser("Tom", 23, "Manager")
    displayUser("Alice", 21)
    displayUser("Kate")
}
```

В данном случае функция displayUser имеет три параметра для передачи имени, возраста и должности. Для первого параметр name значение по умолчанию не установлено, поэтому для него по-прежнему обязательно передавать значение. Два последующих - age и position являются необязательными, и для них установлено значение по умолчанию. Если для этих параметров не передаются значения, тогда параметры используют значения по умолчанию. Поэтому для этих параметров в принципе нам необязательно передавать аргументы. Но если для какого-то параметра определено значение по умолчанию, то для всех последующих параметров тоже должно быть установлено значение по умолчанию.

Консольный вывод программы

```
Name: Tom   Age: 23  Position: Manager
Name: Alice   Age: 21  Position: unemployed
Name: Kate   Age: 18  Position: unemployed
```

### Именованные аргументы

По умолчанию значения передаются параметрам по позиции: первое значение - первому параметру, второе значение - второму параметру и так далее. Однако, используя именованные аргументы, мы можем переопределить порядок их передачи параметрам:

```kt
fun main(args: Array<String>) {
    displayUser(name="Tom", position="Manager", age=28)
    displayUser(age=21, name="Alice")
    displayUser("Kate", position="Middle Developer")
}
```

При вызове функции в скобках мы можем указать название параметра и с помощью знака равно передать ему нужное значение.

При этом, как видно из последнего случае, необязательно все аргументы передавать по имени. Часть аргументов могут передаваться параметрам по позиции. Но если какой-то аргумент передан по имени, то остальные также должны передаваться по имени соответствующих параметров.

### Переменное количество параметров. Vararg

Функция может принимать переменное количество параметров одного типа. Для определения таких параметров применяется ключевое слово vararg. Например, нам необходимо передать в функцию несколько строк, но сколько именно строк, мы точно не знаем. Их может быть пять, шесть, семь и т.д.:

```kt
fun printStrings(vararg strings: String){
    for(str in strings)
        println(str)
}

fun main(args: Array<String>) {
    printStrings("Tom", "Bob", "Sam")
    printStrings("Kotlin", "JavaScript", "Java", "C#", "C++")
}
```

Функция printStrings принимает неопределенное количество строк. В самой функции мы можем работать с параметром как с последовательностью строк, например, перебирать элементы последовательности в цикле и производить с ними некоторые действия.

При вызове функции мы можем ей передать любое количество строк.

Другой пример - подсчет суммы неопределенного количества чисел:

```kt
fun sum(vararg numbers: Int){
    var result=0
    for(n in numbers)
        result += n
    println("Сумма чисел равна $result")
}

fun main(args: Array<String>) {
 
    sum(1, 2, 3, 4, 5)
    sum(1, 2, 3, 4, 5, 6, 7, 8, 9)
}
```

Если функция принимает несколько параметров, то обычно vararg-параметр является последним.

```kt
fun printUserGroup(count:Int, vararg users: String){
    println("Count: $count")
    for(user in users)
        println(user)
}
 
fun main(args: Array<String>) {
 
    printUserGroup(3, "Tom", "Bob", "Alice")
}
```

Однако это необязательно, и если после vararg-параметра идут еще какие-нибудь параметры, то при вызове функции значения этим параметрам передаются через именованные аргументы:

```kt
fun printUserGroup(group: String, vararg users: String, count:Int){
    println("Group: $group")
    println("Count: $count")
    for(user in users)
        println(user)
}
fun main(args: Array<String>) {
 
    printUserGroup("KT-091", "Tom", "Bob", "Alice", count=3)
}
```

Здесь функция printUserGroup принимает три параметра. Значения параметрам до vararg-параметра передаются по позициям. То есть в данном случае "KT-091" будет представлять значение для параметра group. Последующие значения интерпретируются как значения для vararg-параметра вплоть до именнованных аргументов.

### Оператор *

Оператор * (spread operator) (не стоит путать со знаком умножения) позволяет передать параметру в качестве значения элементы из массива:

```kt
fun printUserGroup(group: String, vararg users: String, count:Int){
    println("Count: $count")
    for(user in users)
        println(user)
}

fun main(args: Array<String>) {
    val users = arrayOf("Tom", "Bob", "Alice")
    printUserGroup("MO-011", *users, count=3)
}
```

Обратите внимание на звездочку перед users при вызове функции: printUserGroup("MO-011", *users, count=3). Без применения данного оператора мы столкнулись бы с ошибкой, поскольку параметры функции представляют не массив, а неопределенное количество строк.

### Возвращение результата. Оператор return

Функция может возвращать некоторый результат. В этом случае после списка параметров через двоеточие указывается возвращаемый тип. А в теле функции применяется оператор return, после которого указывается возвращаемое значение.

Например, определим функцию, которая возвращает факториал числа:

```kt
fun factorial(n: Int) : Int{ // функция возвращает значение типа Int
    var result = 1;
    for(d in 1..n){
        result *= d
    }
    return result       //  возвращение значения
}
 
fun main(args: Array<String>) {
 
    val a = factorial(4)
    val b = factorial(5)
    val c = factorial(6)
    println("a=$a  b=$b  c=$c")
}
```

В объявлении функции factorial после списка параметров через двоеточие указывается тип Int, который будет представлять тип возвращаемого значения.

Так как функция возвращает значение, то при ее вызове это значение можно присвоить переменной:

```kt
val a = factorial(4)
```

### Тип Unit

Если функция не возвращает какого-либо результата, то фактически неявно она возвращает значение типа Unit. Этот тип аналогичен типу void в ряде языков программирования, которое указывает, что функция ничего не возвращает. Например, следующая функция

```kt
fun hello(){
    println("Hello")
}
```

будет аналогична следующей:

```kt
fun hello() : Unit{
    println("Hello")
}
```

Формально мы даже можем присвоить результат такой функции переменной:

```kt
val d = hello()
val e = hello()
```

Однако практического смысла это не имеет, так как возвращаемое значение представляет объект Unit, который больше никак не применяется.

Если функция возвращает значение Unit, мы также можем использовать оператор return для возврата из функции:

```kt
fun factorial(n: Int){
    if(n < 1){
        println("Incorrect input parameter")
        return
    }
    var result = 1;
    for(d in 1..n){
        result *= d
    }
    println("Factorial of $n is equal $result")
}
```

В данном случае если значение параметра n меньше 1, то с помощью оператора return осуществляется выход из функции, и последующие инструкции не выполняются. При этом если функция возвращает значение Unit, то после оператора return можно не указывать никакого значения.

### Однострочные функции

Однострочные функции (single expression function) используют сокращенный синтаксис определения функции в виде одного выражения. Эта форма позволяет опустить возвращаемый тип и оператор return.

```
fun имя_функции (параметры_функции) = тело_функции
```

Функция также определяется с помощью ключевого слова fun, после которого идет имя функции и список параметров. Но после списка параметров не указывается возвращаемый тип. Возвращаемый тип будет выводится компилятором. Далее через оператор присвоения = определяется тело функции в виде одного выражения.

Например, функция возведения числа в квадрат:

```kt
fun double(x: Int) = x * x

fun main(args: Array<String>) {
 
    val a = double(5)   // 25
    val b = double(6)   // 36
    println("a=$a  b=$b")
}
```

В данном случае функция double возводит число в квадрат. Она состоит из одного выражения x * x. Значение этого выражения и будет возвращаться функцией. При этом оператор return не используется.

Такие функции более лаконичны, более читабельны, но также опционально можно и указывать возвращаемый тип явно:

```kt
fun double(x: Int) : Int = x * x
```

### Область действия функций

В Kotlin функции могут быть объявлены в самом начале файла. Подразумевается, что вам не обязательно создавать объект какого-либо класса, чтобы воспользоваться его функцией (как в Java, C# или Scala). В дополнение к этому, функции в языке Kotlin могут быть объявлены локально, как функции-члены (ориг. "member functions") и функции-расширения ("extension functions").

### Локальные функции

Одни функции могут быть определены внутри других функций. Внутренние или вложенные функции еще называют локальными.

Локальные функции могут определять действия, которые используются только в рамках какой-то конкретной функции и нигде больше не применяются.

Например, функция принимает на вход основание и высоту двух треугольников и должна вычислить, больше ли площадь первого треугольника, чем второго:

```kt
fun isFirstGreater(base1: Double, height1: Double, base2: Double, height2: Double): Boolean{
 
    fun square(base: Double, height: Double) = base * height / 2
     
    return square(base1, height1) > square(base2, height2)
}

fun main(args: Array<String>) {
    val a = isFirstGreater(10.0, 10.0, 20.0, 20.0)
    val b = isFirstGreater(20.0, 20.0, 10.0, 10.0)
    println("a=$a  b=$b")
}
```

Для промежуточных вычислений - вычисления площади каждого отдельного треугольника в функции isFirstGreater определена вспомогательная функция square. Больше в программе эта функция нигде не используется, поэтому ее можно сделать локальной.

При этом локальная может использоваться только в той функции, где она определена.

### Перегрузка функций

Перегрузка функций (function overloading) представляет определение нескольких функций с одним и тем же именем, но с различными параметрами. Параметры перегруженных функций могут отличаться по количеству, типу или по порядку в списке параметров.

```kt
fun add(a: Int, b: Int) : Int{
    return a + b
}
fun add(a: Double, b: Double) : Double{
    return a + b
}
fun add(a: Int, b: Int, c: Int) : Int{
    return a + b + c
}
fun add(a: Int, b: Double) : Double{
    return a + b
}
fun add(a: Double, b: Int) : Double{
    return a + b
}
```

В данном случае для одной функции add определено пять перегруженных версий. Каждая из версий отличается либо по типу, либо количеству, либо по порядку параметров. При вызове функции add компилятор в зависимости от типа и количества параметров сможет выбрать для выполнения нужную версию:

```kt
fun main(args: Array<String>) {
 
    val a = add(1, 2)
    val b = add(1.5, 2.5)
    val c = add(1, 2, 3)
    val d = add(2, 1.5)
    val e = add(1.5, 2)
}
```

При этом при перегрузке не учитывает возвращаемый результат функции. Например, пусть у нас будут две следующие версии функции add:

```kt
fun add(a: Double, b: Int) : Double{
    return a + b
}
fun add(a: Double, b: Int) : String{
    return "$a + $b"
}
```

Они совпадают во всем за исключением возвращаемого типа. Однако в данном случае мы сталкивамся с ошибкой, так как перегруженные версии должны отличаться именно по типу, порядку или количеству параметров. Отличие в возвращаемом типе не имеют значения.

### Лямбда-выражения

Лямбда-выражения представляют небольшие кусочки кода, которые выполняют некоторые действия. Фактически лямбды преставляют сокращенную запись функций. При этом лямбды могут передаваться в качестве параметра в функции.

Лямбда-выражения оборачиваются в фигурные скобки:

```kt
{println("hello")}
```

В данном случае лямбда-выражение выводит на консоль строку "hello".

Лямбда-выражение можно сохранить в обычную переменную и затем вызывать через имя этой переменной как обычную функцию.

```kt
fun main(args: Array<String>) {
 
    val hello = {println("hello")}
    hello()
    hello()
}
```

В данном случае лямбда сохранена в переменную hello и через эту переменную вызывается два раза.

Также лямбда-выражение можно выполнить сразу при определении с помощью оператора run:

```kt
fun main(args: Array<String>) {
 
    run {println("hello")}
}
```

### Передача параметров

Лямбды как и функции могут принимать параметры. Для передачи параметров используется стрелка ->. Параметры указываются слева от стрелки, а тело лямбда-выражения, то есть сами выполняемые действия, справа от стрелки.

```kt
fun main(args: Array<String>) {
 
    val printer = {message: String -> println(message)}
    printer("Hello")
    printer("Good Bye")
}
```

Здесь лямбда-выражение принимает один параметр типа String, значение которого выводится на консоль.

Если параметров несколько, то они передаются слева от стрелки через запятую:

```kt
fun main(args: Array<String>) {
 
    val sum = {x:Int, y:Int -> println(x + y)}
    sum(2, 3)   // 5
    sum(4, 5)   // 9
}
```

Если в лямбда-выражении надо выполнить не одно, а несколько действий, то эти действия можно размещать на отдельных строках после стрелки:

```kt
val sum = {x:Int, y:Int ->
    val result = x + y
    println("$x + $y = $result")
}
```

### Возвращение результата

Выражение, стоящее после стрелки, определяет результат лямбда-выражения. И этот результат мы можем присвоить, например, переменной.

Если лямбда-выражение формально не возвращает никакого результата, то фактически, как и в функциях, возвращается значение типа Unit:

```kt
val hello = { println("Hello")}
val h = hello()             // h представляет тип Unit
 
val printer = {message: String -> println(message)}
val p = printer("Welcome")    // p представляет тип Unit
```

В обоих случаях используется функция println, которая формально не возвращает никакого значения (точнее возвращает объект типа Unit).

Но также может возвращаться конкретное значение:

```kt
fun main(args: Array<String>) {
 
    val sum = {x:Int, y:Int -> x + y}
     
    val a = sum(2, 3)   // 5
    val b = sum(4, 5)   // 9
    println("a=$a  b=$b")
}
```

Здесь выражение справа от стрелки x + y продуцирует новое значение - сумму чисел, и при вызове лямбда-выражения это значение можно передать переменной.

Если лямбда-выражение многострочное, состоит из нескольких инструкций, то возвращается то значение, которое генерируется последней инструкцией:

```kt
val sum = {x:Int, y:Int ->
    val result = x + y
    println("$x + $y = $result")
    result
}
```

Последнее выражение по сути представляет число - сумму чисел x и y и оно будет возвращаться в качестве результата лямбда-выражения.

### Функции высокого порядка

Функции высокого порядка (high order function) - это функции, которые либо принимают функцию в качестве параметра, либо возвращают функцию, либо и то, и другое.

### Тип функции

Для определения функций высокого порядка прежде всего необходимо представлять, что такое тип функции. Тип функции определяется следующим образом:

```
(типы_параметров) -> возвращаемый_тип
```

Например, возьмем следующее лямбда-выражение:

```
{mes:String-> println(mes)}
```

Это лямбда-выражение принимает в качестве параметра строку и формально ничего не возвращает (точнее возвращаемым типом является Unit). Поэтому тип этого выражения будет следующий:

```
(String)-> Unit
```

Другой пример: лямбда-выражение принимает два числа и возвращает их сумму:

```
x: Int, y: Int -> x+y
```

Это выражение будет иметь следующий тип:

```
(Int, Int) -> Int
```

Если лямбда-выражение не принимает никаких параметров, то указываются пустые скобки:

```
() -> Unit
```

К примеру, этому типу будет соответствовать лямбда-выражение {println("hello")}

При определении лямбда-выражения и присвоении его переменной мы можем явным образом у этой переменной указать тип:

```kt
val sum: (Int, Int)-> Int = {x:Int, y: Int -> x+y}
val printer: (String) -> Unit = {message: String -> println(message)}
```

Правда, в данном случае тип можно не указывать, так как компилятор может сам вывести тип переменной.

### Передача лямбда-выражения в функцию

Для передачи лямбда-выражения в функцию, необходимо определить у функции параметр, тип которого соответствует типу лямбда-выражения:

```kt
fun main(args: Array<String>) {
 
    val add = {x:Int, y: Int -> x+y}
    val multiply = {x:Int, y: Int -> x*y}
 
    action(5, 3, add)
    action(5, 3, multiply)
    action(5, 3, {x: Int, y: Int -> x -y})
}
 
fun action (n1: Int, n2: Int, operation: (Int, Int)-> Int){
    val result = operation(n1, n2)
    println(result)
}
```

В данном случае функция action определяет три параметра. Первый два параметра - числа, а третий параметр - некоторая операция, которая производится над этими числами. На момент определения функции можно не знать, что это будет за операция. Это может быть любое лямбда-выражение, которое принимает два объекта типа Int и возвращает также объект типа Int.

В самой функции action вызываем эту операцию, передавая ей два числа, и полученный результат выводим на консоль.

При вызове функции action мы можем передать для ее третьего параметра лямбда-выражение, которое соответствует этому параметру по типу:

```kt
action(5, 3, add)
action(5, 3, multiply)
action(5, 3, {x: Int, y: Int -> x -y})
```

### Возвращение функции из функции

В более редких случаях может потребоваться возвратить функцию из другой функции. В этом случае для функции в качестве возвращаемого типа устанавливается тип другой функции. А в теле функции возвращается лямбда выражение. Например:

```kt
fun selectAction(key: Int): (Int, Int) -> Int{
    // определение возвращаемого результата
    when(key){
        1 -> return {x:Int, y: Int -> x + y}
        2 -> return {x:Int, y: Int -> x - y}
        3 -> return {x:Int, y: Int -> x * y}
        else -> return  {x:Int, y: Int -> 0}
    }
}
```

Здесь функция selectAction принимает один параметр - key, который представляет тип Int. В качестве возвращаемого типа у функции указан тип (Int, Int) -> Int. То есть selectAction будет возвращать некую функцию, которая принимает два параметра типа Int и возвращает объект типа Int.

В теле функции selectAction в зависимости от значения параметра key возвращается определенное лямбда-выражение, которое соответствует типу (Int, Int) -> Int.

Используем данную функцию:

```kt
fun main(args: Array<String>) {
 
    var action = selectAction(1)
    println(action(8,5))    // 13
 
    action = selectAction(2)
    println(action(8,5))    // 3
 
}
fun selectAction(key: Int): (Int, Int) -> Int{
    // определение возвращаемого результата
    when(key){
        1 -> return {x:Int, y: Int -> x + y}
        2 -> return {x:Int, y: Int -> x - y}
        3 -> return {x:Int, y: Int -> x * y}
        else -> return  {x:Int, y: Int -> 0}
    }
}
```

Здесь переменная action хранит результат функции selectAction. Так как selectAction возвращает лямбда-выражение, то и переменная action будет хранить определенное лямбда-выражение. Затем через переменную action можно вызвать это лямбда-выражение. Поскольку лямбда-выражение соответствует типу (Int, Int) -> Int, то при его вызове ему необходимо передать два числа и соответственно мы можем получить его результат и вывести его на консоль.

### Анонимные функции

Анонимные функции выглядят как обычные за тем исключением, что они не имеют имени. Анонимная функция может иметь одно выражение:

```kt
fun(x: Int, y: Int): Int = x + y
```

Либо может представлять блок кода:

```kt
fun(x: Int, y: Int): Int{ 
    return x + y
}
```

Анонимные функции используется только в качестве аргументов в других функциях. Например:

```kt
fun main(args: Array<String>) {
 
    operation(9, 5, fun(x: Int, y: Int): Int { return x + y })   // 14
    operation(9, 5, fun(x: Int, y: Int): Int = x - y)            // 4
}
fun operation(x: Int, y: Int, op: (Int, Int) ->Int){
 
    val result = op(x, y)
    println(result)
}
```

Функция operation принимает три параметра. Первые два параметра - числа, а третий параметр - функция, которая выполняет некоторые действия над этими числами.

При вызове функции operation для третьего параметра в качестве аргумента передается анонимная функция, которая соответствует этому параметру по типу: (Int, Int) ->Int. То есть анонимная функция должна принимать два парамтра типа Int и возвращать значение типа Int.

Передача анонимной функции в данном случае аналогична передачи лямбда-выражения, в то же время лямбда-выражения представляют более лаконичный синтаксис, поэтому, как правило, в этой роли применяются лямбда-выражения.

### Инфиксная запись

Функции так же могут быть вызваны при помощи инфиксной записи, при условии, что:

* Они являются членом другой функции или расширения
* В них используется один параметр
* Когда они помечены ключевым словом infix

```kt
// Определяем выражение как Int
infix fun Int.shl(x: Int): Int {
...
}

// вызываем функцию, используя инфиксную запись

1 shl 2

// то же самое, что

1.shl(2)
```

## Параметры командной строки

При запуске программы 