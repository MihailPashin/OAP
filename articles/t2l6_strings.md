# Символьные типы данных. Символы и строки. Обработка символов. Обработка строк. Регулярные выражения.

Строки в Python - упорядоченные последовательности символов, используемые для хранения и представления текстовой информации, поэтому с помощью строк можно работать со всем, что может быть представлено в текстовой форме.

## Литералы строк

Работа со строками в Python очень удобна. Существует несколько литералов строк, которые мы сейчас и рассмотрим.

### Строки в апострофах и в кавычках

```py
S = 'spam"s'
S = "spam's"
```

Строки в апострофах и в кавычках - одно и то же. Причина наличия двух вариантов в том, чтобы позволить вставлять в литералы строк символы кавычек или апострофов, не используя экранирование.

### Экранированные последовательности - служебные символы

Экранированные последовательности позволяют вставить символы, которые сложно ввести с клавиатуры.

Экранированная последовательность | Назначение
:--:|---
\n | Перевод строки
\b | Забой
\f | Перевод страницы
\r | Возврат каретки
\t | Горизонтальная табуляция
\v | Вертикальная табуляция
\N{id} | Идентификатор ID базы данных Юникода
\uhhhh | 16-битовый символ Юникода в 16-ричном представлении
\Uhhhh… | 32-битовый символ Юникода в 32-ричном представлении
\xhh | 16-ричное значение символа
\ooo | 8-ричное значение символа
\0 | Символ Null (не является признаком конца строки)

### "Сырые" строки - подавляют экранирование

Если перед открывающей кавычкой стоит символ 'r' (в любом регистре), то механизм экранирования отключается.

```py
S = r'C:\newt.txt'
```

Но, несмотря на назначение, "сырая" строка не может заканчиваться символом обратного слэша. Пути решения:

```py
S = r'\n\n\\'[:-1]
S = r'\n\n' + '\\'
S = '\\n\\n'
```

### Строки в тройных апострофах или кавычках

Главное достоинство строк в тройных кавычках в том, что их можно использовать для записи многострочных блоков текста. Внутри такой строки возможно присутствие кавычек и апострофов, главное, чтобы не было трех кавычек подряд.

```py
c = '''это очень большая
строка, многострочный
блок текста'''
```

## Функции и методы строк

### Базовые операции

* Конкатенация (сложение)

    ```py
    S1 = 'spam'
    S2 = 'eggs'
    print(S1 + S2)
    'spameggs'
    ```

* Дублирование строки (умножение)

    `*` — оператор создает несколько копий строки. Если s это строка, а n целое число, любое из следующих выражений возвращает строку, состоящую из n объединенных копий s:

    ```py
    s * n
    n * s
    ```

    ```py    
    print('spam' * 3)
    'spamspamspam'
    ```

    Значение множителя n должно быть целым положительным числом. Оно может быть нулем или отрицательным, но этом случае результатом будет пустая строка

* Оператор принадлежности подстроки: **in**

    Python предоставляет оператор принадлежности, который можно использоваться для манипуляций со строками. Оператор **in** возвращает *True*, если подстрока входит в строку, и *False*, если нет:

    ```py
    s = 'Python'
    s in 'I love Python.'
    True
    s in 'I love Java.'
    False
    ```

    Есть также оператор not in, у которого обратная логика:

    ```py
    'z' not in 'abc'
    True
    'z' not in 'xyz'
    False
    ```

### Встроенные функции строк в python    

Python предоставляет множество функций, которые встроены в интерпретатор. Вот несколько, которые работают со строками:

Функция | Описание
:--:|---
chr() | Преобразует целое число в символ
ord() | Преобразует символ в целое число
len() | Возвращает длину строки
str() | Изменяет тип объекта на string

Функция **ord(c)** возвращает числовое значение для заданного символа.

На базовом уровне компьютеры хранят всю информацию в виде цифр. Для представления символьных данных используется схема перевода, которая содержит каждый символ с его репрезентативным номером.

Самая простая схема в повседневном использовании называется *ASCII* . Она охватывает латинские символы, с которыми мы чаще работаем. Для этих символов ord(c) возвращает значение ASCII для символа c:

```py
ord('a')
97
ord('#')
35
```

ASCII прекрасен, но есть много других языков в мире, которые часто встречаются. Полный набор символов, которые потенциально могут быть представлены в коде, намного больше обычных латинских букв, цифр и символом.

*Unicode* — это современный стандарт, который пытается предоставить числовой код для всех возможных символов, на всех возможных языках, на каждой возможной платформе. Python 3 поддерживает Unicode, в том числе позволяет использовать символы Unicode в строках.

Функция ord() также возвращает числовые значения для символов Юникода:

```py
ord('€')
8364
ord('∑')
8721
```

Функция **chr(n)** возвращает символьное значение для данного целого числа.

chr() действует обратно ord(). Если задано числовое значение n, chr(n) возвращает строку, представляющую символ n:

```py
chr(97)
'a'
chr(35)
'#'
```

chr() также обрабатывает символы Юникода:

```py
chr(8364)
'€'
chr(8721)
'∑'
```

Функция **len(s)** возвращает длину строки.

len(s) возвращает количество символов в строке s:

```py
s = 'Простоя строка.'
len(s)
15
```

### Индексация строк

Часто в языках программирования, отдельные элементы в упорядоченном наборе данных могут быть доступны с помощью числового индекса или ключа. Этот процесс называется индексация.

В Python строки являются упорядоченными последовательностями символьных данных и могут быть проиндексированы. Доступ к отдельным символам в строке можно получить, указав имя строки, за которым следует число в квадратных скобках [].

Индексация строк начинается с нуля: у первого символа индекс 0, следующего 1 и так далее. Индекс последнего символа в python — ‘‘длина строки минус один’’.

Отдельные символы доступны по индексу следующим образом:

```py
s = 'foobar'

s[0]
'f'
s[1]
'o'
s[3]
'b'
s[5]
'r'
```

Попытка обращения по индексу большему чем len(s) - 1, приводит к ошибке IndexError:

```py
s[6]
Traceback (most recent call last):
  File "<pyshell#17>", line 1, in <module>
    s[6]
IndexError: string index out of range
```

Индексы строк также могут быть указаны отрицательными числами. В этом случае индексирование начинается с конца строки: -1 относится к последнему символу, -2 к предпоследнему и так далее. Вот такая же диаграмма, показывающая как положительные, так и отрицательные индексы строки 'foobar'.

Вот несколько примеров отрицательного индексирования:

```py
s = 'foobar'
s[-1]
'r'
s[-2]
'a'
len(s)
6
s[-len(s)] # отрицательная индексация начинается с -1
'f'
```

Попытка обращения по индексу меньшему чем -len(s), приводит к ошибке IndexError:

```py
s[-7]
Traceback (most recent call last):
  File "<pyshell#26>", line 1, in <module>
    s[-7]
IndexError: string index out of range
```

### Срезы строк

Python также допускает возможность извлечения подстроки из строки, известную как ‘‘string slice’’. Если s это строка, выражение формы s[m:n] возвращает часть s, начинающуюся с позиции m, и до позиции n, но не включая позицию:

```py
s = 'python'
s[2:5]
'tho'
```

>Помните: индексы строк в python начинаются с нуля. Первый символ в строке имеет индекс 0. Это относится и к срезу.

Опять же, второй индекс указывает символ, который не включен в результат. Символ 'n' в приведенном выше примере. Это может показаться немного не интуитивным, но дает результат: выражение s[m:n] вернет подстроку, которая является разницей n - m, в данном случае 5 - 2 = 3.

Если пропустить первый индекс, срез начинается с начала строки. Таким образом, s[:m] = s[0:m]:

```py
s = 'python'
s[:4]
'pyth'
s[0:4]
'pyth'
```

Аналогично, если опустить второй индекс s[n:], срез длится от первого индекса до конца строки. Это хорошая, лаконичная альтернатива более громоздкой s[n:len(s)]:

```py
s = 'python'
s[2:]
'thon'
s[2:len(s)]
'thon'
```

Для любой строки s и любого целого n числа (0 ≤ n ≤ len(s)), s[:n] + s[n:]будет s:

```py
s = 'python'
s[:4] + s[4:]
'python'
s[:4] + s[4:] == s
True
```

Пропуск обоих индексов возвращает исходную строку. Это не копия, это ссылка на исходную строку:

```py
s = 'python'
t = s[:]
id(s)
59598496
id(t)
59598496
s is t
True
```

Если первый индекс в срезе больше или равен второму индексу, Python возвращает пустую строку. Это еще один не очевидный способ сгенерировать пустую строку, если вы его искали:

```py
s[2:2]
''
s[4:2]
''
```

Отрицательные индексы можно использовать и со срезами. Вот пример кода Python:

```py
s = 'python'
s[-5:-2]
'yth'
s[1:4]
'yth'
s[-5:-2] == s[1:4]
True
```

### Форматирование строки

<!-- //todo -->

### Изменение строк

Строки — один из типов данных, которые Python считает неизменяемыми, что означает невозможность их изменять. Как вы ниже увидите, python дает возможность изменять (заменять и перезаписывать) строки.

Такой синтаксис приведет к ошибке TypeError:

```py
s = 'python'
s[3] = 't'
Traceback (most recent call last):
  File "<pyshell#40>", line 1, in <module>
    s[3] = 't'
TypeError: 'str' object does not support item assignment
```

На самом деле нет особой необходимости изменять строки. Обычно вы можете легко сгенерировать копию исходной строки с необходимыми изменениями. Есть минимум 2 способа сделать это в python. Вот первый:

```py
s = s[:3] + 't' + s[4:]
s
'pytton'
```

Есть встроенный метод string.replace(x, y):

```py
s = 'python'
s = s.replace('h', 't')
s
'pytton'
```

Читайте дальше о встроенных методах строк!

