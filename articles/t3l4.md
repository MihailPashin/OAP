[содержание](/readme.md)  

* Циклы
* Массивы
* Коллекции

# Циклы

## for

```
for(i in range)
for(i in array)
for(i in string)
```

Обычное использование с диапазонами и итерацию по строкам/массивам мы уже проходили, рассмотрим другие варианты:

## Обращение по индексу

Строки и массивы имеют методы:

* .indices - возвращает диапазон валидных индексов

```kt
//"test".indices // 0..3
for(c in "test".indices)
  println(c)
```
```
t
e
s
t  
```

* .withIndex() - позволяет при проходе по итерабельному объекту получать пару (индекс,элемент)

```kt
val cats = arrayListOf("Мурзик", "Васька", "Барсик")
for( (index, element) in cats.withIndex()){
    println("$index: $element")
}
```

Получим:

```
0: Мурзик
1: Васька
2: Барсик
```

## forEach

Проходит по всем элементам коллекции.

```kt
val daysOfWeek = listOf("Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday")
daysOfWeek.forEach{
    println(it)
}
```

## repeat()

Встроенная функция для повторения команд заданное число раз.

```kt
repeat(3){
    println("Васька! Иди жрать!")
}
```

# Массивы

Массив можно создать двумя способами - через конструктор Array() или через методы arrayOf(), arrayOfNulls(), emptyArray().

* arrayOf()

```kt
val myArray = arrayOf(1, 2, 3, 4, 5)
```

Узнать длину массива можно при помощи свойства *size*.

```kt
println(myArray.size) // 5
```

Элементами массива могут быть данные разных типов:

```kt
val myArray = arrayOf(1, 2, 3, 4, 5, "зайчик", "вышел", "погулять")
```

Если мы хотим строгого поведения и не хотим смешивать разные типы, то используем обобщения.

```kt
val myArray = arrayOf<Int>(1, 2, 3, 4, 5) // только числа Integer
```

Существует также синонимы метода, когда уже в имени содержится подсказка: intArrayOf(), charArrayOf(), booleanArrayOf(), longArrayOf(), shortArrayOf(), byteArrayOf().

Перепишем пример.

```kt
val myArray = intArrayOf(1, 2, 3, 4, 5)
```

* arrayOfNulls()

Для создания массива с заполненными значениями null можно использовать отдельную функцию arrayOfNulls().

Создадим массив с тремя элементами.

```
val array = arrayOfNulls(3) // [null, null, null]
```

* emptyArray()

Создает пустой массив

```
var arr = emptyArray<String>() // []
arr += "1"
arr += "2"
```

* Конструктор Array()

При использовании конструктора нужно указать размер массива в первом параметре и лямбда-выражение во втором.

```kt
val myArray = Array(5, { i -> i * 2 })
```

Мы задали пять элементов и каждый элемент в цикле умножаем на 2. В итоге получим массив чисел 0, 2, 4, 6, 8.

Создадим массив строк от "A" до "Z"

```kt
val letters = Array<String>(26) { i -> ('A' + i).toString() }
```

Лямбда-выражение принимает индекс элемента массива и возвращает значение, которое будет помещено в массив с этим индексом. Значение вычисляется путём сложения индекса с кодом символа и преобразованием результата в строку.


* forEachIndexed 

Если нужна информация не только о значении элемента, но и его индексе, то используем forEachIndexed.

```kt
arr.forEachIndexed { index, element ->
    println("$index : $element")
}
```

* reversedArray()

Возвращает перевернутое содержимое массива (оригинальный массив не меняется)

```kt
val numbers: IntArray = intArrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9)
var reversedArray = numbers.reversedArray()
```

* reverse()

Если оригинал нам не нужен, то можно перевернуть содержимое массива не создавая новый массив

```kt
val numbers: IntArray = intArrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9)
numbers.reverse()
```

## Сортировка элементов массива

В Kotlin очень просто сортировать элементы.

Вызываем метод sort(). Мы меняем существующий массив, а не создаём новый.

```kt
val numbers: IntArray = intArrayOf(7, 5, 8, 4, 9, 6, 1, 3, 2)
numbers.sort()
println(Arrays.toString(numbers))
```

Сортировать можно не весь массив, а только определённый диапазон. Указываем начало и размер диапазона. Допустим, нам нужно отсортировать только первые три элемента из предыдущего примера.


```
numbers.sort(0, 3)
// 5, 7, 8, 4, 9, 6, 1, 3, 2
```

Сортировка в обратном порядке от наибольшего значения к наименьшему.

```kt
numbers.sortDescending()
```

Если нужно сохранить исходный массив, то вызываем другие функции, которые создадут новый массив.

```kt
val numbers: IntArray = intArrayOf(7, 5, 8, 4, 9, 6, 1, 3, 2)
val sortedNumbers: IntArray = numbers.sortedArray() // новый сортированный массив
val descendingSortedNumber: IntArray = numbers.sortedArrayDescending() // новый сортированный массив в обратном порядке

println(Arrays.toString(numbers) + ":" + Arrays.toString(sortedNumbers))
// [7, 5, 8, 4, 9, 6, 1, 3, 2]:[1, 2, 3, 4, 5, 6, 7, 8, 9]:[9, 8, 7, 6, 5, 4, 3, 2, 1]
```

Для сортировки объектов указываем компаратор и условие сравнения. Например, мы хотим сравнить котов по их возрастам.

```kt
data class Cat(val name: String, val age: Int)

val cats = arrayOf(Cat("Барсик", 8), Cat("Мурзик", 4), Cat("Васька", 9))
// массив до сортировки
cats.forEach { println(it) }

// сортируем по возрасту
cats.sortWith(Comparator { c1: Cat, c2: Cat -> c1.age - c2.age })
cats.forEach { println(it) }
```

Вместо компаратора можно использовать функцию sortBy() с указанием условия. Сравним теперь котов не по возрасту, а по их именам.

```kt
val cats = arrayOf(Cat("Барсик", 8), Cat("Мурзик", 4), Cat("Васька", 9))

cats.sortBy { cat -> cat.name }
```

Содержится ли элемент в массиве

Если содержится, то возвращает true.

```kt
val array = arrayOf(1, 2, 3, 4, 5)
val isContains = array.contains(9) // false
```

Найти среднее значение чисел в массиве

Используем функцию average(). Возвращается Double.

```kt
val array = arrayOf(1, 3, 5)
println(array.average()) // 3.0
```

Подсчитать сумму чисел в массиве

```
val array = arrayOf(1, 2, 3, 4, 5)
println(array.sum()) // 15
```

Найти наибольшее и наименьшее число в массиве

В цикле сравниваем каждое число с эталоном, которые вначале принимает значение первого элемента. Если следующее число массива больше эталона, то берём его значение. В итоге после перебора получим наибольшее число в массиве.


```kt
val numbers: IntArray = intArrayOf(4, 9, 3, 2, 6)
var largestElement = numbers[0]

for (number in numbers){
    if(largestElement < number)
        largestElement = number
}

println("Наибольшее число в массиве: $largestElement")
```

Но можно не писать свой код, а вызвать готовые функции min() и max().

```kt
println(numbers.min())
println(numbers.max())
```

Найти общие элементы двух массивов

Есть два массива с числами. Нужно сравнить их и найти у них общие числа. Поможет нам функция intersect()

```kt
val firstArray = arrayOf(1, 2, 3, 4, 5)
val secondArray = arrayOf(3, 5, 6, 7, 8)

val intersectedArray = firstArray.intersect(secondArray.toList()).toIntArray()
println(Arrays.toString(intersectedArray))

//[3, 5]
```

# Коллекции

Коллекции в Kotlin используют множество различных интерфейсов: Iterable, Collection, Set, List, MutableIterable, MutableCollection и др.

В Kotlin нет собственных коллекций, только Java-коллекции. Но при этом в Kotlin они обладают более широкими возможностями, используя расширения. Например, вы можете узнать последний элемент списка или найти максимальное значение в коллекции чисел.

Важная особенность - в Kotlin интерфейсы явно разделены на две группы - изменяемые и неизменяемые. Старайтесь всегда использовать неизменяемые коллекции с доступом для чтения. Если вам нужно изменять коллекцию, то тогда выбирайте другой вариант. Здесь не надо путать с var и val. Если вы создадите список для чтения и привяжете его к переменной var, список всё равно нельзя будет изменить после создания.

Для создания различных типов коллекций есть разные функции. После создания узнаем, какой класс соответствует коллекции. Основные приёмы работы с коллекциями показаны у listOf().

## List

Функции для создания списков. В списках допустимы дубликаты.

### listOf()

Неизменяемые списки List создаются через функцию listOf():

```kt
val list = listOf(1, 3, 9)
```

Если у вас есть изменяемый список, то его можно сконвертировать в список для чтения через toList():

```kt
val cats = mutableListOf("Мурзик", "Барсик", "Рыжик")
val readOnlyCats = cats.toList()
```

Если указать неправильное значение индекса, то получите исключение ArrayIndexOutOfBoundsException. Вы можете избежать проблемы, если будете использовать метод getOrElse() с указанием значения по умолчанию, если выйдете за пределы допустимых значений. В этом случае вам не придётся обрабатывать исключение.

```kt
val cats = listOf("Мурзик", "Барсик", "Рыжик")
println(cats.getOrElse(4) { "Неизвестный котик" })
```

Другой вариант избежать исключения - использовать getOrNull(), который вернёт null при неправильном индексе. Осталось обработать ситуацию.

```kt
val cats = listOf("Мурзик", "Барсик", "Рыжик")
val cat = cats.getOrNull(4) ?: "Неизвестный котик"
println(cat)
```

Умножаем каждый элемент списка на себя при помощи функции map. Функция проходит по каждому элементу, объединяя результаты в новую коллекцию.

```kt
var list = listOf(1, 2, 3)
var dest = list.map { it * it }
println(dest.toString()) // выводит [1, 4, 9]
```

Выводим только имена, игнорируя возраст и другие поля класса.

```
val cats = listOf(Cat("Barsik", 5, true), Cat("Murzik", 9, true))
println(cats.map (Cat::name))
// или println(cats.map {it.name})
```

Можно объединить вызовы функций в цепочки. Выводим имена котов, чей возраст больше 5.

```kt
val cats = listOf(Cat("Barsik", 5, true), Cat("Murzik", 9, true))
println(cats.filter {it.age > 5}.map (Cat::name))
```

Функция flatMap() работает с коллекцией, содержащей коллекции, и возвращает объединённую «плоскую» коллекцию, содержащую все элементы исходных коллекций.

```kt
val result = listOf(listOf(1, 2, 3), listOf(4, 5, 6)).flatMap { it }
println(result) // [1, 2, 3, 4, 5, 6]
```

**count** с предикатом позволяет узнать число элементов в списке, которые соответствуют условию.

```kt
val list = listOf(1, 2, 3, 4, 5)
// сколько элементов меньше 4?
println(list.count { it < 4 }) // 3
```

Функция-комбинатор zip() принимает разные коллекции и объединяют их в одну новую. Для примера объединим два списка: с именами котов и их размерами. Функция zip() возвращает новый список (коллекцию пар Pair). Для этой коллекции пар вызовем функцию toMap(), чтобы получить ассоциативный массив, к элементам которого можно обращаться по ключу. В этом случае ключ — имя кота.

```kt
val names = listOf("Барсик", "Мурзик", "Рыжик")
val sizes = listOf("большой", "средний", "совсем котёнок")
val catMap = names.zip(sizes).toMap()
// обращаемся к ключу
println(catMap["Рыжик"]) // совсем котёнок
```

**fold** задаёт начальное значение, а потом собирает все значения в списке от первого к последнему.

```kt
val list = listOf(1, 2, 3, 4, 5)

// 15 + 1 + 2 + 3 + 4 + 5
println(list.fold(15) { total, next -> total + next }) // 30
```

**reduce** работает аналогично, только без указания начального значения.

```kt
println(listOf(1, 2, 3).reduce { total, next ->
    total + next
})
```

**foldRight** работает аналогично fold, только значения берутся от последнего к первому.

```kt
println(listOf(1, 2, 3).foldRight(1) { total, next -> total * next })
```

**reduceRight** похож на foldRight без указания начального значения.

**maxBy()** возвращает первый элемент с наибольшим значением заданной функции или null, если элементов нет.

Выберем самого старшего кота (класс содержит имя и возраст, а также другие свойства).

```kt
val cats = listOf(Cat("Барсик", 5, true), Cat("Мурзик", 9, true))
println(cats.maxBy { it.age })
```

//TODO: дописать

http://developer.alexanderklimov.ru/android/kotlin/collection.php

[содержание](/readme.md)  
