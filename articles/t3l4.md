[содержание](/readme.md)  

* Циклы
* Массивы
* Коллекции

# Циклы

## for

```
for(i in range)
for(i in array)
for(i in string)
```

Обычное использование с диапазонами и итерацию по строкам/массивам мы уже проходили, рассмотрим другие варианты:

## Обращение по индексу

Строки и массивы имеют методы:

* .indices - возвращает диапазон валидных индексов

```kt
//"test".indices // 0..3
for(c in "test".indices)
  println(c)
```
```
t
e
s
t  
```

* .withIndex() - позволяет при проходе по итерабельному объекту получать пару (индекс,элемент)

```kt
val cats = arrayListOf("Мурзик", "Васька", "Барсик")
for( (index, element) in cats.withIndex()){
    println("$index: $element")
}
```

Получим:

```
0: Мурзик
1: Васька
2: Барсик
```

## forEach

Проходит по всем элементам коллекции.

```kt
val daysOfWeek = listOf("Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday")
daysOfWeek.forEach{
    println(it)
}
```

## repeat()

Встроенная функция для повторения команд заданное число раз.

```kt
repeat(3){
    println("Васька! Иди жрать!")
}
```

# Массивы

Массив можно создать двумя способами - через конструктор Array() или через методы arrayOf(), arrayOfNulls(), emptyArray().

* arrayOf()

```kt
val myArray = arrayOf(1, 2, 3, 4, 5)
```

Узнать длину массива можно при помощи свойства *size*.

```kt
println(myArray.size) // 5
```

Элементами массива могут быть данные разных типов:

```kt
val myArray = arrayOf(1, 2, 3, 4, 5, "зайчик", "вышел", "погулять")
```

Если мы хотим строгого поведения и не хотим смешивать разные типы, то используем обобщения.

```kt
val myArray = arrayOf<Int>(1, 2, 3, 4, 5) // только числа Integer
```

Существует также синонимы метода, когда уже в имени содержится подсказка: intArrayOf(), charArrayOf(), booleanArrayOf(), longArrayOf(), shortArrayOf(), byteArrayOf().

Перепишем пример.

```kt
val myArray = intArrayOf(1, 2, 3, 4, 5)
```

* arrayOfNulls()

Для создания массива с заполненными значениями null можно использовать отдельную функцию arrayOfNulls().

Создадим массив с тремя элементами.

```
val array = arrayOfNulls(3) // [null, null, null]
```

* emptyArray()

Создает пустой массив

```
var arr = emptyArray<String>() // []
arr += "1"
arr += "2"
```

* Конструктор Array()

При использовании конструктора нужно указать размер массива в первом параметре и лямбда-выражение во втором.

```kt
val myArray = Array(5, { i -> i * 2 })
```

Мы задали пять элементов и каждый элемент в цикле умножаем на 2. В итоге получим массив чисел 0, 2, 4, 6, 8.

Создадим массив строк от "A" до "Z"

```kt
val letters = Array<String>(26) { i -> ('A' + i).toString() }
```

Лямбда-выражение принимает индекс элемента массива и возвращает значение, которое будет помещено в массив с этим индексом. Значение вычисляется путём сложения индекса с кодом символа и преобразованием результата в строку.


* forEachIndexed 

Если нужна информация не только о значении элемента, но и его индексе, то используем forEachIndexed.

```kt
arr.forEachIndexed { index, element ->
    println("$index : $element")
}
```

* reversedArray()

Возвращает перевернутое содержимое массива (оригинальный массив не меняется)

```kt
val numbers: IntArray = intArrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9)
var reversedArray = numbers.reversedArray()
```

* reverse()

Если оригинал нам не нужен, то можно перевернуть содержимое массива не создавая новый массив

```kt
val numbers: IntArray = intArrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9)
numbers.reverse()
```

## Сортировка элементов массива

В Kotlin очень просто сортировать элементы.

Вызываем метод sort(). Мы меняем существующий массив, а не создаём новый.

```kt
val numbers: IntArray = intArrayOf(7, 5, 8, 4, 9, 6, 1, 3, 2)
numbers.sort()
println(Arrays.toString(numbers))
```

Сортировать можно не весь массив, а только определённый диапазон. Указываем начало и размер диапазона. Допустим, нам нужно отсортировать только первые три элемента из предыдущего примера.


```
numbers.sort(0, 3)
// 5, 7, 8, 4, 9, 6, 1, 3, 2
```

Сортировка в обратном порядке от наибольшего значения к наименьшему.

```kt
numbers.sortDescending()
```

Если нужно сохранить исходный массив, то вызываем другие функции, которые создадут новый массив.

```kt
val numbers: IntArray = intArrayOf(7, 5, 8, 4, 9, 6, 1, 3, 2)
val sortedNumbers: IntArray = numbers.sortedArray() // новый сортированный массив
val descendingSortedNumber: IntArray = numbers.sortedArrayDescending() // новый сортированный массив в обратном порядке

println(Arrays.toString(numbers) + ":" + Arrays.toString(sortedNumbers))
// [7, 5, 8, 4, 9, 6, 1, 3, 2]:[1, 2, 3, 4, 5, 6, 7, 8, 9]:[9, 8, 7, 6, 5, 4, 3, 2, 1]
```

Для сортировки объектов указываем компаратор и условие сравнения. Например, мы хотим сравнить котов по их возрастам.

```kt
data class Cat(val name: String, val age: Int)

val cats = arrayOf(Cat("Барсик", 8), Cat("Мурзик", 4), Cat("Васька", 9))
// массив до сортировки
cats.forEach { println(it) }

// сортируем по возрасту
cats.sortWith(Comparator { c1: Cat, c2: Cat -> c1.age - c2.age })
cats.forEach { println(it) }
```

Вместо компаратора можно использовать функцию sortBy() с указанием условия. Сравним теперь котов не по возрасту, а по их именам.

```kt
val cats = arrayOf(Cat("Барсик", 8), Cat("Мурзик", 4), Cat("Васька", 9))

cats.sortBy { cat -> cat.name }
```

Содержится ли элемент в массиве

Если содержится, то возвращает true.

```kt
val array = arrayOf(1, 2, 3, 4, 5)
val isContains = array.contains(9) // false
```

Найти среднее значение чисел в массиве

Используем функцию average(). Возвращается Double.

```kt
val array = arrayOf(1, 3, 5)
println(array.average()) // 3.0
```

Подсчитать сумму чисел в массиве

```
val array = arrayOf(1, 2, 3, 4, 5)
println(array.sum()) // 15
```

Найти наибольшее и наименьшее число в массиве

В цикле сравниваем каждое число с эталоном, которые вначале принимает значение первого элемента. Если следующее число массива больше эталона, то берём его значение. В итоге после перебора получим наибольшее число в массиве.


```kt
val numbers: IntArray = intArrayOf(4, 9, 3, 2, 6)
var largestElement = numbers[0]

for (number in numbers){
    if(largestElement < number)
        largestElement = number
}

println("Наибольшее число в массиве: $largestElement")
```

Но можно не писать свой код, а вызвать готовые функции min() и max().

```kt
println(numbers.min())
println(numbers.max())
```

Найти общие элементы двух массивов

Есть два массива с числами. Нужно сравнить их и найти у них общие числа. Поможет нам функция intersect()

```kt
val firstArray = arrayOf(1, 2, 3, 4, 5)
val secondArray = arrayOf(3, 5, 6, 7, 8)

val intersectedArray = firstArray.intersect(secondArray.toList()).toIntArray()
println(Arrays.toString(intersectedArray))

//[3, 5]
```

# Коллекции

Коллекции в Kotlin используют множество различных интерфейсов: Iterable, Collection, Set, List, MutableIterable, MutableCollection и др.

В Kotlin нет собственных коллекций, только Java-коллекции. Но при этом в Kotlin они обладают более широкими возможностями, используя расширения. Например, вы можете узнать последний элемент списка или найти максимальное значение в коллекции чисел.

Важная особенность - в Kotlin интерфейсы явно разделены на две группы - изменяемые и неизменяемые. Старайтесь всегда использовать неизменяемые коллекции с доступом для чтения. Если вам нужно изменять коллекцию, то тогда выбирайте другой вариант. Здесь не надо путать с var и val. Если вы создадите список для чтения и привяжете его к переменной var, список всё равно нельзя будет изменить после создания.

Для создания различных типов коллекций есть разные функции. После создания узнаем, какой класс соответствует коллекции. Основные приёмы работы с коллекциями показаны у listOf().

## List

Функции для создания списков. В списках допустимы дубликаты.

### listOf()

Неизменяемые списки List создаются через функцию listOf():

```kt
val list = listOf(1, 3, 9)
```

Если у вас есть изменяемый список, то его можно сконвертировать в список для чтения через toList():

```kt
val cats = mutableListOf("Мурзик", "Барсик", "Рыжик")
val readOnlyCats = cats.toList()
```

Если указать неправильное значение индекса, то получите исключение ArrayIndexOutOfBoundsException. Вы можете избежать проблемы, если будете использовать метод getOrElse() с указанием значения по умолчанию, если выйдете за пределы допустимых значений. В этом случае вам не придётся обрабатывать исключение.

```kt
val cats = listOf("Мурзик", "Барсик", "Рыжик")
println(cats.getOrElse(4) { "Неизвестный котик" })
```

Другой вариант избежать исключения - использовать getOrNull(), который вернёт null при неправильном индексе. Осталось обработать ситуацию.

```kt
val cats = listOf("Мурзик", "Барсик", "Рыжик")
val cat = cats.getOrNull(4) ?: "Неизвестный котик"
println(cat)
```

Умножаем каждый элемент списка на себя при помощи функции map. Функция проходит по каждому элементу, объединяя результаты в новую коллекцию.

```kt
var list = listOf(1, 2, 3)
var dest = list.map { it * it }
println(dest.toString()) // выводит [1, 4, 9]
```

Выводим только имена, игнорируя возраст и другие поля класса.

```
val cats = listOf(Cat("Barsik", 5, true), Cat("Murzik", 9, true))
println(cats.map (Cat::name))
// или println(cats.map {it.name})
```

Можно объединить вызовы функций в цепочки. Выводим имена котов, чей возраст больше 5.

```kt
val cats = listOf(Cat("Barsik", 5, true), Cat("Murzik", 9, true))
println(cats.filter {it.age > 5}.map (Cat::name))
```

Функция flatMap() работает с коллекцией, содержащей коллекции, и возвращает объединённую «плоскую» коллекцию, содержащую все элементы исходных коллекций.

```kt
val result = listOf(listOf(1, 2, 3), listOf(4, 5, 6)).flatMap { it }
println(result) // [1, 2, 3, 4, 5, 6]
```

**count** с предикатом позволяет узнать число элементов в списке, которые соответствуют условию.

```kt
val list = listOf(1, 2, 3, 4, 5)
// сколько элементов меньше 4?
println(list.count { it < 4 }) // 3
```

Функция-комбинатор zip() принимает разные коллекции и объединяют их в одну новую. Для примера объединим два списка: с именами котов и их размерами. Функция zip() возвращает новый список (коллекцию пар Pair). Для этой коллекции пар вызовем функцию toMap(), чтобы получить ассоциативный массив, к элементам которого можно обращаться по ключу. В этом случае ключ — имя кота.

```kt
val names = listOf("Барсик", "Мурзик", "Рыжик")
val sizes = listOf("большой", "средний", "совсем котёнок")
val catMap = names.zip(sizes).toMap()
// обращаемся к ключу
println(catMap["Рыжик"]) // совсем котёнок
```

**fold** задаёт начальное значение, а потом собирает все значения в списке от первого к последнему.

```kt
val list = listOf(1, 2, 3, 4, 5)

// 15 + 1 + 2 + 3 + 4 + 5
println(list.fold(15) { total, next -> total + next }) // 30
```

**reduce** работает аналогично, только без указания начального значения.

```kt
println(listOf(1, 2, 3).reduce { total, next ->
    total + next
})
```

**foldRight** работает аналогично fold, только значения берутся от последнего к первому.

```kt
println(listOf(1, 2, 3).foldRight(1) { total, next -> total * next })
```

**reduceRight** похож на foldRight без указания начального значения.

**maxBy()** возвращает первый элемент с наибольшим значением заданной функции или null, если элементов нет.

Выберем самого старшего кота (класс содержит имя и возраст, а также другие свойства).

```kt
val cats = listOf(Cat("Барсик", 5, true), Cat("Мурзик", 9, true))
println(cats.maxBy { it.age })
```

**sumBy()** подсчитывает сумму всех элементов, после того, как они подверглись изменению.

```kt
// увеличиваем все элементы на 5, а потом складываем
println(listOf(1, 2, 3).sumBy { it + 5 }) // 21
```

**take** оставит первые элементы списка. takeLast оставит последние элементы.

```kt
// оставим первые два элемента
println(listOf(12, 32, 34, 45, 45).take(2)) // [12, 32]
```

**takeWhile** оставит элементы, которые соответствуют условию.

```kt
println(listOf(1, 2, 3, 4, 5).takeWhile{it < 3}) // [1, 2]
```

**filter** вернёт список, который соответствует предикату. Также есть **filterNotNull**, который вернёт список, не содержащий null. Функция может удалять элементы из коллекции, но не может изменять их (используйте map).

```kt
// больше или равно 3
println(
  listOf(1, 2, 3, 4, 5).filter { it >= 3 }
) // [3, 4, 5]
```

```kt
// чётные числа
println(
  listOf(1, 2, 3, 4, 5).filter { it % 2 == 0 }
) // [2, 4]
```

```kt
val cats = listOf("Барсик", "Мурзик", "Васька", "Рыжик")
// слова, у которых второй символ "а"
println(cats.filter { it[1] == 'а' })
// [Барсик, Васька]
```

```kt
// Содержит "ик", сортируем по длине слова
val cats = listOf("Барсик", "Мурзик", "Пикассо", "Васька", "Рыжик")
val filtered = cats.filter { it.contains("ик") }.sortedBy { it.length }
println(filtered)
```

```kt
// Начинается на "П" и оканчивается на "к"
val cats = listOf("Барсик", "Мурзик", "Пикассо", "Васька", "Рыжик", "Пушок")
val filtered = cats.filter { it.startsWith('П') } .filter { it.endsWith('к') }
println(filtered) // Пушок
```

**filterNot** вернёт список, который не соответствует предикату.

```kt
// оставляем нечётные числа
println(listOf(1, 2, 3, 4, 5).filterNot { it % 2 == 0 }) // [1, 3, 5]
```

Получить элемент по индексу можно через **elementAt()**. Также доступны **elementAtOrElse**, **elementAtOrNull**.

```
println(listOf(1, 2, 3, 4, 5).elementAt(3)) // 4
```

**first()** вернёт первый элемент, соответствующий предикату. Если элемент не будет найдет, то получим исключение NoSuchElementException. Похожая функция **firstOrNull** вернёт null, если элемент не будет найден.

```kt
println(listOf(1, 2, 3, 4, 5).first{it % 3 == 0}) // 3
```

По такому же принципу работают last() и lastOrNull() для последнего элемента.

**indexOf()** вернёт индекс элемента. Функции **indexOfFirst()**, **indexOfLast**, **lastIndexOf()** работают с предикатами.

```kt
println(listOf(1, 2, 3, 4, 5).indexOf(4)) // 3
```

Функция **single()** вернёт один уникальный элемент из списка. Если элементов, соответствующих условию, будет несколько будет исключение. **singleOrNull** вместо исключения вернёт null.

```kt
println(
  listOf(1, 6, 3, 4, 5).singleOrNull { it % 3 == 0 }
) // null
```

Добавить ещё один элемент можно через **plus()**. Оригинальный список останется без изменений и будет создан новый список.

```kt
val list = listOf(1, 2, 3, 4, 5)
println(list.plus(6)) // новый список [1, 2, 3, 4, 5, 6]
println(list) // старый список [1, 2, 3, 4, 5]
```

Функция minus() удаляет указанный элемент.

```kt
val list = listOf(1, 2, 3, 4, 5)
println(list.minus(3)) // [1, 2, 4, 5]
```

Функция **slice** возвращает список по указанным индексам.

```kt
println(
  listOf(1, 2, 3, 4, 5).slice(listOf(1, 3, 4))
)  // [2, 4, 5]
```

Функция **shuffled()** создаёт новый список с перемешанными элементами от старого списка.

```kt
val items = listOf(1, 2, 3)
val newList = items.shuffled()

println("shuffled: $newList") // shuffled: [2, 1, 3] один из вариантов
```

**groupBy()** группирует значения по некоторому критерию. Например, мы хотим разбить список котов по возрасту.

```kt
val cats = listOf(Cat("Barsik", 5),
        Cat("Murzik", 9), Cat("Ryzhik", 5))
println(cats.groupBy { it.age })

// Результат
{5=[Cat(name=Barsik, age=5), Cat(name=Ryzhik, age=5)],
 9=[Cat(name=Murzik, age=9)]}
``` 

На выходе получается словарь с ключами (Map<Int, List<Cat>>), которые определяют признак группировки (в нашем случае это возраст). Мы получили одну группу котов с возрастом 5 лет и вторую группу с возрастом 9 лет. Вы можете изменить словарь при помощи mapKeys и mapValues.

Список может содержать дубликаты. Но если вы хотите избавиться от них, то можно преобразовать список во множество, а затем снова в список. Существует готовая функция **distinct()**, которая сделает это за вас.

```kt
val cats = listOf("Рыжик", "Мурзик", "Барсик", "Рыжик")
        .distinct() // ["Рыжик", "Мурзик", "Барсик"]
```        

**emptyList()**

Пустой неизменяемый список можно создать через emptyList(), который вернёт тип List.

```kt
val emptyList: List<String> = emptyList<String>()
```

**listOfNotNull()**

Ещё один вид неизменяемых списков - listOfNotNull().

```kt
val nonNullsList: List<String> = listOfNotNull(9, 35, 7, null, 44, null)
```

**arrayListOf()**

Изменяемый список создаётся через arrayListOf(), который возвращает ArrayList.

```kt
//val stringList: ArrayList<String> = arrayListOf<String>("Hello", "Kitty")
val stringList = arrayListOf("Hello", "Kitty")
```

**mutableListOf()**

Изменять данные можно только в изменяемых списках. Но если у вас есть в наличии неизменяемый список, то его можно сконвертировать в изменяемый через специальный метод **toMutableList()**. При этом будет создан новый список.

```kt
var mutableNames = names.toMutableList() // превращаем в изменяемый список
mutableNames.add("Рыжик") // добавляем новое имя
```

А можно сразу создать изменяемый список нужного типа через **mutableListOf<T>()**. Также есть перегруженная версия без указания нужного типа - **mutableListOf()**.

```kt
val mutableListNames: MutableList<String> =
        mutableListOf<String>("Барсик", "Мурзик", "Васька")
mutableListNames.add("Рыжик") // добавляем
mutableListNames.removeAt(1) // удаляем второй элемент
mutableListNames[0] = "Пушок" // заменяем первый элемент через присваивание

// изменяемый список из разных типов
val mutableListMixed = mutableListOf("Кот", "Собака", 5, 5.27, 'F')
```

Удалить элемент из изменяемого списка можно через **removeIf()**, указав лямбда-выражение в качестве условия.

```kt
val cats = mutableListOf("Мурзик", "Барсик", "Рыжик")
cats.removeIf{ it.contains("у") }
println(cats)

// выводится: [Барсик, Рыжик]
```

Другой способ объединения двух списков с сохранением только уникальных элементов. Обратите внимание на порядок сохранения - сначала берутся элементы основного списка, а затем добавляются элементы добавляемого списка.

```kt
val listA = mutableListOf("a", "e", "b")
val listB = mutableListOf("a", "c", "d", "e", "f")
val listC = listB.union(listA)
println(listC)
```

**replaceAll (Kotlin 1.2)**

Заменяет каждый элемент списка новым значением в результате заданного выражения. Доступно для API 24 и выше

```kt
val items = (1..5).toMutableList()

if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
    items.replaceAll { it * 2 }
}
println("Значения удвоены: $items") // [2, 4, 6, 8, 10]
```

**fill (Kotlin 1.2)**

Заменяет все элементы списка заданным значением.

```kt
val items = (1..5).toMutableList()

println("Было: $items")
items.fill(5)
println("Стало: $items")

//Было: [1, 2, 3, 4, 5]
//Стало: [5, 5, 5, 5, 5]
```

Все коллекция являются стандартными и полностью совместимыми с Java, Kotlin не использует собственных коллекций, но тем не менее предлагает удобные методы из коробки. Выше были показаны примеры для списков. Можно применять методы для других коллекций.

**joinToString()**

Встроенная котлиновская функция для создания строки из элементов коллекции. Вы можете задать собственный префикс и постфикс, а также разделитель. При большом количестве элементов можно задать лимит, тогда будут показаны первые элементы коллекции и после них многоточие.

Функция использует параметры по умолчанию, поэтому часть параметров можно опускать.

```kt
val numbers = listOf(1, 2, 3, 4, 5, 6)
println(numbers.joinToString()) // 1, 2, 3, 4, 5, 6
println(numbers.joinToString(prefix = "[", postfix = "]")) // [1, 2, 3, 4, 5, 6]
println(numbers.joinToString(prefix = "<", postfix = ">", separator = "•")) // <1•2•3•4•5•6>

val chars = charArrayOf('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q')
println(chars.joinToString(limit = 5, truncated = "...!") { it.toUpperCase().toString() }) // A, B, C, D, E, ...!
```

### Создать список из случайных чисел

В Kotlin можно создать функцию для генерации списка из случайных чисел очень лаконичным способом.

```kt
val random = Random()
fun buildRandom() = List(25) { random.nextInt() }

// вызываем функцию
println(buildRandom())
```

## Set (Множество)

В коллекции с интерфейсом Set дубликаты элементов не допускаются, все элементы должны быть уникальными.

**setOf()**

Неизменяемая коллекция Set создаётся функцией setOf():

```kt
val set = setOf(1, 3, 9)

var intSet: Set<Int> = setOf(1, 2, 3)  // разрешены только Integer

val cats = setOf("Мурзик", "Барсик", "Рыжик")
```

Если попытаетесь добавить дубликат, то он будет просто отброшен и не попадёт в набор.

Мы не можем обратиться к нужному элементу по идексу через квадратные скобки, как у List. Но мы можем использовать elementAt()

```kt
println(cats.elementAt(2))
```

Разбить на две коллекции по указанному признаку можно через функцию partition():

```kt
val setA = setOf(1, 2, 3, 4, 5, 6)
val pair = setA.partition {
    it % 2 == 0
}
println(pair) // ([2, 4, 6], [1, 3, 5])
```



[содержание](/readme.md)  
