# Языки программирования.

**Язык программирования** — это способ записи программ решения различных задач на компьютере в понятной для компьютера форме.

Процессор компьютера непосредственно понимает **язык машинных команд**.

Программы на таких языках программисты писали лишь для самых первых ламповых машин — ЭВМ первого поколения.

В 1950-х гг. появляются первые средства автоматизации программирования — языки Автокоды. Позднее для языков этого уровня стало применяться название «Ассемблеры».

Появление языков типа Ассемблер облегчило участь программистов.
Переменные величины стали изображаться символическими именами. Числовые коды операций заменились на мнемонические (словесные) обозначения, которые легче запомнить.

Язык программирования стал понятнее для человека, но при этом удалился от языка машинных команд.

Чтобы компьютер мог исполнять программы на Ассемблере, потребовался специальный переводчик — транслятор. **Транслятор** — это системная программа, переводящая текст программы на Ассемблере в текст эквивалентной программы на язык машинных команд.

## Классификация языков программирования.

Язык машинных команд и ассемблер являются **языками низкого уровня**.

**Язык низкого уровня** – это язык программирования, предназначенный для определенного типа компьютера и отражающий его внутренний машинный код; языки низкого уровня часто называют машинно-ориентированными языками. Их сложно конвертировать для использования на компьютерах с разными центральными процессорами, а также довольно сложно изучать, поскольку для этого требуется хорошо знать внутренние принципы работы компьютера.

**Язык высокого уровня** – это язык программирования, предназначенный для программиста; он не зависит от внутренних машинных кодов компьютера. Каждая команда языка высокого уровня эквивалентна нескольким командам в машинных кодах, поэтому программы, написанные на языках высокого уровня, более компактны, чем аналогичные программы в машинных кодах.

Реализовать тот или иной язык программирования на ЭВМ — это значит создать **транслятор** с этого языка для данной ЭВМ (тут имеется в виду не конкретный экземпляр ЭВМ, а архитектура процессора и поддерживаемая им система команд).

Существуют два принципиально различных метода трансляции. Они называются соответственно **компиляция** и **интерпретация**.

**Компилятор** читает всю программу целиком, делает ее перевод и создает законченный вариант программы на машинном языке, который затем и выполняется.

**Интерпретатор** переводит и выполняет программу строка за строкой (при этом на компьютере должен быть установлен интерпретатор языка).

# Интегрированная среда программирования (IDE).

IDE - комплекс программных средств, используемый программистами для разработки программного обеспечения.

Среда разработки включает в себя:

* текстовый редактор,
* Транслятор (компилятор и/или интерпретатор),
* средства автоматизации сборки,
* отладчик.

Питон не имеет свой IDE. Мы, в дальнейшем, будем использовать **Visual Studio Code** — активно развивающийся, бесплатный редактор исходного кода, разработанный Microsoft для Windows, Linux и macOS. Позиционируется как «лёгкий» редактор кода для кроссплатформенной разработки веб- и облачных приложений. Включает в себя *отладчик*, инструменты для работы с Git (*контроль версий*), *подсветку синтаксиса*, *IntelliSense* и средства для рефакторинга. Т.е. это не полноценный IDE, но вполне подходит для разработки на PHP, JS, имеет систему плагинов, т.е. может быть добавлена поддержка и других языков.

# Типы приложений

Традиционно приложения делят на две большие группы (по способу взаимодействия с пользователем):

* консольные, ввод и вывод информации в которых производится при помощи стандартных потоков ввода (stdin), поток вывода (stdout) и поток ошибок (stderr).

  Стандартные потоки открываются автоматически при запуске программы и связаны по умолчанию с монитором. Хотя вывод может быть перенаправлен в файл (или из файла) средствами операционной системы (>>, <<, >, <).

  Взаимодействие с программой сводится к передаче параметров командную строку или интерактивно через поток ввода и выдачи программой текстовой и символьной информации через поток вывода или ошибок.

  Одним из недостатков консольных приложений считается необходимость ввода команд, достоинством - лёгкое встраивание в скрипты и автоматизация действий. В графических операционных системах (Windows, Mac), консольные программы хоть и играют достаточно важную роль, но практически не развиваются.

  Широкое развитие консольные программы получили в UNIX-подобных операционных системах, где консольные инструменты развиваются и совершенствуются до сих пор.

* оконные приложения позволяют выводить информацию посредством растровых изображений с интенсивным использованием событийной модели.

Мы в рамках этого курса будем рассматривать только консольные приложения.

# Синтаксис и основные типы данных языка Питон.

## Основные свойства

Python не требует явного объявления переменных, является регистро-зависимым (переменная var не эквивалентна переменной Var или VAR — это три разные переменные)объектно-ориентированным языком.

В питоне нет констант (обычно переменные, которые не предполагается менять, пишут большими буквами)

## Алфавит

В именах переменных и функций допускаются латинские буквы, цифры и знак подчеркивания.

## Лексическая структура

Любая Python-программа состоит из последовательности лексем (допустимых символов), записанных в определенном порядке и по определенным правилам.

Лексемы включают в себя:

* комментарии;
* литералы;
* идентификаторы;
* ключевые слова.

### Комментарии

Комментарии предназначены для пояснения кода для разработчика и начинаются с символа #, действуя до конца строки (Листинг 2.1.1).

```py
# Вся эта строка является комментарием
x = 5  # Это inline-комментарий
y = '#Это строка'  # А это комментарий
```

### Литералы

Литералы - значения, представленные в коде программы, например, числа или строки

```py
5         # Целочисленный литерал
3.4       # Литерал в виде числа с плавающей точкой
'строка'  # Строковый литерал
```

### Идентификаторы

**Идентификатор** - обычное имя, которое дается ссылке на какой-либо объект (имя переменной или функции). Любой идентификатор имеет некоторые правила и соглашения наименования.

**правила**

* может состоять из букв (ASCII или Unicode), знаков подчеркивания _ или цифр 0-9;
* цифра не может быть на первом месте;
* чувствителен к регистру: UserName, username и USERNAME - разные идентификаторы;
* не должен совпадать с каким-либо из ключевых слов языка Python

**соглашения**:

* использовать змеиный_регистр (англ. snake_case): customer_account;
* не использовать предопределенные имена;
* не использовать 2 знака подчеркивания __ в начале и конце, и _ или __ в начале идентификатора; данный синтаксис имеет специальное назначение.

```py
some_var_name = 0

def some_fun_name()
```

### Ключевые (зарезервированные) слова

Имена переменным придумывает программист, но есть несколько ограничений, связанных с наименованием. В качестве имен переменных нельзя использовать ключевые слова, которые для Python имеют определенный смысл (эти слова обычно подсвечиваются в IDE цветом):

|  |  |  | | | | 
----|----|--------|-------|-------|--------
and | as | assert | break | class | continue
def | del | elif | else | except |
finally | for | from | global | if | import
in | is | lambda | nonlocal | not | or
pass | raise | return | try | while | with
yield | True | False | None

### Синтаксис

* Во первых стоит отметить интересную особенность Python. Он не содержит операторных скобок (begin..end в pascal или {..} в Си-подобных языках), вместо этого блоки выделяются отступами: пробелами или табуляцией, а вход в блок из операторов осуществляется двоеточием. 

```py
if(x>0):
    x=0
    y=0
    z=0
else:
    x=y=z=1
```

* Конец строки является концом инструкции (точка с запятой не требуется).

* Однострочные комментарии начинаются со знака фунта «#», многострочные — начинаются и заканчиваются тремя двойными кавычками «"""».

```py
# однострочный комментарий
"""это тоже комментарий
и его можно писать в несколько
строк"""
```

* Вложенные инструкции объединяются в блоки по величине отступов. Отступ может быть любым, главное, чтобы в пределах одного вложенного блока отступ был одинаков. И про читаемость кода не забывайте. Отступ в 1 пробел, к примеру, не лучшее решение. Используйте 4 пробела (или знак табуляции, на худой конец).

* Вложенные инструкции в Python записываются в соответствии с одним и тем же шаблоном, когда основная инструкция завершается двоеточием, вслед за которым располагается вложенный блок кода, обычно с отступом под строкой основной инструкции.

```python
Основная инструкция:
    Вложенный блок инструкций:
        Еще один уровень 
```

* Чтобы присвоить значение пременной используется знак «=», а для сравнения — 
«==». Для увеличения значения переменной, или добавления к строке используется оператор «+=», а для уменьшения — «-=». Все эти операции могут взаимодействовать с большинством типов, в том числе со строками. Например:

```py
myvar = 3
myvar += 2
myvar -= 1
mystring = "Hello"
mystring += " world."
print(mystring)
>Hello world.
# Следующая строка меняет значения переменных местами. (Всего одна строка!)
myvar, mystring = mystring, myvar
```

### Несколько специальных случаев

* Иногда возможно записать несколько инструкций в одной строке, разделяя их точкой с запятой:

```py
a = 1; b = 2; print(a, b)
```

* Допустимо записывать одну инструкцию в нескольких строках. Достаточно ее заключить в пару круглых, квадратных или фигурных скобок, либо с использованием висячего отступа. При использовании висячего отступа следует применять следующие соображения: на первой линии не должно быть аргументов, а остальные строки должны четко восприниматься как продолжение линии.

```python
# выражение заключено в скобки и выровнено по открывающей скобке
if (a == 1 and b == 2 and
    c == 3 and d == 4):  # Не забываем про двоеточие
        print('spam' * 3)

# Выровнено по открывающему разделителю
foo = long_function_name(var_one, var_two,
                         var_three, var_four)

# Больше отступов включено для отличения его последующего блока
def long_function_name(
        var_one, var_two, var_three,
        var_four):
    print(var_one)                         
```

* Тело составной инструкции может располагаться в той же строке, что и тело основной, если тело составной инструкции не содержит составных инструкций.

```python
if x > y: print(x)
```

* Для склейки строк можно использовать обратную косую черту. Например, длинная конструкция with не может использовать неявные продолжения, так что обратная косая черта является приемлемой:

```python
with open('/path/to/some/file/you/want/to/read') as file_1, \
        open('/path/to/some/file/being/written', 'w') as file_2:
    file_2.write(file_1.read())
```

### Пустые строки

* Отделяйте функции верхнего уровня и определения классов двумя пустыми строками.
* Определения методов внутри класса разделяются одной пустой строкой.

```python
from MainWindow import Ui_MainWindow


class MainWindow(QMainWindow, Ui_MainWindow):
    def __init__(self, *args, **kwargs):
      pass

    def other(self):
      pass  
```

### Операторы

В языке Python поддерживает такие типы операторов:

* арифметические операторы
* операторы сравнения
* операторы присваивания
* логические операторы
* битовые операторы
* операторы принадлежности
* операторы тождественности

Далее мы рассмотрим все эти операторы по очереди.

**Арифметические операторы**  

Предположим, переменная a = 10, а переменная b = 20.

ОПЕРАТОР | ОПИСАНИЕ  | ПРИМЕР
:-------:|-----------|-------
``+``    | сложение  | a + b = 30
 –       | вычитание | a – b = -10
``*``    | умножение | a * b = 200
``/``    | деление   | b / a = 2
% | модуль (остаток целочисленного деления) | b % a = 0
``**``   | возведение в степень | a**b = 10<sup>20</sup>
 ``//``  | целочисленное деление | 9//2 = 4

**Операторы сравнения**

Результатом сравнения будет логическое значение *True* или *False*

ОПЕРАТОР | ОПИСАНИЕ  | ПРИМЕР
:-------:|-----------|-------
=        | истинным  | 5 = 5 в результате будет True
==       | Проверяет равны ли оба операнда.</br>Если да, то условие становится истинным    | 5 == 5 в результате будет *True*</br>*True* == *False* в результате будет *False*</br>"hello" == "hello" в результате будет *True*
!=       | Проверяет равны ли оба операнда.</br>Если нет, то условие становится истинным    | 12 != 5 в результате будет *True*</br>*False* != *False* в результате будет *False*</br>"hi" != "Hi" в результате будет *True*
<>       | Проверяет равны ли оба операнда.</br>Если нет, то условие становится истинным    | 12 <> 5 в результате будет True</br>Похоже на оператор !=
``>``    | Проверяет больше ли значение левого операнда,</br>чем значение правого. Если да, то условие становится истинным | 5 > 2 в результате будет True</br>True > False в результате будет True</br>"A" > "B" в результате будет False.
``<``    | Проверяет меньше ли значение левого операнда,</br>чем значение правого.</br>Если да, то условие становится истинным | 3 < 5 в результате будет True</br>True < False в результате будет False</br>"A" < "B" в результате будет True.
``>=``   | Проверяет больше или равно значение левого операнда,</br>чем значение правого.</br>Если да, то условие становится истинным | 1 >= 1 в результате будет True</br>23 >= 3.2 в результате будет True</br>"C" >= "D" в результате будет False.
``<=``   | Проверяет меньше или равно значение левого операнда,</br>чем значение правого.</br>Если да, то условие становится истинным | 4 <= 5 в результате будет True</br>0 <= 0.0 в результате будет True</br>-0.001 <= -36 в результате будет False

**Операторы присваивания**  

Присваивает значение правого **выражения** левому операнду

ОПЕРАТОР | ОПИСАНИЕ  | ПРИМЕР
:-------:|-----------|-------
=        | Присваивает значение правого операнда левому. | c = 23 присвоит переменной с значение 23
+=       | Прибавит значение правого операнда к левому</br>и присвоит эту сумму левому операнду | с = 5</br>а = 2</br>с += а равносильно: с = с + а</br>с будет равно 7
-=       | Отнимает значение правого операнда от левого</br>и присваивает результат левому операнду | с = 5</br>а = 2</br>с -= а равносильно: с = с - а</br>с будет равно 3
*=       | Умножает правый операнд с левым</br>и присваивает результат левому операнду    | с = 5</br>а = 2</br>с *= а равносильно: с = с * а</br>c будет равно 10
/=       | Делит левый операнд на правый</br>и присваивает результат левому операнду | с = 10</br>а = 2</br>с /= а равносильно: с = с / а</br>c будет равно 5
%=       | Делит по модулю операнды</br> и присваивает результат левому | с = 5</br>а = 2</br>с %= а равносильно: с = с % а</br>c будет равно 1
``**=``  | Возводит левый операнд в степень правого</br>и присваивает результат левому операнду | с = 3</br>а = 2</br>с \*\*= а равносильно: с = с \*\* а.</br>c будет равно 9
``//=``  | Производит целочисленное деление левого операнда на правый</br>и присваивает результат левому операнду | с = 11</br>а = 2</br>с //= а равносильно: с = с // а</br>c будет равно 5

**Побитовые операторы**  

Побитовые операторы предназначены для работы с данными в битовом (двоичном) формате. Предположим, что у нас есть два числа a = 60; и b = 13. В двоичном формате они будут иметь следующий вид:  
```
a = 0011 1100  
b = 0000 1101
```

ОПЕРАТОР | ОПИСАНИЕ  | ПРИМЕР
:-------:|-----------|-------
&        | Бинарный "И" | a & b = 12, которое в двоичном формате выглядит так 0000 1100
\|       | Бинарный "ИЛИ" | a \| b = 61 (0011 1101)
^        | Бинарный "Исключительное ИЛИ" | a ^ b = 49 (0011 0001)
~        | Бинарный комплиментарный оператор</br>Является унарным (то есть ему нужен только один операнд) | ~a = -61 (1100 0011)
<<       | Побитовый сдвиг влево</br>Значение левого операнда "сдвигается" влево на количество бит указанных в правом операнде | a << 2 = 240 (1111 0000)
``>>``   | Побитовый сдвиг вправо</br>Значение левого операнда "сдвигается" вправо на количество бит указанных в правом операнде | a >> 2 = 15 (0000 1111)

**Логические операторы**

ОПЕРАТОР | ОПИСАНИЕ  | ПРИМЕР
:-------:|-----------|-------
and      | Логический оператор "И"</br>Условие будет истинным если оба операнда истина | True and True равно True</br>True and False равно False</br>False and True равно False</br>False and False равно False
or       | Логический оператор "ИЛИ"</br>Если хотя бы один из операндов истинный, то и все выражение будет истинным. | True or True равно True</br>True or False равно True</br>False or True равно True</br>False or False равно False
not      | Логический оператор "НЕ"</br>Изменяет логическое значение операнда на противоположное | not True равно False</br>not False равно True

**Операторы членства**  

В Python присутствуют, так называмые, операторы членства, предназначенные для проверки на наличие элемента в составных типах данных, таких, как строки, списки, кортежи или словари:

ОПЕРАТОР | ОПИСАНИЕ  | ПРИМЕР
:-------:|-----------|-------
in       | Возвращает истину, если элемент присутствует в последовательности, иначе возвращает ложь | "cad" in "cadillac" вернет True</br>1 in [2,3,1,6] вернет True</br>"hi" in {"hi":2,"bye":1} вернет True</br>2 in {"hi":2,"bye":1} вернет False</br>(в словарях проверяется наличие в ключах, а не в значениях)
not in   | Возвращает истину если элемента нет в последовательности | Результаты противоположны результатам оператора in.

**Операторы тождественности**  

Операторы тождественности сравнивают размещение двух объектов в памяти компьютера.

ОПЕРАТОР | ОПИСАНИЕ  | ПРИМЕР
:-------:|-----------|-------
is       | Возвращает истину, если оба операнда указывают на один объект | x is y вернет истину, если id(x) будет равно id(y).
is not   | Возврашает ложь если оба операнда указывают на один объект | x is not y, вернет истину если id(x) не равно id(y).

**Приоритет операторов**  

В следующей таблице описан приоритет выполнения операторов в Python от наивысшего (выполняется в первую очередь) до наинизшего.

ОПЕРАТОР | ОПИСАНИЕ 
:-------:|----------
**       | Возведение в степень
~        | Комплиментарный оператор
``*``    | Умножение 
/        | деление
%        | деление по модулю (остаток от деления)
//       | целочисленное деление
``+``    | Сложение
``-``    | вычитание
``>>``   | Побитовый сдвиг вправо
``<<``   | побитовый сдвиг влево.
&        | Бинарный "И"
^        | Бинарный "Исключительное ИЛИ"
\|       | бинарный "ИЛИ"
<=</br><</br>></br>>= | Операторы сравнения
<></br>==</br>!= | Операторы равенства (неравенства)
=</br>%=</br>/=</br>//=</br>-=</br>+=</br>*=</br>**= | Операторы присваивания
is</br>is not | Тождественные операторы
in</br>not in | Операторы членства
not</br>or</br>and | Логические операторы

В случае сомнений в порядке вычислений будет не лишним обозначить приоритет в
виде круглых скобок. 

### Типы данных и операции с ними

#### Числа: целые, вещественные, комплексные

**Целые числа (int)**  

Числа в Python ничем не отличаются от обычных чисел. Они поддерживают набор самых обычных математических операций:

Операция | Описание
:-------:|---------
x + y	 | Сложение  
x - y    | Вычитание  
x * y	 | Умножение  
x / y	 | Деление  
x // y   | Получение целой части от деления  
x % y	 | Остаток от деления  
-x       | Смена знака числа  
abs(x)   | Модуль числа  
divmod(x, y) | Пара (x // y, x % y)
x ** y   | Возведение в степень
pow(x, y[, z]) | x<sup>y</sup> по модулю (если модуль задан)

Над целыми числами также можно производить битовые операции

Операция | Описание
:-------:|---------
x \| y   | Побитовое или
x ^ y	 | Побитовое исключающее или
x & y	 | Побитовое и
x << n   | Битовый сдвиг влево
x >> y   | Битовый сдвиг вправо
~x       | Инверсия битов

**Вещественные числа (float)**  

Вещественные числа поддерживают те же операции, что и целые. Однако (из-за представления чисел в компьютере) вещественные числа неточны, и это может привести к ошибкам:

```python
0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1
0.9999999999999999
```

Для высокой точности используют другие объекты (например Decimal и Fraction)).

Помимо стандартных выражений для работы с числами (а в Python их не так уж и много), в составе Python есть несколько полезных модулей.

Модуль **math** предоставляет более сложные математические функции.

Модуль **random** реализует генератор случайных чисел и функции случайного выбора.

#### Строки

Строки в Python - упорядоченные последовательности символов, используемые для хранения и представления текстовой информации, поэтому с помощью строк можно работать со всем, что может быть представлено в текстовой форме.

**Литералы строк**

Работа со строками в Python очень удобна. Существует несколько литералов строк, которые мы сейчас и рассмотрим.

```py
#Строки в апострофах и в кавычках
S = 'spam"s'
S = "spam's"
```

Строки в апострофах и в кавычках - одно и то же. Причина наличия двух вариантов в том, чтобы позволить вставлять в литералы строк символы кавычек или апострофов, не используя экранирование.

**Экранированные последовательности - служебные символы**

Экранированные последовательности позволяют вставить символы, которые сложно ввести с клавиатуры.

Экранированная последовательность | Назначение
:--------------------------------:|-----------
\n | Перевод строки
\a | Звонок
\b | Забой
\f | Перевод страницы
\r | Возврат каретки
\t | Горизонтальная табуляция
\v | Вертикальная табуляция
\N{id} | Идентификатор ID базы данных Юникода
\uhhhh | 16-битовый символ Юникода в 16-ричном представлении
\Uhhhh… | 32-битовый символ Юникода в 32-ричном представлении
\xhh | 16-ричное значение символа
\ooo | 8-ричное значение символа
\0 | Символ Null (не является признаком конца строки)

**"Сырые" строки - подавляют экранирование**

Если перед открывающей кавычкой стоит символ 'r' в любом регистре (скорее всего это сокращение от RAW), то механизм экранирования отключается.

```py
S = r'C:\newt.txt'
```

**Строки в тройных апострофах или кавычках**

Главное достоинство строк в тройных кавычках в том, что их можно использовать для записи многострочных блоков текста. Внутри такой строки возможно присутствие кавычек и апострофов, главное, чтобы не было трех кавычек подряд.

```py
c = '''это очень большая
строка, многострочный
блок текста'''
```

**Базовые операции со строками**

* Конкатенация (сложение)

```python
S1 = 'spam'
S2 = 'eggs'
print(S1 + S2)
>spameggs
```

* Дублирование (клонирование) строки

```python
print('spam' * 3)
>spamspamspam
```

* Длина строки (функция len)

```python
len('spam')
>4
```

* Доступ по индексу

```python
S = 'spam'
S[0] 
's'
S[2]
'a'
S[-2]
'a'
```

Как видно из примера, в Python возможен и доступ по отрицательному индексу, при этом отсчет идет от конца строки.

* Извлечение среза (части строки)

Оператор извлечения среза: [X:Y]. X – начало среза, а Y – окончание;

символ с номером Y в срез не входит. По умолчанию первый индекс равен 0, а второй - длине строки.

```python
s = 'spameggs'
s[3:5]
'me'
s[2:-2]
'ameg'
s[:6]
'spameg'
s[1:]
'pameggs'
s[:]
'spameggs'
```

Кроме того, можно задать шаг, с которым нужно извлекать срез.

```python
s[::-1]
'sggemaps'
s[3:5:-1]
''
s[2::2]
'aeg'
```

Необходимо помнить, что строки в Python относятся к категории неизменяемых последовательностей, то есть все функции и методы могут лишь создавать новую строку.

Поэтому все строковые методы возвращают новую строку, которую потом следует присвоить переменной.

Иногда (а точнее, довольно часто) возникают ситуации, когда нужно сделать строку, подставив в неё некоторые данные, полученные в процессе выполнения программы (пользовательский ввод, данные из файлов и т. д.). Подстановку данных можно сделать с помощью форматирования строк. Форматирование можно сделать с помощью оператора %, либо с помощью метода format.

**Форматирование строк с помощью метода format**

Если для подстановки требуется только один аргумент, то значение - сам аргумент:

```py
'Hello, {}!'.format('Vasya')
'Hello, Vasya!'
```

А если несколько, то значениями будут являться все аргументы со строками подстановки (обычных или именованных):

```python
'{0}, {1}, {2}'.format('a', 'b', 'c')
'a, b, c'
'{}, {}, {}'.format('a', 'b', 'c')
'a, b, c'
```

Однако метод format умеет большее. Полный синтаксис выходит за рамки лекции.

#### Списки

Списки в Python - упорядоченные **изменяемые** коллекции объектов произвольных типов (почти как массив, но типы могут отличаться).

Чтобы использовать списки, их нужно создать. Создать список можно несколькими способами. Например, можно обработать любой итерируемый объект (например, строку) встроенной функцией list:

```py
list('список')
['с', 'п', 'и', 'с', 'о', 'к']
```

Список можно создать и при помощи литерала:

```py
s = []  # Пустой список
l = ['s', 'p', ['isok'], 2]
```

Как видно из примера, список может содержать любое количество любых объектов (в том числе и вложенные списки), или не содержать ничего.

Нужно отметить, что методы списков, в отличие от строковых методов, изменяют сам список, а потому результат выполнения не нужно записывать в новую переменную.

```python
l = [1, 3, 2, 5, 7]
l.sort()
[1, 2, 3, 5, 7]
```

### Словари

Словари в Python - неупорядоченные коллекции произвольных объектов с доступом по ключу. Их иногда ещё называют ассоциативными массивами или хеш-таблицами.

Чтобы работать со словарём, его нужно создать. Создать его можно несколькими способами. Во-первых, с помощью литерала:

```python
d = {}
>{}

d = {'dict': 1, 'dictionary': 2}
>{'dict': 1, 'dictionary': 2}
```

Во-вторых, с помощью функции dict:

```py
d = dict(short='dict', long='dictionary')
>{'short': 'dict', 'long': 'dictionary'}

d = dict([(1, 1), (2, 4)])
>{1: 1, 2: 4}
```

В-третьих, с помощью метода fromkeys:

```python
d = dict.fromkeys(['a', 'b'])
>{'a': None, 'b': None}

d = dict.fromkeys(['a', 'b'], 100)
>{'a': 100, 'b': 100}
```

Теперь попробуем добавить записей в словарь и извлечь значения ключей:
```python
d = {1: 2, 2: 4, 3: 9}
d[1]
>2

d[4] = 4 ** 2
>{1: 2, 2: 4, 3: 9, 4: 16}

d['1']
>error
```

Как видно из примера, присвоение по новому ключу расширяет словарь, присвоение по существующему ключу перезаписывает его, а попытка извлечения несуществующего ключа порождает исключение. Для избежания исключения есть специальный метод (см. ниже), или можно перехватывать исключение.

Что же можно еще делать со словарями? Да то же самое, что и с другими объектами: встроенные функции, ключевые слова (например, циклы for и while), а также специальные методы словарей.

