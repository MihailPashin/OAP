
# Стандартная библиотека. Подключение не стандартных библиотек.

[содержание](/readme.md)  

# Стандартная Библиотека Котлин

Стандартная библиотека Kotlin предоставляет все необходимое для повседневной работы с Kotlin:

- функции высшего порядка реализации идиоматических моделей (let, with, apply, use и т. д.)
- функции расширения, обеспечивающие операции запроса для коллекций (eager) и последовательностей (lazy)
- различные утилиты для работы со строками и последовательностями символов.
- расширения для классов JDK, что делает его удобным для работы с файлами, ввода-вывода и потоковой обработки.

## let

**let** полезен при работе с объектами, которые могут принимать значение **null**. Вместо того, чтобы создавать длинные цепочки выражений **if-else**, можно просто скомбинировать оператор **?** («оператор безопасного вызова») с **let**: в результате мы получим лямбду, у которой аргумент *it* является не nullable-версией исходного объекта.

```kt
var cat: String? = null
cat?.let{ println(it) } // не выводится
cat = "Barsik"
cat?.let{ println(it) }
```

## with

Функция **with** позволяет выполнить несколько операций над одним объектом, не повторяя его имени.

Функция принимает два аргумента - объект и лямбда-выражение. Первый аргумент преобразуется в получатель лямбда-выражения. К получателю можно обращаться через this.

```kt
// выводим все буквы алфавита
fun printAlphabet() = with(StringBuilder()){
    for (letter in 'A'..'Z'){
        append(letter)
    }
    toString()
}

println(printAlphabet()) // ABCDEFGHIJKLMNOPQRSTUVWXYZ
```

Функция возвращает результат последнего выражения в теле лямбда-выражения. Если вам нужен объект-получатель, то используйте apply.

## apply

Функция **apply** работает почти так же, как **with**, но возвращает объект, переданный в аргументе.

```kt
fun printAlphabet() = StringBuilder().apply{
    for (letter in 'A'..'Z'){
        append(letter)
    }
}.toString()

println(printAlphabet())// ABCDEFGHIJKLMNOPQRSTUVWXYZ
```

Полезна в тех случаях, когда требуется создание экземпляра, у которого следует инициализировать некоторые свойства. Часто в этих случаях мы просто повторяем имя экземпляра.

```kt
button.text = "I am a button"
button.textSize = 18.0F
button.setBackgroundColor(Color.RED)
```

Инициализируем настройки кнопки через apply.

```kt
button.apply{
    text = "I am a button"
    textSize = 18.0F
    setBackgroundColor(Color.RED)
}
```

Применим к коту, поменяв возраст.


```kt
class Cat(var age: Int)

val result = Cat(5).apply { age = 8 }
println(result.age) // 8
```

## also

Метод для обмена значениями между двумя переменными без участия третьей переменной.

```kt
var x = 100
var y = 25
x = y.also { y = x }
println(x)
println(y)
```

```kt
class Cat(var age: Int)
val result = Cat(5).also { it.age = 8 }
println(result.age) // 8
```

Склеиваем строки.

```kt
val game: String = StringBuilder().also {
    it.append("tic")
    it.append("tac")
    it.append("toe")
}
        .toString()

println(game)
```

## run

Узнаем настроение кота.

```kt
fun testCat() {
    var mood = "I am sad"

    run {
        val mood = "I am happy"
        println(mood) // I am happy
    }
    println(mood)  // I am sad
}
```

```
I am happy
I am sad
```

В функции дважды используется переменная с одним именем, но они не мешают друг другу и выводят разные сообщения, не переопределяя своих значений.

## Пакеты

Файл с исходным кодом может начинаться с объявления пакета:

```
package foo.bar

fun baz() {}

class Goo {}

// ...
```

Всё содержимое файла с исходниками (например, классы и функции) располагается в объявленном пакете. Таким образом, в приведённом выше примере полное имя функции baz() будет foo.bar.baz, а полное имя класса Goo - foo.bar.Goo.

Если файл не содержит явного объявления пакета, то его содержимое находится в безымянном "пакете по умолчанию".

## Импорт

Функции или классы пакетов (встроенных в котлин или от сторонних разработчиков) становятся видны в нашем коде при импорте.

Каждый файл может содержать свои собственные объявления импорта.

Мы можем импортировать одно имя, например:

```
import foo.Bar // теперь Bar можно использовать без указания пакета
```

или доступное содержимое пространства имён (пакет, класс, объект и т.д.):

```
import foo.* // всё в 'foo' становится доступно без указания пакета
```

При совпадении имён мы можем разрешить коллизию используя ключевое слово as для локального переименования совпадающей сущности:

```
import foo.Bar // Bar доступен
import bar.Bar as bBar // bBar заменяет имя 'bar.Bar'
```

Ключевое слово import можно использовать не только с классами, но и с другими объявлениями.

## Пакет kotlin

Содержит стандартные функции и типы.

## Пакет kotlin.collections

Содержит типы для коллекций, таких как *Iterable, Collection, List, Set, Map* и функции для работы с ними.

## kotlin.comparisons

Вспомогательные функции для интерфейса *Comparator*

## kotlin.concurrent

Функции для программирования потоков (с ними мы познакомимся на следующей лекции)

## kotlin.coroutines

Базовые примитивы для создания корутин (асинхронное выполнение кода)

## kotlin.io

Функции для работы с файлами и потоками (streams, не путать с threads).

## kotlin.math

Математические функции и константы

## kotlin.random

Функции для генерации псевдо-случайных чисел

## kotlin.ranges

Функции для работы с диапазонами

## kotlin.reflect

### Рефлексия

Рефлексия — это набор возможностей языка и библиотек, который позволяет интроспектировать программу (обращаться к её структуре) во время её исполнения. В Kotlin функции и свойства первичны, и поэтому их интроспекция (например, получение имени или типа во время исполнения) сильно переплетена с использованием функциональной или реактивной парадигмы.

### Ссылки на классы

Самая базовая возможность рефлексии — это получение ссылки на Kotlin класс. Чтобы получить ссылку на статический Kotlin класс, используйте синтаксис литерала класса:

```kt
val c = MyClass::class
```

Ссылка на класс имеет тип KClass.

Обратите внимание, что ссылка на Kotlin класс это не то же самое, что и ссылка на Java класс. Для получения ссылки на Java класс, используйте свойство .java экземпляра KClass.

### Ссылки на привязанные классы

> доступно с версии Kotlin 1.1

Вы можете получить ссылку на класс определённого объекта с помощью уже известного вам синтаксиса, вызвав ::class у нужного объекта:

```kt
val widget: Widget = ...
assert(widget is GoodWidget) { "Bad widget: ${widget::class.qualifiedName}" }
```

Вы получите ссылку на точный класс объекта, например GoodWidget или BadWidget, несмотря на тип объекта, участвующего в выражении (Widget).

### Ссылки на функции

Когда у нас есть именованная функция, объявленная следующим образом:

```kt
fun isOdd(x: Int) = x % 2 != 0
```

Мы можем как вызвать её напрямую (isOdd(5)), так и передать её как значение, например в другую функцию. Чтобы сделать это, используйте оператор "::":

```kt
val numbers = listOf(1, 2, 3)
println(numbers.filter(::isOdd)) // выведет [1, 3]
```

Здесь, ::isOdd — значение функционального типа (Int) -> Boolean.

Оператор "::" может быть использован с перегруженными функциями, когда тип используемой функции известен из контекста. Например:

```kt
fun isOdd(x: Int) = x % 2 != 0
fun isOdd(s: String) = s == "brillig" || s == "slithy" || s == "tove"

val numbers = listOf(1, 2, 3)
println(numbers.filter(::isOdd)) // ссылается на isOdd(x: Int)
```

Также вместо этого вы можете указать нужный контекст путём сохранения ссылки на функцию в переменной, тип которой задан явно:

```kt
val predicate: (String) -> Boolean = ::isOdd   // ссылается на isOdd(x: String)
```

Если вы хотите использовать член класса или функцию-расширение, вам нужно обозначить это явным образом. Например, String::toCharArray даёт нам функцию-расширение для типа String: String.() -> CharArray

### Ссылки на свойства

Для доступа к свойствам как первичным объектам в Kotlin мы по-прежнему можем использовать оператор "::":

```kt
var x = 1

fun main(args: Array<String>) {
    println(::x.get()) // выведет "1"
    ::x.set(2)
    println(x)         // выведет "2"
}
```

Выражение ``::x`` возвращает объект свойства типа KProperty<Int>, который позволяет нам читать его значение с помощью get() или получать имя свойства при помощи обращения к свойству name. Для получения более подробной информации обратитесь к документации класса KProperty.

Для изменяемых свойств, например var y = 1, ``::y`` возвращает значение типа KMutableProperty<Int>.

Ссылка на свойство может быть использована там, где ожидается функция без параметров:

```kt
val strs = listOf("a", "bc", "def")
println(strs.map(String::length)) // выведет [1, 2, 3]
```

Для доступа к свойству, которое является членом класса, мы указываем класс:

```kt
class A(val p: Int)

fun main(args: Array<String>) {
    val prop = A::p
    println(prop.get(A(1))) // выведет "1"
}
```

Для функции-расширения:

```kt
val String.lastChar: Char
    get() = this[length - 1]

fun main(args: Array<String>) {
    println(String::lastChar.get("abc")) // выведет "c"
}
```

### Ссылки на конструктор

К конструкторам можно обратиться так же, как и к методам или свойствам. Они могут быть использованы везде, где ожидается объект функционального типа. Обращение к конструкторам происходит с помощью оператора **::** и имени класса. Рассмотрим функцию, которая принимает функциональный параметр без параметров и возвращает Foo:

```kt
class Foo

fun function(factory : () -> Foo) {
    val x : Foo = factory()
}
```

Используя ::Foo, конструктор класса Foo без аргументов, мы можем просто вызывать функцию таким образом:

```kt
function(::Foo)
```

### Привязанные функции

Вы можете сослаться на метод экземпляра конкретного объекта.

```kt
val numberRegex = "\\d+".toRegex()
println(numberRegex.matches("29")) // выведет "true"
```
 
```kt 
val isNumber = numberRegex::matches
println(isNumber("29")) // выведет "true"
```

Вместо вызова метода matches напрямую, мы храним ссылку на него. Такие ссылки привязаны к объектам, к которым относятся:

```kt
val strings = listOf("abc", "124", "a70")
println(strings.filter(numberRegex::matches)) // выведет "[124]"
```

Сравним типы привязанных и соответствующих непривязанных ссылок. Объект-приёмник "прикреплён" к привязанной ссылке, поэтому тип приёмника больше не является параметром:

```kt
val isNumber: (CharSequence) -> Boolean = numberRegex::matches

val matches: (Regex, CharSequence) -> Boolean = Regex::matches
```

Ссылка на свойство может быть также привязанной:

```kt
val prop = "abc"::length
println(prop.get())   // выведет "3"
```

## kotlin.text

Функции для работы с текстом и регулярными выражениями.

## kotlin.time

АПИ для представления значений типа Duration и измерение временных интервалов (экспериментальное)

# Подключение не стандартных библиотек

В лекции про INI-файлы мы уже [подключали](t4l1.md#apache_common) стороннюю библиотеку из репозитория Maven.

[содержание](/readme.md)  
