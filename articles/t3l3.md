[содержание](/readme.md)  

* Pair и Triple
* Map
* Методы основных типов данных.

# Pair и Triple

Часто требуются пары значений, как "ключ-значение". Для таких случаев выделен отдельный класс Pair. Относится к группе data class, а значит имеет методы equals(), hashCode(), component1, toString() и т.д. Также может использоваться для хранения связанных данных, например, координаты (точки x и y) и другие похожие случаи. В других языках есть похожий тип Tuple.

## Pair
Создать пару можно через ключевое слово to, а затем обращаться к элементам через first и second.

```kt
val currency = "USA" to "Dollar"
println(currency.first)
println(currency.second)
```

Можно создать одну переменную, затем к ней присоединить значение/вторую переменную.

```kt
val cat = "Барсик"
val pair = cat.to(7)
```

Можно создать пару новых переменных и присвоить им объект Pair, они автоматически заберут нужные значения из пары.

```kt
val currency = "USA" to "Dollar"
val(country, money) = currency
```

Способ объединения нескольких переменных в скобки применим и к другим классам.

Из пар можно создавать списки.

```kt
val cats = listOf("Васька" to "Москва", "Барсик" to "Мурманск")
```

Пара может быть из разных типов.

```kt
val pair = "Moscow" to 1247 // Pair<String, Int>
```

Пару можно создать явно, используя конструктор.

```kt
val pair = Pair("Moscow", 1247)
```

Если брать ситуацию с координатами, то код будет следующим (разные варианты).

```kt
val coordinates: Pair<Int, Int> = Pair(2, 3)
val coordinates = Pair(2, 3)
val coordinates = 2 to 3
```

## Triple

Класс Triple похож на Pair, но использует уже три значения.

```kt
val coordinates3D = Triple(2, 3, 1)
//val (x3, y3, z3) = coordinates3D
// или
val x3 = coordinates3D.first
val y3 = coordinates3D.second
val z3 = coordinates3D.third
```

Если вы хотите проигнорировать одно из значений, то используйте символ подчёркивания.

```kt
val coordinates3D = Triple(2, 3, 4)
val (x, y, _) = coordinates3D
```

Удобно использовать для дат.

```
val birthday = Triple(27, 7, 1996)
println("День рождения: ${birthday.first}")
println("Месяц рождения: ${birthday.second}")
println("Год рождения: ${birthday.third}")
```

# Map

Ассоциативные списки с уникальными ключами и любыми значениями (дубликаты ключей не допускаются, значения могут быть одинаковыми). Связь между ключами и значениями происходит через функцию to.

## mapOf()  
Неизменяемый Map создаётся через mapOf(). Вы не можете добавлять или удалять пару ключа и значения или обновлять значение в ключе:

```kt
val map = mapOf(1 to "one", 3 to "three", 9 to "nine")
println(map.javaClass) // class java.util.LinkedHashMap
```

Вывести содержимое коллекции можно через вызов самой переменной.

```kt
println(map)
```

В примере ключи были числами, а значения строками. Можно сделать наоборот, ключи будут строками, а значения числами.

```kt
val map = mapOf("One" to 1, "Two" to 2, "Eight" to 8)
println(map)
```

Проверить существование ключа или значения можно через containsKey() и containsValue().

```kt
map.containsKey("One")
```

Получить значение у заданного ключа можно через get() или getValue(). Если указать несуществующий ключ, то get() вернёт null, а getValue() выбросит исключение NoSuchElementException. Также можно получить значение ключа через квадратные скобки.

```kt
val map = mutableMapOf("One" to 1, "Two" to 2, "Three" to 3)

println(map.getValue("One"))
println(map["Two"])
```

Во избежание проблем с исключениями применяйте getOrElse() или getOrDefault().

```kt
// анонимная функция для несуществующего ключа
val map = mapOf("One" to 1, "Two" to 2, "Eight" to 8)
val number = map.getOrElse("One1", {"No such number"})
println(number)
```

```kt
// Значение по умолчанию
val map = mapOf("One" to 1, "Two" to 2, "Eight" to 8)
val number = map.getOrDefault("Cat", 0)
println(number)
```

Перебрать все ключи и их значения можно в цикле for.

```kt
val map = mapOf("One" to 1, "Two" to 2, "Three" to 3)
for((key, value) in map){
    println("Key is $key, value is $value")
}
```

Применим функцию отбора и преобразования.

```kt
val map = mapOf(1 to "one", 3 to "three", 9 to "nine")
println(map.mapValues { it.value.toUpperCase() })

{1=ONE, 3=THREE, 9=NINE}
```

## mutableMapOf()

Изменяемый Map.

Так как мы имеем дело с изменяемым Map, то у него есть дополнительные возможности. Например, мы можем добавить новую запись через put().

```kt
val map = mutableMapOf("One" to 1, "Two" to 2, "Three" to 3)
map.put("Four", 4)
```

Можно добавить через оператор +=. Если ключ уже существует, то его значение будет переписано.

```kt
val map = mutableMapOf("One" to 1, "Two" to 2, "Three" to 3)
map.put("Four", 4)
map += "Five" to 5
map += "Two" to 22
```

Можно сначала подготовить несколько записей для вставки и вставить их сразу через putAll():

```kt
val map = mutableMapOf("One" to 1, "Two" to 2, "Three" to 3)
val entry1 = Pair("Four", 4)
val entry2 = Pair("Five", 5)
val entryToAdd = mapOf(entry1, entry2)
map.putAll(entryToAdd)
```

Удалить запись можно по ключу через remove():

```kt
map.remove("Two")
```

Перегруженная версия remove() удалит запись только при совпадении ключа и его значения.

```kt
val map = mutableMapOf("One" to 1, "Two" to 2, "Three" to 3)
map.remove("Two", 3) // не удалит
map.remove("Three", 3) // удалит
```

Очистить все записи можно через clear(). Но сам объект остаётся.

Можно перевести в список List через toList().

```kt
val list = map.toList()
println(list)

//[(One, 1), (Two, 2), (Three, 3), (Four, 4), (Five, 5)]
```



# Методы основных типов данных.

Как уже упоминалось, все базовые типы данных в Котлине являются объектами и, соответственно, имеют методы.

## Int

https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html

### .and(*other*), .inv(*other*), .or(*other*), .xor(*other*), где *other* значение с типом Byte, Short, Int, Long  

Побитовые лперации И, НЕ, ИЛИ, исключающее ИЛИ  

```kt
1.and(2)
3.inv()
4.or(5)
```

### .dec(), .inc()  

Аналог **--** и **++**  
```kt
1.dec()
2.inc()
```

### .div(*other*), .minus(*other*), .plus(*other*), где *other* значение с типом Byte, Short, Int, Long  

```kt
2.div(2)
3.minus(4)
5.plus(6)
```

### .compareTo(*other*), где *other* значение с типом Byte, Short, Int, Long, Float, Double  

Сравнивает текущее число с указанным значением. Возвращает 0, если числа одинаковые, -1, если текущее число меньше и 1, если больше

### .rangeTo(*other*), где *other* значение с типом Byte, Short, Int, Long  

Создает диапазон от текущего числа до *other*

### .until(*other*), где *other* значение с типом Byte, Short, Int, Long  

Создает диапазон от текущего числа до *other* (не включая *other*)

### .downTo(*other*), где *other* значение с типом Byte, Short, Int, Long  

Создает убывающий диапазон от текущего числа до *other*

### .rem(*other*), где *other* значение с типом Byte, Short, Int, Long  

Вычисляет остаток от деления текущего числа на *other*

### .shl(*Int*), .shr(*Int*), .ushr(*Int*)  

Побитовый сдвиг влево и вправо, соответственно

### .rotateLeft(Int), .rotateRight(Int)  

Циклический сдвиг влево и вправо, соответственно

### .times(*other*), где *other* значение с типом Byte, Short, Int, Long, Float, Double  

Аналог умножения

### .equals(Any)  

Проверка на равенство

### .unaryMinus()  

Возвращает отрицательное текущее число 

### .hashcode(): Int  

Возвращает хэш числа

### .toByte(), .toShort(), .toLong(), .toFloat(), .toDouble(), .toString()  

Преобразует число в объект соответствующего типа

### .to(B)  

Создает пару: ``Pair<Int, B>``

### .coerceAtLeast(minimumValue: Int): Int  

Возвращает текущее число, если оно больше чем *minimumValue*, иначе возвращает *minimumValue*

### .coerceAtMost(maximumValue: Int): Int  

Возвращает текущее число, если оно меньше чем *maximumValue*, иначе возвращает *maximumValue*

### .coerceIn(min, max), coerceIn(range): Int  

Возвращает текущее число, если оно в указанном диапазоне, иначе минимальное или максимальное значение диапазона

### .absoluteValue

Геттер (не функция), возвращающий абсолютное значение текущего числа

## Числовые типы (Byte, Short, Long, Float, Double) в принципе имеют те же методы

https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html
https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte/index.html
https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-short/index.html
https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-float/index.html
https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html

