[содержание](/readme.md)  

# Шаблоны проектирования (порождающие)

>содрано [отсюда](https://tproger.ru/translations/design-patterns-simple-words-1/
)

**Шаблоны проектирования** — это руководства по решению повторяющихся проблем. Это не классы, пакеты или библиотеки, которые можно было бы подключить к вашему приложению и сидеть в ожидании чуда. Они скорее являются методиками, как решать определенные проблемы в определенных ситуациях.

Википедия описывает их следующим образом:

Шаблон проектирования, или паттерн, в разработке программного обеспечения — повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования, в рамках некоторого часто возникающего контекста.

## Будьте осторожны

* шаблоны проектирования не являются решением всех ваших проблем;
* не пытайтесь использовать их в обязательном порядке — это может привести к негативным последствиям. Шаблоны — это подходы к решению проблем, а не решения для поиска проблем;
* если их правильно использовать в нужных местах, то они могут стать спасением, а иначе могут привести к ужасному беспорядку.

## Типы шаблонов

Шаблоны бывают следующих трех видов:

* Порождающие
* Структурные
* Поведенческие

## Порождающие шаблоны

Этот тип особенно важен, когда система зависит не столько от наследования классов, сколько от [композиции](https://habr.com/ru/post/325478/) (композиция — это когда один объект предоставляет другому свою функциональность частично или полностью). Порождающие паттерны отвечают за создание объектов и позволяют системе быть независимой от типов этих самых объектов и от процесса порождения.

В свою очередь, порождающие паттерны делятся на:

* Simple Factory
* Factory Method
* Abstract Factory
* Builder
* Prototype
* Singleton

### Шаблон Simple Factory (Простая Фабрика)

В объектно-ориентированном программировании (ООП), фабрика — это объект для создания других объектов. Формально фабрика — это функция или метод, который возвращает объекты изменяющегося прототипа или класса из некоторого вызова метода, который считается «новым».

**Пример из жизни**: Представьте, что вам надо построить дом, и вам нужны двери. Было бы глупо каждый раз, когда вам нужны двери, надевать вашу столярную форму и начинать делать дверь. Вместо этого вы заказываете её на фабрике.

**Простыми словами**: Простая фабрика генерирует экземпляр для клиента, не раскрывая никакой логики.

Шаблон предназначен для инкапсуляции процесса образования объектов с помощью отдельного класса. «Простая Фабрика» удобна, но за простоту приходится платить: привязка к конкретной реализации исключает гибкость системы. *Simple Factory* следует использовать только там, где архитектура не будет изменяться.

Допустим, у нас есть интерфейс двери и класс, реализующий деревянную дверь:

```kt
interface Door {
    fun get_Width(): Float
    fun get_Height(): Float
}

class WoodenDoor(val width: Float, val height: Float) : Door {
    // вообще в котлине эти методы лишние - переменные и так видны
    // к тому же пришлось добавлять знак "_" в имена методов,
    // иначе название метода совпадает с геттером

    override fun get_Width(): Float {
        return width
    }

    override fun get_Height(): Float{
        return height
    }
}
```

Далее появляется завод, который изготавливает дверь и возвращает ее нам (в классической реализации метод makeDoor должен быть статическим, но котлин не поддерживает этот модификатор. Можно реализовать через *companion object* или *extension function*):

```kt
class DoorFactory {
    companion object{
        fun makeDoor(width: Float, height: Float): Door {
            return WoodenDoor(width, height)
        }
    }
}
```

И после этого мы можем сделать дверь на фабрике:

```kt
val door = DoorFactory.makeDoor(100F, 200F)
println("width=${door.get_Width()}, height=${door.get_Height()}")
```

Как видно из кода, вызвав статический метод (в нашем случае компаньон) ``DoorFactory.makeDoor(100F, 200F)`` мы получили не экземпляр завода, а экземпляр двери.

Вообще этот пример фабрики не очень нагляден на Котлине, есть еще пример:

```kt
class SecretiveGirl private constructor(val age: Int,
                                        val name: String = "A girl has no name",
                                        val desires: String = "A girl has no desires") {
    companion object {
        fun newGirl(vararg desires : String) : SecretiveGirl {
            return SecretiveGirl(17, desires = desires.joinToString(", "))
        }
        fun newGirl(name : String) : SecretiveGirl {
            return SecretiveGirl(17, name = name)
        }
    }
}
```

Есть класс "СтеснительнаяДевушка", который скрывает основной конструктор (private constructor) и, соответственно, возраст девушки. Это тот паттерн, при помощи которого объект контролирует процесс своей инициализации для того, чтобы скрывать какие-то секреты внутри себя.

```kt
val arya1 = SecretiveGirl.newGirl("Arry")
```

**Когда использовать**: Когда создание объекта — это не просто несколько присвоений, а какая-то логика, тогда имеет смысл создать отдельную фабрику вместо повторения одного и того же кода повсюду.

### Шаблон Fabric Method (Фабричный метод)

**Фабричный метод** — порождающий шаблон проектирования, предоставляющий подклассам интерфейс для создания экземпляров некоторого класса. В момент создания наследники могут определить, какой класс создавать. Иными словами, данный шаблон делегирует создание объектов наследникам родительского класса. Это позволяет использовать в коде программы не специфические классы, а манипулировать абстрактными объектами на более высоком уровне.

**Пример из жизни**: Рассмотрим пример с менеджером по найму. Невозможно одному человеку провести собеседования со всеми кандидатами на все вакансии. В зависимости от вакансии он должен распределить этапы собеседования между разными людьми.

**Простыми словами**: Менеджер предоставляет способ делегирования логики создания экземпляра дочерним классам.

Изначально у нас есть интерфейс Interviewer и несколько реализаций для него:

```kt
interface Interviewer {
    fun askQuestions()
}

class Developer : Interviewer {
    override fun askQuestions() = println("Спрашивает про шаблоны проектирования!")
}

class CommunityExecutive : Interviewer {
    override fun askQuestions() = println("Спрашивает о работе с сообществом")
}
```

Теперь создаем менеджера по подбору персонала:

```kt
abstract class HiringManager {
    lateinit var interviewer: Interviewer

    // Фабричный метод
    abstract fun makeInterviewer(): Interviewer

    fun takeInterview() {
        interviewer = makeInterviewer()
        interviewer.askQuestions()
    }
}
```

И теперь любой дочерний класс может расширять его и предоставлять необходимого интервьюера:

```kt
class DevelopmentManager : HiringManager() {
    override fun makeInterviewer(): Interviewer {
        return Developer()
    }
}

class MarketingManager : HiringManager() {
    override fun makeInterviewer(): Interviewer {
        return CommunityExecutive()
    }
}
```

После чего можно использовать:

```kt
fun main() {
    var devManager = DevelopmentManager()
    devManager.takeInterview() // Вывод: Спрашивает о шаблонах проектирования!

    var marketingManager = MarketingManager()
    marketingManager.takeInterview() // Вывод: Спрашивает о работе с сообществом
}
```

**Когда использовать**: Полезен, когда есть некоторая общая обработка в классе, но необходимый подкласс динамически определяется во время выполнения. Иными словами, когда клиент не знает, какой именно подкласс ему может понадобиться.

### Абстрактная фабрика (Abstract Factory)

**Абстрактная фабрика** — порождающий шаблон проектирования, предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов. Шаблон реализуется созданием абстрактного класса Factory, который представляет собой интерфейс для создания компонентов системы (например, для оконного интерфейса он может создавать окна и кнопки). Затем пишутся классы, реализующие этот интерфейс.

**Пример из жизни**: Расширим наш пример про двери из простой фабрики. В зависимости от ваших нужд вам понадобится деревянная дверь из одного магазина, железная дверь — из другого или пластиковая — из третьего. Кроме того, вам понадобится соответствующий специалист: столяр для деревянной двери, сварщик для железной двери и так далее. Как вы можете заметить, тут есть зависимость между дверьми.

**Простыми словами**: Фабрика фабрик. Фабрика, которая группирует индивидуальные, но связанные/зависимые фабрики без указания их конкретных классов.

Обратимся к коду. Используем пример про двери. Сначала у нас есть интерфейс Door и несколько его реализаций:

```kt
interface Door {
    fun getDescription()
}

class WoodenDoor : Door {
    override fun getDescription() = println("Я деревянная дверь")
}

class IronDoor : Door {
    override fun getDescription() = println("Я железная дверь")
}
```

Затем у нас есть несколько мастеров по установке для каждого типа дверей:

```kt
interface DoorFittingExpert {
    fun getDescription()
}

class Welder : DoorFittingExpert {
    override fun getDescription() = println("Я слесарь, работаю только с железными дверьми")
}

class Carpenter : DoorFittingExpert {
    override fun getDescription() = println("Я столяр, работаю только с деревянными дверьми")
}
```

Теперь нам нужна фабрика дверей, которая позволит нам создать семейство связанных объектов. То есть фабрика деревянных дверей предоставит нам деревянную дверь и эксперта по деревянным дверям. Аналогично для железных дверей:

```kt
interface DoorFactory {
    fun makeDoor(): Door
    fun makeFittingExpert(): DoorFittingExpert
}

// Деревянная фабрика вернет деревянную дверь и столяра
class WoodenDoorFactory : DoorFactory {
    override fun makeDoor(): Door {
        return WoodenDoor()
    }

    override fun makeFittingExpert(): DoorFittingExpert {
        return Carpenter()
    }
}

// Железная фабрика вернет железную дверь и сварщика
class IronDoorFactory : DoorFactory {
    override fun makeDoor(): Door {
        return IronDoor()
    }

    override fun makeFittingExpert(): DoorFittingExpert {
        return Welder()
    }
}
```

Пример использования:

```kt
fun main() {
    var woodenFactory = WoodenDoorFactory()

    var door = woodenFactory.makeDoor()
    var expert = woodenFactory.makeFittingExpert()

    door.getDescription()  // Вывод: Я деревянная дверь
    expert.getDescription() // Вывод: Я работаю только с деревянными дверями

    // Аналогично для железной двери
    var ironFactory = IronDoorFactory()

    door = ironFactory.makeDoor()
    expert = ironFactory.makeFittingExpert()

    door.getDescription()  // Вывод: Я железная дверь
    expert.getDescription() // Вывод: Я работаю только с железными дверями
}
```

Как вы можете заметить, фабрика деревянных дверей инкапсулирует столяра и деревянную дверь, а фабрика железных дверей инкапсулирует железную дверь и слесаря. Это позволило нам убедиться, что для каждой двери мы получим нужного нам установщика.

**Когда использовать**: Когда есть взаимосвязанные зависимости с не очень простой логикой создания.

### Строитель (Builder)

**Строитель** — порождающий шаблон проектирования, который предоставляет способ создания составного объекта. Предназначен для решения проблемы антипаттерна «Телескопический конструктор».

**Пример из жизни**: Представьте, что вы пришли в McDonalds и заказали конкретный продукт, например, БигМак, и вам готовят его без лишних вопросов. Это пример простой фабрики. Но есть случаи, когда логика создания может включать в себя больше шагов. Например, вы хотите индивидуальный сэндвич в Subway: у вас есть несколько вариантов того, как он будет сделан. Какой хлеб вы хотите? Какие соусы использовать? Какой сыр? В таких случаях на помощь приходит шаблон «Строитель».

**Простыми словами**: Шаблон позволяет вам создавать различные виды объекта, избегая засорения конструктора. Он полезен, когда может быть несколько видов объекта или когда необходимо множество шагов, связанных с его созданием.

Давайте я покажу на примере, что такое «Телескопический конструктор». 

```kt
class SomeClass {
    constructor(size: Float, 
                cheese: Boolean = true, 
                pepperoni: Boolean = true, 
                tomato: Boolean = false, 
                lettuce: Boolean = true) {}
}
```    

Как вы можете заметить, количество параметров конструктора может резко увеличиться, и станет сложно понимать расположение параметров. Кроме того, этот список параметров будет продолжать расти, если вы захотите добавить новые варианты. Это и есть «Телескопический конструктор».

Перейдем к примеру в коде. Адекватной альтернативой будет использование шаблона «Строитель». Сначала у нас есть Бутерброд, который мы хотим создать:

```kt
class Burger {
    protected var size: Int? = null
    protected var cheese = false
    protected var pepperoni = false
    protected var lettuce = false
    protected var tomato = false

    constructor(builder: BurgerBuilder)
    {
        size = builder.size
        cheese = builder.cheese
        pepperoni = builder.pepperoni
        lettuce = builder.lettuce
        tomato = builder.tomato
    }
}
```

Аттрибуты бутерброда приватные, мы не будем его разбирать - употребим целиком.

Затем мы берём «Строителя»:

```kt
class BurgerBuilder {
    var size: Int? = null
    var cheese = false
    var pepperoni = false
    var lettuce = false
    var tomato = false

    constructor(_size: Int) {
        size = _size
    }

    fun addPepperoni(): BurgerBuilder {
        pepperoni = true
        return this
    }

    fun addLettuce(): BurgerBuilder {
        lettuce = true
        return this
    }

    fun addCheese(): BurgerBuilder {
        cheese = true
        return this
    }

    fun addTomato(): BurgerBuilder {
        tomato = true
        return this
    }

    fun build(): Burger {
        return Burger(this)
    }
}
```

А вот у строителя аттрибуты публичные, т.к. используются при постронении бутерброда

Пример использования:

```kt
fun main() {
    var burger = BurgerBuilder(14)
        .addPepperoni()
        .addLettuce()
        .addTomato()
        .build()
}
```

**Когда использовать**: Когда может быть несколько видов объекта и надо избежать «телескопического конструктора». Главное отличие от «фабрики» — это то, что она используется, когда создание занимает один шаг, а «строитель» применяется при множестве шагов.

### Прототип (Prototype)

Задаёт виды создаваемых объектов с помощью экземпляра-прототипа и создаёт новые объекты путём копирования этого прототипа. Он позволяет уйти от реализации и позволяет следовать принципу «программирование через интерфейсы». В качестве возвращающего типа указывается интерфейс / абстрактный класс на вершине иерархии, а классы-наследники могут подставить туда наследника, реализующего этот тип.

**Пример из жизни**: Помните Долли? Овечка, которая была клонирована. Не будем углубляться, главное — это то, что здесь все вращается вокруг клонирования.

**Простыми словами**: Прототип создает объект, основанный на существующем объекте при помощи клонирования.

То есть он позволяет вам создавать копию существующего объекта и модернизировать его согласно вашим нуждам, вместо того, чтобы создавать объект заново.

В Котлине легго клонировать объекты наследуя интерфейс **Cloneable** и переопределив его метод *clone()*:

```kt
class Sheep(var name: String) : Cloneable {
    public override fun clone(): Sheep {
        try {
            return super.clone() as Sheep
        } catch(e: CloneNotSupportedException) {
            throw InternalError()
        }
    }
}

fun main() {
    var original = Sheep("Jolly")
    println( original.name ) // Jolly

    // Clone and modify what is required
    var cloned = original.clone()
    cloned.name = "Dolly"
    println(cloned.name) // Dolly
}
```

### Одиночка (Singleton)

**Одиночка** — порождающий шаблон проектирования, гарантирующий, что в однопроцессном приложении будет единственный экземпляр некоторого класса, и предоставляющий глобальную точку доступа к этому экземпляру.

**Пример из жизни**: В семье всего одна пара тапочек, одеть их может только один человек.

**Простыми словами**: Обеспечивает тот факт, что создаваемый объект является единственным объектом своего класса.

Вообще шаблон одиночка признан антипаттерном, необходимо избегать его чрезмерного использования. Он необязательно плох и может иметь полезные применения, но использовать его надо с осторожностью, потому что он вводит глобальное состояние в ваше приложение и его изменение в одном месте может повлиять на другие части приложения, что вызовет трудности при отладке. Другой минус — это то, что он делает ваш код связанным.

В котлине он встроен прямо в язык в виде ключевого слова object (Ключевое слово object одновременно объявляет класс и создаёт его экземпляр):

```kt
object JustSingleton {
    val value : String = "Just a value"
}

println(JustSingleton.value)
```

Для object вы можете задавать свойства, методы, блоки инициализации, но не можете создавать конструкторы (как основные, так и вторичные).

[содержание](/readme.md)  

