## ООП. Наследование.

**Теоретическое введение.** Важнейшим принципом ООП является наследование. Класс, который наследуется, называется базовым классом, а наследующий класс – производным классом (субкласс, потомок и т.п.).

Классы, объекты, интерфейсы, конструкторы, функции, свойства и их сеттеры могут иметь **модификаторы доступа** (у геттеров всегда такая же видимость, как у свойств, к которым они относятся). В Kotlin предусмотрено четыре модификатора доступа: *private*, *protected*, *internal* и *public*. Если явно не используется никакого модификатора доступа, то по умолчанию применяется *public*.

* private означает видимость только внутри этого класса;
* protected — то же самое, что и private + видимость в субклассах;
* internal — любой клиент внутри модуля, который видит объявленный класс, видит и его internal члены;
* public — любой клиент, который видит объявленный класс, видит его public члены.

Для явного объявления суперкласса мы помещаем его имя за знаком двоеточия в оглавлении класса:

```kt
open class Base(p: Int)

class Derived(p: Int) : Base(p)
```

Обратите внимание: у базового класса используется модификатор **open**, это означает, что от него можно наследоваться. По-умолчанию классы имеют модификатор **final** - наследование запрещено.

Однако класс и некоторые его члены могут быть объявлены как **abstract**. Абстрактный член не имеет реализации в своём классе. Обратите внимание, что нам не надо аннотировать абстрактный класс или функцию словом open - это подразумевается и так.

При выполнении данного задания необходимо определить базовый класс и производные от него классы. Предусмотреть передачу аргументов конструкторам базового класса; использование перегруженных функций; обработку исключительных ситуаций.

---

**Пример:**

Создать три класса: **Point** (базовый класс – **Точка**), **Ellipse** (производный класс от класса Point – **Эллипс**) и **Cylinder** (производный класс от класса Ellipse – **Цилиндр**).

Для класса **Point** определить свойства для координаты точки, метод *Move* (перемещение) и метод *pointInFigure* (принадлежность точки фигуре)

Для класса **Ellipse** добавить свойства *большая и малая полуоси* и переопределить метод *pointInFigure*

Для класса **Cylinder** добавить свойство *высота* и переопределить метод *pointInFigure*

**Реализация:**

Класс **Точка** имеет основной конструктор, в котором объявлены protected свойства (кординаты точки), метод *pointInFigure* и метод *move* переносящий координаты объекта (метод без модификатора **open** - переопределить в потомке его нельзя)

```kt
// вспомогательный data class для точки
data class Coord(val x: Int, val y: Int)

// класс Точка
open class Point(protected var x: Int, protected var y: Int) {
    open fun pointInFigure(r: Coord): Boolean{
        return x==r.x && y==r.y
    }

    fun move(dx: Int, dy: Int){
        x+=dx; y+=dy
    }
}

val r = Coord(0, 0)

val p = Point(0, 0)
println( p.pointInFigure(r) ) // true

p.move(-1,-1)
println( p.pointInFigure(r) ) // false
```

У **Эллипса** координаты центра передаются в базовый класс и переопределяется метод *pointInFigure*

>Каноническое уравнение эллипса: x^2/a^2 + y^2/b^2 = 1, где a и b - полуоси

```kt
open class Ellipse(x: Int, y: Int, protected val a: Int, protected val b: Int): Point(x,y){
    override fun pointInFigure(r: Coord): Boolean {
        val res = (r.x - x).toDouble().pow(2.0) / a.toDouble().pow(2.0) +
                  (r.y - y).toDouble().pow(2.0) / b.toDouble().pow(2.0)
        return res<=1
    }
}
```

Для **Цилиндра** добавляется высота и переопределяется метод *pointInFigure* 

```kt
class Cylinder(x: Int, y: Int, a: Int, b: Int, private val h: Int): Ellipse(x,y,a,b){
    override fun pointInFigure(r: Coord): Boolean {
        // эллипс в основании цилиндра (используем метод базового класса)
        val res1 = super.pointInFigure(r)

        // эллипс на вершине цидиндра (сдвигаем y на высоту h)
        val res2 = (r.x - x).toDouble().pow(2.0) / a.toDouble().pow(2.0) +
                (r.y - y + h).toDouble().pow(2.0) / b.toDouble().pow(2.0)

        // прямоугольник, образуемый большими полуосями цилиндров
        val res3 = r.x>=(x-a) && r.x<=(x+a) && r.y>=y && r.y<=(y+h)

        return res1<=1 || res2<=1 || res3
    }
}
```

---

В следующих заданиях требуется создать базовый класс (как вариант абстрактный базовый класс) и определить общие методы *show()*, *get()*, *set()* и другие, специфические для данного класса. Создать производные классы, в которые добавить свойства и методы. Часть методов базового класса переопределить. 

>Реализовать одно задание, номер которого соответствует последней цифре вашего телефона

1. Создать базовый класс **Транспортное средство** и производные классы **Автомобиль**, **Велосипед**, **Повозка**. Подсчитать время и стоимость перевозки пассажиров и грузов каждым транспортным средством.

2. Создать базовый класс **Грузоперевозчик** и производные классы **Самолет**, **Поезд**, **Автомобиль**. Определить время и стоимость перевозки для указанных городов и расстояний.

3. Создать аналогичный базовый класс **Пассажироперевозчик** и производные классы **Самолет**, **Поезд**, **Автомобиль**. Определить время и стоимость передвижения.

4. Изменить задания 1–3, чтобы базовый класс стал абстрактным. Сделать некоторые методы абстрактными.

5. Создать базовый класс **Учащийся** и производные классы **Школьник** и **Студент**. Создать массив объектов базового класса и заполнить этот массив объектами. Показать отдельно студентов и школьников.

6. Создать базовый класс **Музыкальный инструмент** и производные классы **Ударный**, **Струнный**, **Духовой**. Создать массив объектов **Оркестр**. Выдать состав оркестра, переопределив метод.

7. Создать абстрактный класс **Работник фирмы** и производные классы **Менеджер**, **Администратор**, **Программист**.

9. Создать базовый класс **Домашнее животное** и производные классы **Собака**, **Кошка**, **Попугай** и др. С помощью конструктора установить имя каждого животного и его характеристики.

0. Создать базовый класс **Садовое дерево** и производные классы **Яблоня**, **Вишня**, **Груша** и др. С помощью конструктора автоматически установить номер каждого дерева. Принять решение о пересадке каждого дерева в зависимости от возраста и плодоношения.
