[содержание](/readme.md)  

# Работа с файлами.

## Типы файлов.

В контексте изучения программирования файлы делятся на три типа:

* Текстовые файлы. У них нет постоянной длины записи. Текстовые данные записываются/читаются порциями - строками, где разделителем служит перевод строки (в MSDOS и Windows - это пара символов #13#10)

* Типизированные файлы - когда в файле хранятся одинаковые структуры данных, заранее определенные (либо программистом, либо форматом файла). В принципе любой файл можно рассматривать как типизированный со структурой данных равной одному байту.

* Нетипизированные файлы. Информация в них хранится разными блоками, обычно в начале файла есть заголовок, где описаны свойства и размеры блоков.

Скорость работы с текстовыми файлами ниже, потому что ядро (а мы понимаем, что для компьютера все файлы просто набор байтов) языка программирования вынуждено считывать промежуточный буфер, в котором искать конец строки, а если он не найден в этом буфере, то подгружать еще один (или несколько) и склеивать из них результирующую строку. Все эти накладные расходы и влияют на скорость.

В старой литературе пишут, что доступ к нетипизированным файлам быстрее, чем к остальным (видимо из-за того что в типизированных файлах структура может быть небольшой и постоянно приходится перечитывать одно и то же место, чтобы достать очередной блок), но на практике все операции с диском кэшируются и вряд ли вы заметите эту разницу.

## Организация доступа к файлам.

Для использования информации, хранимой в файлах, она должна быть считана в память компьютера. Есть несколько способов доступа к файлам.

Ранние ОС давали только один способ доступа – последовательный (перфолента, магнитная лента). Записи считывались в порядке поступления. Текущая позиция считывания могла быть возвращена к началу файла (rewind), но операция эта очень медленная.

Вместе с магнитными барабанами и дисками появились файлы с прямым (random) доступом. Для специфицирования места, с которого надо начинать чтение используются два способа: с начала, или с текущей позиции, которую дает операция *seek*.

## Файлы последовательного доступа

В питоне многие объекты являются файлами: стандартный ввод sys.stdin, стандартный вывод sys.stdout, каналы (pipes).

```py
import sys
text = sys.stdin.read() # аналог input()
sys.stdout.write(text)  # аналог print()
```

## Файловый объект в Python

В Python работа с файлами осуществляется через специальный абстрактный файловый объект. В зависимости от способа создания такого объекта, он может быть привязан как к физическому файлу на диске, так и другому устройству, поддерживающему схожие операции (стандартный ввод/вывод и пр.).

Стандартный способ создания файлового объекта - функция open():

``open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)``

Открывает файл и возвращает файловый объект. Если файл не может быть открыт, возбуждается исключение OSError и его потомки (FileNotFoundError и др.).

Некоторые из параметров:

* file – путь к файлу (например, строка) или файловый дескриптор;
* mode – режим открытия файла:

Символ | Описание
:-----:|---------
'r'	| Открыть для чтения (по умолчанию)
'w'	| Открыть для записи (если файл существует, то очищается)
'x'	| Открыть для создания с эксклюзивными правами (ошибка, если файл существует)
'a'	| Открыть для добавления (если файл существует)
'+'	| Открыть для чтения и записи
't'	| Текстовый режим (по умолчанию)
'b'	| Двоичный режим

Двоичный/текстовый режимы могут быть скомбинированы с другими: например, режим 'rb' позволит открыть на чтение бинарный файл;

* encoding – наименование кодировки, используемой при чтении/записи файла (например, 'utf-8'); параметр имеет смысл только для текстового режима.

>**Кодировка файла**
>
>При открытии файла Python по умолчанию использует кодировку, предпочитаемую операционной системой. Для определения кодировки по умолчанию выполните код:
>
>```py 
>import locale
>locale.getpreferredencoding(False)  # 'cp1251' на российской сборке ОС Windows``
>```
>Старайтесь указывать кодировку файла явно, например, encoding="utf-8", особенно если есть вероятность работы программы на различных ОС.

Открытие файлов связано с потреблением/резервированием ресурсов, поэтому после выполнения необходимых операций его следует закрыть.

``close()``

Закрывает файл. После этого работа с файлом невозможна (чтение, запись и др.).

Общий цикл работы с файлом может выглядеть следующим образом:

```py
# При работе с файлами всегда целесообразно использовать исключения

fh = None
try:
    fh = open("data.txt", encoding="utf-8")
    #
    # Чтение и запись файла
    #
except Exception as e:
    print("Ошибка при работе с файлом:", e)
finally:
    if fh:  # Если файл не открылся, значит 'fh' == None и закрывать его не нужно
        fh.close()
```

Для упрощения кода по выделению и высвобождению ресурсов в Python предусмотрены специальные объекты - менеджеры контекста, которые могут самостоятельно следить за использованием ресурсов Наиболее часто менеджеры контекста вызываются с использованием ключевого слова with

```py
try:
    with open("data2.txt", encoding="utf-8") as fh:
        #
        # Чтение и запись файла
        #
except Exception as e:
    print("Ошибка при работе с файлом:", e)
```

>В большинстве примеров данной темы подробная обработка исключений опущена для того, чтобы сосредоточиться на демонстрации конкретных возможностей.
>
>При самостоятельном написании программ не следует забывать добавлять обработку исключений - программа должна адекватно реагировать на возможные нестандартные ситуации (используемые файлы может изменить пользователь или другая программа).

## Основные свойства и методы работа с файлами

Файловый объект предоставляет ряд свойств и методов для работы с файлами. Большинство методов универсально и предполагают работу (чтение/запись) со строками в указанной кодировке (str для текстовых файлов) или с набором байт (bytes для двоичных файлов).

* **name** - Имя файла (если имеется)
* **encoding** - Кодировка, используемая для *строковых* преобразований в файле.
* **closed** - Возвращает True, если файл закрыт.
* **close()** - Закрывает файл. После этого работа с файлом невозможна (чтение, запись и др.).
* **read(count)** - Читает до *count* байт из файлового объекта. Если значение *count* не определено, то читаются все байты, начиная от текущей позиции и до конца.</br>
Если ничего не было прочитано (конец файла), возвращается пустой объект str или bytes.
* **readline(count)** - Читает следующую строку (до count байт, если значение count определено и число прочитанных байтов было достигнуто раньше, чем встретился символ перевода строки '\n'), включая символ перевода строки '\n'.
* **readlines()** - Читает все строки до конца файла и возвращает их в виде списка.
* **write(s)** - Записывает в файл объект s типа:<br/>
str для текстового режима;</br>
bytes / bytearray для двоичного режима.
* **writelines(seg)** - Записывает в файл последовательность объектов типа:</br>
str для текстового режима;</br>
bytes / bytearray для двоичного режима.</br>
* **flush()** - При работе с файлами Python по умолчанию использует буфер определенного размера. Вызов методов записи приводит к записи в буфер, после чего в определенный момент производится очистка буфера и передача сигнала для записи данных на диск.</br>
Метод flush() вызывает принудительное очистку буфера. В большинстве случаев вызывать его напрямую не нужно.

Пример работы с двоичным файлом (пример на самом деле плохой, данные хранятся не структирированными и в текстовом виде)

```py
human = dict(name="Михаил Толстых", age=35, weight=90.5)
filename = "08_01_02_data.txt"

# 1. Запись в файл
#    При записи бинарных файлов все данные должны быть преобразованы в тип bytes
#    Удобно выполнить преобразование через метод str.encode()
fh = open(filename, "wb")
fh.write(bytes(human["name"].encode("utf-8")))
fh.write(bytes(str(human["age"]).encode("utf-8")))
fh.write(bytes(str(human["weight"]).encode("utf-8")))
fh.close()

# 2. Чтение из файла
#    При чтении бинарных файлов необходимо точно знать, сколько байт
#    прочитать и как их декодировать, используя bytes.decode()
#    При редактировании файла в стороннем редакторе файл может быть не читаем
fh = open(filename, "rb")
name = fh.read(27).decode("utf-8")
age = int(fh.read(2).decode("utf-8"))
weight = float(fh.read(4).decode("utf-8"))
print(name, age, weight)  # Михаил Толстых 35 90.5
fh.close()
```

Пример работы с текстовым файлом:

```py
human = dict(name="Михаил Толстых", age=35, weight=90.5)
filename = "08_01_03_data.txt"

# 1. Запись в файл
#    При записи текстовых файлов все данные должны быть преобразованы в тип str
#    По умолчанию, write() не добавляет перенос строки, однако его можно добавить самостоятельно
fh = None
try:
    fh = open(filename, "w", encoding="utf-8")
    # При добавлении переноса записываемые данные будут на отдельной строке
    fh.write(human["name"] + "\n")
    fh.write(str(human["age"]) + "\n")
    # Как альтернатива - print() позволяет не переводить в строку и не добавлять перенос вручную
    print(human["weight"], file=fh)
finally:
    if fh:
        fh.close()

# 2. Чтение из файла
#    Для чтения отдельной строки достаточно вызвать метод readline().
#    В конце полученной строки знак переноса - \n,
#    который можно убрать, например, методом str.strip()
fh = None
try:
    fh = open(filename, encoding="utf-8")
    # Читаем первые 3 строки и преобразуем при необходимости
    name = fh.readline().strip()
    age = int(fh.readline())
    weight = float(fh.readline())
    print(name, age, weight)  # Михаил Толстых 35 90.5
finally:
    if fh:
        fh.close()
```

## Сериализация и десериализация

Чтение/запись простых типов (например, чисел или строк) не представляет большого труда, однако с увеличением объема информации появляется необходимость эффективно сохранять/загружать более сложные структуры данных (например, словари). Кроме того,модульная архитектура современного программного обеспечения приводит к необходимости обмена данными между различными модулями, а также между приложениями в целом, для чего необходимо иметь возможность удобно обмениваться данными.

**Сериализация** — процесс перевода какой-либо структуры данных в последовательность битов. **Десериализация** — обратный процесс.

Чаще всего сериализация используется для сохранения объектов в файлы или передачи их по сети.

## Популярные форматы файлов

Большое количество данных в совокупности с их разнородностью привело к появлению специальных форматов файлов, позволяющих хранить различные объемы связанной информации и не привязанных к конкретному языку программирования.

Среди них одними из наиболее популярных являются:

* CSV (англ. Comma-Separated Values - значения, разделенные запятыми);
* JSON (англ. JavaScript Object Notation) - текстовый формат обмена данными, основанный на JavaScript;
* XML (англ. eXtensible Markup Language - расширяемый язык разметки);
* INI (англ. Initialization file - файл инициализации);

Подавляющее большинство форматов поддерживается Python (стандартными или сторонними модулями и пакетами).

## CSV

CSV (англ. Comma-Separated Values - значения, разделенные запятыми, 2005 г.) - текстовый формат, предназначенный для представления табличных данных. Каждая строка файла - это одна строка таблицы, где значения отдельных колонок разделяются разделительным символом (англ. delimiter) запятой ",". Значения содержащие запятую заключаются в кавычки: "запятая служебный символ, но в кавычках не считается" 

Несмотря на наличие стандарта (RFC 4180), на сегодняшний день под CSV, как правило,понимают набор значений, разделенных произвольными разделителями, в произвольной кодировке с произвольными окончаниями строк. Это значительно затрудняет перенос данных из одних программ в другие, несмотря на всю простоту реализации поддержки CSV (так, например, Microsoft Excel не всегда открывает стандартные разделенные запятыми данные).

В Python работа с CSV-файлами поддерживается стандартным модулем csv, предоставляющем следующие основные объекты и функции:

``csv.reader(csvfile, dialect='excel', **fmtparams)``

Создает и возвращает объект для чтения последовательности из CSV-файла.

Параметры:	
* csvfile – итерируемый объект, возвращающий строку на каждой итерации (например, файловый объект в текстовом режиме доступа);
* dialect – диалект CSV (набор специальных параметров);
* fmtparams – дополнительные настройки (совокупность кавычек, разделителей и т.д.).

```py
import csv
 
csv_path = "data.csv"
with open(csv_path, "r") as f_obj:
    reader = csv.reader(f_obj)
    for row in reader:
        print(" ".join(row))
```

``csv.writer(csvfile, dialect='excel', **fmtparams)``

Создает и возвращает объект для записи последовательности в CSV-файл.

Параметры:	
* csvfile – любой объект, поддерживающий метод записи write();
* dialect – аналогично csv.reader();
* fmtparams – аналогично csv.reader().

```py
import csv

data = ["first_name,last_name,city".split(","),
        "Tyrese,Hirthe,Strackeport".split(","),
        "Jules,Dicki,Lake Nickolasville".split(","),
        "Dedric,Medhurst,Stiedemannberg".split(",")
        ]

path = "output.csv"
with open(path, "w", newline='') as csv_file:
    writer = csv.writer(csv_file, delimiter=',')
    for line in data:
        writer.writerow(line)
```

## JSON

JSON (англ. JavaScript Object Notation, 1999 г.) - текстовый формат обмена данными,основанный на JavaScript. Одно из преимуществ - JSON легко читается людьми (англ. human-readable)

Пример JSON-файла
```json
{
	"ФИО": "Иванов Сергей Михайлович",
	"ЕГЭ": {
		"Математика": 90,
		"Физика": 70,
		"Информатика": 80
	},
	"Хобби": ["Рисование", "Плавание"],
	"Возраст": 25.5,
	"ДомЖивотные": null
}
```

JSON-текст представляет собой одну из двух структур:
* набор пар "ключ: значение" (словарь в терминологии Python), где ключ - строка, значение - любой тип;
* упорядоченный набор значений (список в терминологии Python).

Значением может являться:
* строка (в кавычках);
* число;
* логическое значение (true/false);
* null;
* одна из структур.

Одним из преимуществ JSON является близкое соответствие Python по типам данных. Работа с JSON-форматом поддерживается стандартным пакетом json, предоставляющем следующие основные функции:

``json.dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)``</br>

Сериализует объект obj, возвращая строку в JSON-формате.

Параметры:	
* obj – сериализуемый объект;
* ensure_ascii – если равен False, запись не-ASCII значений происходит в файл «как есть», без преобразования в Unicode;
* indent – величина отступа для вложенных структур.

``json.loads(s, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)``

Десериализует объект (в том числе файловый) s, возвращая структуру в Python.

При ошибке десериализации возбуждается исключение JSONDecodeError.

``exception json.JSONDecodeError(msg, doc, pos, end=None)``

Класс исключения, возбуждаемый при ошибке в работе некоторых функций пакета.

Работа с JSON-форматом в Python
```py
import json

filename = "data.json"

info = {
    "ФИО": "Иванов Сергей Михайлович",
    "ЕГЭ": {
        "Математика": 90,
        "Физика": 70,
        "Информатика": 80
    },
    "Хобби": ["Рисование", "Плавание"],
    "Возраст": 25.5,
    "ДомЖивотные": None
}

# Запись структуры в файл в JSON-формате
with open(filename, "w", encoding="utf-8") as fh:
    fh.write( json.dumps(info, ensure_ascii=False, indent=4) )
```

Пример содержимого файла:
```json
{
    "Хобби": [
        "Рисование",
        "Плавание"
    ],
    "ЕГЭ": {
        "Информатика": 80,
        "Математика": 90,
        "Физика": 70
    },
    "ФИО": "Иванов Сергей Михайлович",
    "ДомЖивотные": null,
    "Возраст": 25.5
}
```

Чтение из файла JSON-формата

```py
info_2 = []
with open(filename, encoding="utf-8") as fh:
    info_2 = json.loads(fh.read())

print(info_2)
# {'ФИО': 'Иванов Сергей Михайлович', 'ЕГЭ': {'Информатика': 80, 'Математика': 90, 'Физика': 70},
#  'Хобби': ['Рисование', 'Плавание'], 'Возраст': 25.5, 'ДомЖивотные': None}
```

>Примечание
>
>Валидация и оформление JSON-файлов
>
>При возникновении ошибки чтения файла JSON-формата рекомендуется проверить его синтаксис с использованием специальных онлайн-сервисов, например, https://jsonformatter.curiousconcept.com/, которые могут как указать место ошибки, так и оформить его по стандарту.

## INI

Очень часто программам нужно где-то хранить настройки, желательно в текстовом виде,чтобы пользователь мог их менять. CSV для этой цели не подходит, он "заточен" под базы данных. JSON всем хорош, но у него нет "защиты от дурака". Не поставленная запятая или кавычка приведут к тому, что программа не сможет преобразовать его в объект (в словарь в нашем случае).

Для хранения настроек в текстовом виде используют .ini файлы, они легко читаются и правятся человеком, хотя в них трудно сохранить сложную структуру данных.

Формат этот очень старый, в Windows он сейчас практически вытеснен реестром, но в Линуксах до сих пор повсеменно используется.

Библиотека в ядре Python включает в себя модуль, под названием configparser, который вы можете использовать для создания и работы с файлами конфигурации.

### Создание ini-файла

Создание ini-файла при помощи configparser невероятно просто. 

```py
import configparser
 
def createConfig(path):
    """
    Create a config file
    """
    config = configparser.ConfigParser()
    config.add_section("Settings")
    config.set("Settings", "font", "Courier")
    config.set("Settings", "font_size", "10")
    config.set("Settings", "font_style", "Normal")
    config.set("Settings", "font_info",
               "You are using %(font)s at %(font_size)s pt")
    
    with open(path, "w") as config_file:
        config.write(config_file)
 
 
if __name__ == "__main__":
    path = "settings.ini"
    createConfig(path)
```

Данный код создает файл settings.ini с одной секцией, под названием Settings, которая будет содержать наши опции: font, font_size, font_style и font_info.

```ini
[Settings]
font=Courier
font_size=10
font_style=Normal
font_info=You are using Courier at 10 pt
```

### Как читать, обновлять и удалять опции

Теперь мы готовы к тому, что бы научиться чтению ini-файла, обновлять его опции и даже удалять их. В нашем случае учиться будет намного проще, если мы попробуем на практике написать какой-нибудь код. Просто добавьте следующую функцию в код, который вы писали ранее.

```py
import configparser
import os
 
def crudConfig(path):
    """
    Create, read, update, delete config
    """
    if not os.path.exists(path):
        createConfig(path)
    
    config = configparser.ConfigParser()
    config.read(path)
    
    # Читаем некоторые значения из конфиг. файла.
    font = config.get("Settings", "font")
    font_size = config.get("Settings", "font_size")
    
    # Меняем значения из конфиг. файла.
    config.set("Settings", "font_size", "12")
    
    # Удаляем значение из конфиг. файла.
    config.remove_option("Settings", "font_style")
 
    # Вносим изменения в конфиг. файл.
    with open(path, "w") as config_file:
        config.write(config_file)
 
 
if __name__ == "__main__":
    path = "settings.ini"
    crudConfig(path)
```

Этот код сначала проверяет, существует ли ini-файл в принципе. Если его нет, то он использует созданную нами ранее функцию createConfig, чтобы создать файл. Далее мы создаем объект ConfigParser и указываем путь к файлу для чтения. Чтобы прочесть опцию в вашем config файле, мы вызываем метод нашего объекта ConfigParser, указываем ему наименование секции и опции.

Это вернет значение параметра. Если вы хотите изменить значение опции, вам нужно использовать метод set, в котором вы указываете название секции, опции, и новое значение. Наконец, мы можем использовать метод remove_option, чтобы удалить опцию. В нашем примере мы изменили значение font_size, и задали ему размер 12, затем мы удалили опцию font_style. После этого мы записали наши изменения на диск. 

Если же вспомнить одну из предыдущих лекций, где мы говорили о правилах написания "правильных" функций, то код лучше разделить на более простые функции, каждая из которых делает что-то одно:

```py
import configparser
import os
 
 
def create_config(path):
    """
    Create a config file
    """
    config = configparser.ConfigParser()
    config.add_section("Settings")
    config.set("Settings", "font", "Courier")
    config.set("Settings", "font_size", "10")
    config.set("Settings", "font_style", "Normal")
    config.set("Settings", "font_info",
                "You are using %(font)s at %(font_size)s pt")
    
    with open(path, "w") as config_file:
        config.write(config_file)
 
 
def get_config(path):
    """
    Returns the config object
    """
    if not os.path.exists(path):
        create_config(path)
    
    config = configparser.ConfigParser()
    config.read(path)
    return config
 
 
def get_setting(path, section, setting):
    """
    Print out a setting
    """
    config = get_config(path)
    value = config.get(section, setting)
    return value
 
 
def update_setting(path, section, setting, value):
    """
    Update a setting
    """
    config = get_config(path)
    config.set(section, setting, value)
    with open(path, "w") as config_file:
        config.write(config_file)
 
 
def delete_setting(path, section, setting):
    """
    Delete a setting
    """
    config = get_config(path)
    config.remove_option(section, setting)
    with open(path, "w") as config_file:
        config.write(config_file)
 
 
if __name__ == "__main__":
    path = "settings.ini"
    font = get_setting(path, 'Settings', 'font')
    print("Settings font_size is %s" % font_size)

    font_size = get_setting(path, 'Settings', 'font_size')
    print("Settings font_size is %s" % font_size)

    update_setting(path, "Settings", "font_size", "12")
    delete_setting(path, "Settings", "font_style")
```

Этот пример выглядит более организованно, по сравнению с первым. Каждая функция должна объяснять сама себя и выполнять лишь одну задачу. Вместо того, чтобы помещать всю логику в одну единственную функцию, мы разделяем её на несколько функций, после чего демонстрируем их функционал в конце оператора if. Теперь вы можете импортировать модуль и использовать по назначению. 

Может показаться, что файл слишком часто открывается/закрываеся. Но, как я уже упоминал, в современных ОС дисковые операции кэшируются и файл с большой вероятностью в итоге будет открыт и закрыт всего один раз.

## Работа с файловой системой

Прежде чем попытаться прочитать какой-то файл, нужно узнать есть ли он на диска. А перед записью убедиться, что пишем в нужный нам каталог.

Стандартный модуль **os** имеет интерфейс работы с файловой системой. 

**Текущий каталог** - каталог, в котором программа будет открывать файлы, если в названии файла не указан абсолютный путь к нему. Обычно каталог, в котором прграмму запустили.

Функция os.getcwd возвращает текущий каталог:
```py
import os

cwd = os.getcwd()
print(cwd)
```

Проверить наличие файла в текущем каталоге:
```py
os.path.exists('my_file')
```

Вывести список файлов и подкаталогов для данного каталога:
```py
os.listdir(path)
```

Следующий пример рекурсивно выводит список всех файлов и подкаталогов для текущего каталога:
```py
import os

def walk(dir):
  for name in os.listdir(dir):
    path = os.path.join(dir, name)
    if os.path.isfile(path):
        print(path)
    else:
        walk(path)

walk(os.getcwd())
```

В следующем примере мы получим статистическую информацию о текущем каталоге: общий размер каталога в байтах, число файлов, число подкаталогов. Стандартная функция os.path.walk имеет три параметра: каталог, пользовательская функция, список для подсчета:

```py 
import os, sys

def getlocaldata(sms, dr, flst):
   for f in flst:
      fullf = os.path.join(dr,f)
      if os.path.islink(fullf): continue # don't count linked files
      if os.path.isfile(fullf):
          sms[0] += os.path.getsize(fullf)
          sms[1] += 1
      else:
          sms[2] += 1

def dtstat(dtroot):
   sums = [0,0,1] # 0 bytes, 0 files, 1 directory so far
   os.path.walk(dtroot, getlocaldata, sums)
   return sums
 
report = dtstat('.') # '.' обозначает текущий каталог
print(report)
```

В следующем примере сделана интерпретация системной утилиты grep. В текущем каталоге будут найдены файлы с питоновским расширением, в которых будет найдена поисковая строка 'import os':

```py
import os, sys, fnmatch
 
mask = '*.py'
pattern = 'import os'
 
def walk(arg,dir,files):
   for file in files:
     if fnmatch.fnmatch(file,mask):
        name = os.path.join(dir,file)
        try:
          data = open(name,'rb').read()
          if data.find(pattern) != -1:
            print name
        except:
            pass    

os.path.walk('.', walk, [])
```

## Произвольный доступ

Открывать и закрывать файлы мы уже научились. Научились читать построчно и даже весь файл целиком. Но в реальной жизни чаще приходится работать c двоичными файлами и их объем может превышать объем ОЗУ, например базы данных. И для таких файлов возникает необходимость постоянно перемещаться из одной части файла в другую (индексы баз данных).  

В этом случае нам поможет метод **seek**.

``seek(offset[, whence=0]->int``

* offset – смещение в байтах, может быть отрицательным (если смещение идет с середины файла или с конца);
* whence – указывает откуда брать смещение, с начала файла (0), с текущей позиции (1) или с конца файла (2).

Этот метод перемещает позицию чтения (или записи) в нужную нам сторону на нужное количество **байт**.

Возвращает новую позицию в файле.

Функция ``tell()->int`` возвращает текущую позицию файла.

## Бинарные файлы

Стандартный модуль *struct* позволяет преобразовывать объекты в структуры Си в виде строк в бинарном формате и обратно. Данные в строке располагаются в соответствии со строкой формата. Эти возможности могут быть использованы для чтения и сохранения в двоичном формате.

### Функции модуля struct:

``pack(format, value1, value2 ...)->bytes``

Возвращает байтовую строку, содержащую значения value1, value2 ..., упакованные в соответствии с форматом. Количество и тип аргументов должны соответствовать значениям, которые требует строка формата format.

**Format** состоит из спецификаторов, определяющих как интерпретировать значение.

Спецификаторы, определяющие порядок, размер и Alignment байт

Спецификатор | Порядок | Размер | Alignment
:-----------:|---------|--------|----
@  | Native | native | native
=  | Native | standard | none
<  | little-endian | standard | none
\> | big-endian | standard | none
!  | network (big-endian) | standard | none

Если ни один из этих спецификаторов не задан, то по-умолчанию используется "@"

**Порядок** *native* - означает стандартный для текущей платформы (для intel это little-endian)

>Native byte order is big-endian or little-endian, depending on the host system. For example, Intel x86 and AMD64 (x86-64) are little-endian; Motorola 68000 and PowerPC G5 are big-endian; ARM and Intel Itanium feature switchable endianness (bi-endian). Use sys.byteorder to check the endianness of your system.

**Размер** может быть либо стандартным, либо в зависимости от настроек компилятора.


Спецификатор | тип (Си) | тип Питон | Стандартный размер
:-----------:|----------|---|---
цифра | количество повторений или длина | no value |  | 
с | char | bytes размером 1 байт | 1
b | знаковый байт | integer | 1
B | беззнаковый байт | integer | 1
? | логический | bool | 1
h | знаковое короткое | integer | 2
H | беззнаковое короткое | integer | 2
i | знаковое целое | integer | 4
I | беззнаковое целое | integer | 4
l | знаковое длинное | integer | 4
L | беззнаковое длинное | integer | 4
q | знаковое очень длинное | integer | 8
Q | беззнаковое очень длинное | integer | 8
e | single | float | 2
f | число с плавающей точкой | float | 4
d | число с плавающей точкой двойной точности | float | 8
p | char[] | bytes |
s | char[] | bytes | 
P | void*  | pointer | |

Как видим, спецификаторов больше чем типов в Питоне.

```py
from struct import *
# упаковываем три числа, два знаковых коротких и одно знаковое длинное
pack('hhl', 1, 2, 3)
# я выделил числа пробелами для наглядности, 
# на самом деле пробелов тут нет, конечно
>b'\x00\x01 \x00\x02 \x00\x00\x00\x03'
```

``unpack(format, buffer)->tuple``

Распаковывает *buffer* в соответствии с форматом *format* и возвращает кортеж объектов.

Распаковываемы поля могут быть именованными (для использования с именованным кортежем).

```py
# исходная байтовая строка
record = b'raymond   \x32\x12\x08\x01\x08'
# распаковываем в кортеж: 10 смволов, два беззнаковых коротких и байт
name, serialnum, school, gradelevel = unpack('<10sHHb', record)

from collections import namedtuple
Student = namedtuple('Student', 'name serialnum school gradelevel')
Student._make(unpack('<10sHHb', record))
>Student(name=b'raymond   ', serialnum=4658, school=264, gradelevel=8)
```

``calcsize(format)->int``

Возвращает размер структуры (т.е. длину результирующей байтовой строки), соответствующей формату format.

Перед символом формата может идти число, обозначающее количество повторений. Например, строка формата '4h' полностью эквивалентна строке 'hhhh'. 

>тут не понял: Символы пропуска между символами формата игнорируются, однако символы пропуска между числом и символом формата не допускаются.

Число перед символом формата 's' интерпретируется как длина строки, а не число повторений. То есть '10s' обозначает строку из 10 символов, в то время как '10c' – 10 раз по одному символу.

В следующем примере мы упаковываем в структуру два числа – целое и float, строку из пяти символов, сохраняем в бинарный файл, а потом извлекаем из файла:

```py
from struct import *

out = open("123.bin", "wb")    
data   = pack("if5s", 24,12.48,'12345')
out.write(data)
out.close()

input = open("123.bin", "rb")
data = input.read()
input.close()

format = "if5s" 
value,value2,value3 = unpack(format, data) 

print value
print value2
print value3
print calcsize(format)
 
>24
>12.4799995422
>12345
>13
```

The ordering of format characters may have an impact on size since the padding needed to satisfy alignment requirements is different (порядок символов формата может повлиять на размер структуры). Вроде такое возможно с нативными типами, поэтому лучше работать со стандартом (проверить на практике).

```py
pack('ci', b'*', 0x12131415)
>b'*\x00\x00\x00\x12\x13\x14\x15'
pack('ic', 0x12131415, b'*')
>b'\x12\x13\x14\x15*'
calcsize('ci')
>8
calcsize('ic')
>5
```

``struct.iter_unpack(format, buffer)->iterable``

Возвращает итерабельный объект, из которого в цикле можно доставать однотипные структуры.

>Проверить на практике

Модуль *struct* содержит также классы для упаковки/распаковки данных. Они выполняют те же действия и с ними вы сможете самостоятельно разобраться, когда мы изучим ООП.

